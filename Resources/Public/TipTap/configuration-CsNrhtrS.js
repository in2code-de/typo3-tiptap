const Bi = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get $brand() {
    return Nt;
  },
  get $input() {
    return nr;
  },
  get $output() {
    return er;
  },
  get NEVER() {
    return Ot;
  },
  get TimePrecision() {
    return kr;
  },
  get ZodAny() {
    return pi;
  },
  get ZodArray() {
    return _i;
  },
  get ZodBase64() {
    return ot;
  },
  get ZodBase64URL() {
    return at;
  },
  get ZodBigInt() {
    return Ye;
  },
  get ZodBigIntFormat() {
    return lt;
  },
  get ZodBoolean() {
    return Xe;
  },
  get ZodCIDRv4() {
    return rt;
  },
  get ZodCIDRv6() {
    return it;
  },
  get ZodCUID() {
    return qn;
  },
  get ZodCUID2() {
    return Yn;
  },
  get ZodCatch() {
    return Li;
  },
  get ZodCodec() {
    return vt;
  },
  get ZodCustom() {
    return tn;
  },
  get ZodCustomStringFormat() {
    return Ie;
  },
  get ZodDate() {
    return st;
  },
  get ZodDefault() {
    return Pi;
  },
  get ZodDiscriminatedUnion() {
    return Ii;
  },
  get ZodE164() {
    return ut;
  },
  get ZodEmail() {
    return Wn;
  },
  get ZodEmoji() {
    return Bn;
  },
  get ZodEnum() {
    return _e;
  },
  get ZodError() {
    return wl;
  },
  get ZodFile() {
    return Ni;
  },
  get ZodFirstPartyTypeKind() {
    return hn;
  },
  get ZodFunction() {
    return Vi;
  },
  get ZodGUID() {
    return Ne;
  },
  get ZodIPv4() {
    return nt;
  },
  get ZodIPv6() {
    return tt;
  },
  get ZodISODate() {
    return Mn;
  },
  get ZodISODateTime() {
    return Fn;
  },
  get ZodISODuration() {
    return Vn;
  },
  get ZodISOTime() {
    return Gn;
  },
  get ZodIntersection() {
    return zi;
  },
  get ZodIssueCode() {
    return gs;
  },
  get ZodJWT() {
    return ct;
  },
  get ZodKSUID() {
    return et;
  },
  get ZodLazy() {
    return Mi;
  },
  get ZodLiteral() {
    return Oi;
  },
  get ZodMAC() {
    return ri;
  },
  get ZodMap() {
    return wi;
  },
  get ZodNaN() {
    return Ci;
  },
  get ZodNanoID() {
    return Xn;
  },
  get ZodNever() {
    return hi;
  },
  get ZodNonOptional() {
    return gt;
  },
  get ZodNull() {
    return gi;
  },
  get ZodNullable() {
    return xi;
  },
  get ZodNumber() {
    return Be;
  },
  get ZodNumberFormat() {
    return se;
  },
  get ZodObject() {
    return He;
  },
  get ZodOptional() {
    return ft;
  },
  get ZodPipe() {
    return pt;
  },
  get ZodPrefault() {
    return Di;
  },
  get ZodPromise() {
    return Gi;
  },
  get ZodReadonly() {
    return Ji;
  },
  get ZodRealError() {
    return U;
  },
  get ZodRecord() {
    return en;
  },
  get ZodSet() {
    return ji;
  },
  get ZodString() {
    return Ke;
  },
  get ZodStringFormat() {
    return z;
  },
  get ZodSuccess() {
    return Ai;
  },
  get ZodSymbol() {
    return mi;
  },
  get ZodTemplateLiteral() {
    return Fi;
  },
  get ZodTransform() {
    return Ui;
  },
  get ZodTuple() {
    return Si;
  },
  get ZodType() {
    return b;
  },
  get ZodULID() {
    return Hn;
  },
  get ZodURL() {
    return We;
  },
  get ZodUUID() {
    return F;
  },
  get ZodUndefined() {
    return fi;
  },
  get ZodUnion() {
    return Qe;
  },
  get ZodUnknown() {
    return vi;
  },
  get ZodVoid() {
    return $i;
  },
  get ZodXID() {
    return Qn;
  },
  get ZodXor() {
    return yi;
  },
  get _ZodString() {
    return Kn;
  },
  get _default() {
    return Zi;
  },
  get _function() {
    return ke;
  },
  get any() {
    return H;
  },
  get array() {
    return X;
  },
  get base64() {
    return ci;
  },
  get base64url() {
    return li;
  },
  get bigint() {
    return Cl;
  },
  get boolean() {
    return qe;
  },
  get catch() {
    return Ri;
  },
  get check() {
    return us;
  },
  get cidrv4() {
    return ai;
  },
  get cidrv6() {
    return ui;
  },
  get clone() {
    return Z;
  },
  get codec() {
    return is;
  },
  get coerce() {
    return bs;
  },
  get config() {
    return w;
  },
  get core() {
    return Il;
  },
  get cuid() {
    return Yr;
  },
  get cuid2() {
    return Hr;
  },
  get custom() {
    return bt;
  },
  get date() {
    return Vl;
  },
  get decode() {
    return Rr;
  },
  get decodeAsync() {
    return Jr;
  },
  get describe() {
    return cs;
  },
  get discriminatedUnion() {
    return Xl;
  },
  get e164() {
    return si;
  },
  get email() {
    return Kr;
  },
  get emoji() {
    return Xr;
  },
  get encode() {
    return Lr;
  },
  get encodeAsync() {
    return Cr;
  },
  get endsWith() {
    return Tn;
  },
  get enum() {
    return nn;
  },
  get file() {
    return es;
  },
  get flattenError() {
    return In;
  },
  get float32() {
    return El;
  },
  get float64() {
    return Al;
  },
  get formatError() {
    return zn;
  },
  get fromJSONSchema() {
    return $s;
  },
  get function() {
    return ke;
  },
  get getErrorMap() {
    return vs;
  },
  get globalRegistry() {
    return E;
  },
  get gt() {
    return ee;
  },
  get gte() {
    return N;
  },
  get guid() {
    return jl;
  },
  get hash() {
    return Tl;
  },
  get hex() {
    return Dl;
  },
  get hostname() {
    return Zl;
  },
  get httpUrl() {
    return xl;
  },
  get includes() {
    return Zn;
  },
  get instanceof() {
    return ss;
  },
  get int() {
    return pn;
  },
  get int32() {
    return Ll;
  },
  get int64() {
    return Jl;
  },
  get intersection() {
    return K;
  },
  get ipv4() {
    return ti;
  },
  get ipv6() {
    return oi;
  },
  get iso() {
    return zl;
  },
  get json() {
    return ms;
  },
  get jwt() {
    return di;
  },
  get keyof() {
    return Kl;
  },
  get ksuid() {
    return ni;
  },
  get lazy() {
    return $t;
  },
  get length() {
    return Ge;
  },
  get literal() {
    return oe;
  },
  get locales() {
    return Qt;
  },
  get looseObject() {
    return Bl;
  },
  get looseRecord() {
    return vn;
  },
  get lowercase() {
    return xn;
  },
  get lt() {
    return Q;
  },
  get lte() {
    return A;
  },
  get mac() {
    return ii;
  },
  get map() {
    return Yl;
  },
  get maxLength() {
    return ue;
  },
  get maxSize() {
    return Me;
  },
  get meta() {
    return ls;
  },
  get mime() {
    return En;
  },
  get minLength() {
    return B;
  },
  get minSize() {
    return ve;
  },
  get multipleOf() {
    return pe;
  },
  get nan() {
    return rs;
  },
  get nanoid() {
    return qr;
  },
  get nativeEnum() {
    return Ql;
  },
  get negative() {
    return zr;
  },
  get never() {
    return V;
  },
  get nonnegative() {
    return wr;
  },
  get nonoptional() {
    return Ei;
  },
  get nonpositive() {
    return Sr;
  },
  get normalize() {
    return An;
  },
  get null() {
    return xe;
  },
  get nullable() {
    return ye;
  },
  get nullish() {
    return ns;
  },
  get number() {
    return Ue;
  },
  get object() {
    return P;
  },
  get optional() {
    return Pe;
  },
  get overwrite() {
    return Y;
  },
  get parse() {
    return Dr;
  },
  get parseAsync() {
    return Tr;
  },
  get partialRecord() {
    return ql;
  },
  get pipe() {
    return Ze;
  },
  get positive() {
    return Ir;
  },
  get prefault() {
    return Ti;
  },
  get preprocess() {
    return fs;
  },
  get prettifyError() {
    return Tt;
  },
  get promise() {
    return as;
  },
  get property() {
    return jr;
  },
  get readonly() {
    return ht;
  },
  get record() {
    return dt;
  },
  get refine() {
    return Ki;
  },
  get regex() {
    return Un;
  },
  get regexes() {
    return Sn;
  },
  get registry() {
    return jn;
  },
  get safeDecode() {
    return Mr;
  },
  get safeDecodeAsync() {
    return Vr;
  },
  get safeEncode() {
    return Fr;
  },
  get safeEncodeAsync() {
    return Gr;
  },
  get safeParse() {
    return Er;
  },
  get safeParseAsync() {
    return Ar;
  },
  get set() {
    return Hl;
  },
  get setErrorMap() {
    return ps;
  },
  get size() {
    return Nn;
  },
  get slugify() {
    return Jn;
  },
  get startsWith() {
    return Dn;
  },
  get strictObject() {
    return Wl;
  },
  get string() {
    return x;
  },
  get stringFormat() {
    return Pl;
  },
  get stringbool() {
    return ds;
  },
  get success() {
    return ts;
  },
  get superRefine() {
    return Wi;
  },
  get symbol() {
    return Ml;
  },
  get templateLiteral() {
    return os;
  },
  get toJSONSchema() {
    return Nr;
  },
  get toLowerCase() {
    return Rn;
  },
  get toUpperCase() {
    return Cn;
  },
  get transform() {
    return mt;
  },
  get treeifyError() {
    return Dt;
  },
  get trim() {
    return Ln;
  },
  get tuple() {
    return G;
  },
  get uint32() {
    return Rl;
  },
  get uint64() {
    return Fl;
  },
  get ulid() {
    return Qr;
  },
  get undefined() {
    return Gl;
  },
  get union() {
    return ce;
  },
  get unknown() {
    return ne;
  },
  get uppercase() {
    return Pn;
  },
  get url() {
    return Br;
  },
  get util() {
    return Pt;
  },
  get uuid() {
    return Wr;
  },
  get uuidv4() {
    return Ol;
  },
  get uuidv6() {
    return Nl;
  },
  get uuidv7() {
    return Ul;
  },
  get void() {
    return bi;
  },
  get xid() {
    return ei;
  },
  get xor() {
    return ki;
  }
}, Symbol.toStringTag, { value: "Module" })), Ot = Object.freeze({
  status: "aborted"
});
function s(e, t, i) {
  function r(u, l) {
    if (u._zod || Object.defineProperty(u, "_zod", {
      value: {
        def: l,
        constr: a,
        traits: /* @__PURE__ */ new Set()
      },
      enumerable: !1
    }), u._zod.traits.has(e))
      return;
    u._zod.traits.add(e), t(u, l);
    const c = a.prototype, d = Object.keys(c);
    for (let f = 0; f < d.length; f++) {
      const p = d[f];
      p in u || (u[p] = c[p].bind(u));
    }
  }
  const n = i?.Parent ?? Object;
  class o extends n {
  }
  Object.defineProperty(o, "name", { value: e });
  function a(u) {
    var l;
    const c = i?.Parent ? new o() : this;
    r(c, u), (l = c._zod).deferred ?? (l.deferred = []);
    for (const d of c._zod.deferred)
      d();
    return c;
  }
  return Object.defineProperty(a, "init", { value: r }), Object.defineProperty(a, Symbol.hasInstance, {
    value: (u) => i?.Parent && u instanceof i.Parent ? !0 : u?._zod?.traits?.has(e)
  }), Object.defineProperty(a, "name", { value: e }), a;
}
const Nt = /* @__PURE__ */ Symbol("zod_brand");
class ie extends Error {
  constructor() {
    super("Encountered Promise during synchronous parse. Use .parseAsync() instead.");
  }
}
class $n extends Error {
  constructor(t) {
    super(`Encountered unidirectional transform during encode: ${t}`), this.name = "ZodEncodeError";
  }
}
const sn = {};
function w(e) {
  return e && Object.assign(sn, e), sn;
}
function ks(e) {
  return e;
}
function Is(e) {
  return e;
}
function zs(e) {
}
function Ss(e) {
  throw new Error("Unexpected value in exhaustive check");
}
function ws(e) {
}
function Ut(e) {
  const t = Object.values(e).filter((r) => typeof r == "number");
  return Object.entries(e).filter(([r, n]) => t.indexOf(+r) === -1).map(([r, n]) => n);
}
function g(e, t = "|") {
  return e.map((i) => h(i)).join(t);
}
function dn(e, t) {
  return typeof t == "bigint" ? t.toString() : t;
}
function De(e) {
  return {
    get value() {
      {
        const t = e();
        return Object.defineProperty(this, "value", { value: t }), t;
      }
    }
  };
}
function le(e) {
  return e == null;
}
function bn(e) {
  const t = e.startsWith("^") ? 1 : 0, i = e.endsWith("$") ? e.length - 1 : e.length;
  return e.slice(t, i);
}
function go(e, t) {
  const i = (e.toString().split(".")[1] || "").length, r = t.toString();
  let n = (r.split(".")[1] || "").length;
  if (n === 0 && /\d?e-\d?/.test(r)) {
    const l = r.match(/\d?e-(\d?)/);
    l?.[1] && (n = Number.parseInt(l[1]));
  }
  const o = i > n ? i : n, a = Number.parseInt(e.toFixed(o).replace(".", "")), u = Number.parseInt(t.toFixed(o).replace(".", ""));
  return a % u / 10 ** o;
}
const Xi = /* @__PURE__ */ Symbol("evaluating");
function _(e, t, i) {
  let r;
  Object.defineProperty(e, t, {
    get() {
      if (r !== Xi)
        return r === void 0 && (r = Xi, r = i()), r;
    },
    set(n) {
      Object.defineProperty(e, t, {
        value: n
        // configurable: true,
      });
    },
    configurable: !0
  });
}
function js(e) {
  return Object.create(Object.getPrototypeOf(e), Object.getOwnPropertyDescriptors(e));
}
function te(e, t, i) {
  Object.defineProperty(e, t, {
    value: i,
    writable: !0,
    enumerable: !0,
    configurable: !0
  });
}
function q(...e) {
  const t = {};
  for (const i of e) {
    const r = Object.getOwnPropertyDescriptors(i);
    Object.assign(t, r);
  }
  return Object.defineProperties({}, t);
}
function Os(e) {
  return q(e._zod.def);
}
function Ns(e, t) {
  return t ? t.reduce((i, r) => i?.[r], e) : e;
}
function Us(e) {
  const t = Object.keys(e), i = t.map((r) => e[r]);
  return Promise.all(i).then((r) => {
    const n = {};
    for (let o = 0; o < t.length; o++)
      n[t[o]] = r[o];
    return n;
  });
}
function xs(e = 10) {
  const t = "abcdefghijklmnopqrstuvwxyz";
  let i = "";
  for (let r = 0; r < e; r++)
    i += t[Math.floor(Math.random() * t.length)];
  return i;
}
function yt(e) {
  return JSON.stringify(e);
}
function po(e) {
  return e.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
const xt = "captureStackTrace" in Error ? Error.captureStackTrace : (...e) => {
};
function me(e) {
  return typeof e == "object" && e !== null && !Array.isArray(e);
}
const vo = De(() => {
  if (typeof navigator < "u" && navigator?.userAgent?.includes("Cloudflare"))
    return !1;
  try {
    const e = Function;
    return new e(""), !0;
  } catch {
    return !1;
  }
});
function ae(e) {
  if (me(e) === !1)
    return !1;
  const t = e.constructor;
  if (t === void 0 || typeof t != "function")
    return !0;
  const i = t.prototype;
  return !(me(i) === !1 || Object.prototype.hasOwnProperty.call(i, "isPrototypeOf") === !1);
}
function _n(e) {
  return ae(e) ? { ...e } : Array.isArray(e) ? [...e] : e;
}
function Ps(e) {
  let t = 0;
  for (const i in e)
    Object.prototype.hasOwnProperty.call(e, i) && t++;
  return t;
}
const Zs = (e) => {
  const t = typeof e;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(e) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      return Array.isArray(e) ? "array" : e === null ? "null" : e.then && typeof e.then == "function" && e.catch && typeof e.catch == "function" ? "promise" : typeof Map < "u" && e instanceof Map ? "map" : typeof Set < "u" && e instanceof Set ? "set" : typeof Date < "u" && e instanceof Date ? "date" : typeof File < "u" && e instanceof File ? "file" : "object";
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
}, mn = /* @__PURE__ */ new Set(["string", "number", "symbol"]), ho = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function W(e) {
  return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Z(e, t, i) {
  const r = new e._zod.constr(t ?? e._zod.def);
  return (!t || i?.parent) && (r._zod.parent = e), r;
}
function m(e) {
  const t = e;
  if (!t)
    return {};
  if (typeof t == "string")
    return { error: () => t };
  if (t?.message !== void 0) {
    if (t?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    t.error = t.message;
  }
  return delete t.message, typeof t.error == "string" ? { ...t, error: () => t.error } : t;
}
function Ds(e) {
  let t;
  return new Proxy({}, {
    get(i, r, n) {
      return t ?? (t = e()), Reflect.get(t, r, n);
    },
    set(i, r, n, o) {
      return t ?? (t = e()), Reflect.set(t, r, n, o);
    },
    has(i, r) {
      return t ?? (t = e()), Reflect.has(t, r);
    },
    deleteProperty(i, r) {
      return t ?? (t = e()), Reflect.deleteProperty(t, r);
    },
    ownKeys(i) {
      return t ?? (t = e()), Reflect.ownKeys(t);
    },
    getOwnPropertyDescriptor(i, r) {
      return t ?? (t = e()), Reflect.getOwnPropertyDescriptor(t, r);
    },
    defineProperty(i, r, n) {
      return t ?? (t = e()), Reflect.defineProperty(t, r, n);
    }
  });
}
function h(e) {
  return typeof e == "bigint" ? e.toString() + "n" : typeof e == "string" ? `"${e}"` : `${e}`;
}
function $o(e) {
  return Object.keys(e).filter((t) => e[t]._zod.optin === "optional" && e[t]._zod.optout === "optional");
}
const bo = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
}, _o = {
  int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
  uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
};
function yo(e, t) {
  const i = e._zod.def, r = q(e._zod.def, {
    get shape() {
      const n = {};
      for (const o in t) {
        if (!(o in i.shape))
          throw new Error(`Unrecognized key: "${o}"`);
        t[o] && (n[o] = i.shape[o]);
      }
      return te(this, "shape", n), n;
    },
    checks: []
  });
  return Z(e, r);
}
function ko(e, t) {
  const i = e._zod.def, r = q(e._zod.def, {
    get shape() {
      const n = { ...e._zod.def.shape };
      for (const o in t) {
        if (!(o in i.shape))
          throw new Error(`Unrecognized key: "${o}"`);
        t[o] && delete n[o];
      }
      return te(this, "shape", n), n;
    },
    checks: []
  });
  return Z(e, r);
}
function Io(e, t) {
  if (!ae(t))
    throw new Error("Invalid input to extend: expected a plain object");
  const i = e._zod.def.checks;
  if (i && i.length > 0)
    throw new Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.");
  const n = q(e._zod.def, {
    get shape() {
      const o = { ...e._zod.def.shape, ...t };
      return te(this, "shape", o), o;
    },
    checks: []
  });
  return Z(e, n);
}
function zo(e, t) {
  if (!ae(t))
    throw new Error("Invalid input to safeExtend: expected a plain object");
  const i = {
    ...e._zod.def,
    get shape() {
      const r = { ...e._zod.def.shape, ...t };
      return te(this, "shape", r), r;
    },
    checks: e._zod.def.checks
  };
  return Z(e, i);
}
function So(e, t) {
  const i = q(e._zod.def, {
    get shape() {
      const r = { ...e._zod.def.shape, ...t._zod.def.shape };
      return te(this, "shape", r), r;
    },
    get catchall() {
      return t._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return Z(e, i);
}
function wo(e, t, i) {
  const r = q(t._zod.def, {
    get shape() {
      const n = t._zod.def.shape, o = { ...n };
      if (i)
        for (const a in i) {
          if (!(a in n))
            throw new Error(`Unrecognized key: "${a}"`);
          i[a] && (o[a] = e ? new e({
            type: "optional",
            innerType: n[a]
          }) : n[a]);
        }
      else
        for (const a in n)
          o[a] = e ? new e({
            type: "optional",
            innerType: n[a]
          }) : n[a];
      return te(this, "shape", o), o;
    },
    checks: []
  });
  return Z(t, r);
}
function jo(e, t, i) {
  const r = q(t._zod.def, {
    get shape() {
      const n = t._zod.def.shape, o = { ...n };
      if (i)
        for (const a in i) {
          if (!(a in o))
            throw new Error(`Unrecognized key: "${a}"`);
          i[a] && (o[a] = new e({
            type: "nonoptional",
            innerType: n[a]
          }));
        }
      else
        for (const a in n)
          o[a] = new e({
            type: "nonoptional",
            innerType: n[a]
          });
      return te(this, "shape", o), o;
    },
    checks: []
  });
  return Z(t, r);
}
function re(e, t = 0) {
  if (e.aborted === !0)
    return !0;
  for (let i = t; i < e.issues.length; i++)
    if (e.issues[i]?.continue !== !0)
      return !0;
  return !1;
}
function C(e, t) {
  return t.map((i) => {
    var r;
    return (r = i).path ?? (r.path = []), i.path.unshift(e), i;
  });
}
function we(e) {
  return typeof e == "string" ? e : e?.message;
}
function L(e, t, i) {
  const r = { ...e, path: e.path ?? [] };
  if (!e.message) {
    const n = we(e.inst?._zod.def?.error?.(e)) ?? we(t?.error?.(e)) ?? we(i.customError?.(e)) ?? we(i.localeError?.(e)) ?? "Invalid input";
    r.message = n;
  }
  return delete r.inst, delete r.continue, t?.reportInput || delete r.input, r;
}
function yn(e) {
  return e instanceof Set ? "set" : e instanceof Map ? "map" : e instanceof File ? "file" : "unknown";
}
function kn(e) {
  return Array.isArray(e) ? "array" : typeof e == "string" ? "string" : "unknown";
}
function fe(...e) {
  const [t, i, r] = e;
  return typeof t == "string" ? {
    message: t,
    code: "custom",
    input: i,
    inst: r
  } : { ...t };
}
function Ts(e) {
  return Object.entries(e).filter(([t, i]) => Number.isNaN(Number.parseInt(t, 10))).map((t) => t[1]);
}
function Oo(e) {
  const t = atob(e), i = new Uint8Array(t.length);
  for (let r = 0; r < t.length; r++)
    i[r] = t.charCodeAt(r);
  return i;
}
function No(e) {
  let t = "";
  for (let i = 0; i < e.length; i++)
    t += String.fromCharCode(e[i]);
  return btoa(t);
}
function Es(e) {
  const t = e.replace(/-/g, "+").replace(/_/g, "/"), i = "=".repeat((4 - t.length % 4) % 4);
  return Oo(t + i);
}
function As(e) {
  return No(e).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function Ls(e) {
  const t = e.replace(/^0x/, "");
  if (t.length % 2 !== 0)
    throw new Error("Invalid hex string length");
  const i = new Uint8Array(t.length / 2);
  for (let r = 0; r < t.length; r += 2)
    i[r / 2] = Number.parseInt(t.slice(r, r + 2), 16);
  return i;
}
function Rs(e) {
  return Array.from(e).map((t) => t.toString(16).padStart(2, "0")).join("");
}
class Cs {
  constructor(...t) {
  }
}
const Pt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BIGINT_FORMAT_RANGES: _o,
  Class: Cs,
  NUMBER_FORMAT_RANGES: bo,
  aborted: re,
  allowsEval: vo,
  assert: ws,
  assertEqual: ks,
  assertIs: zs,
  assertNever: Ss,
  assertNotEqual: Is,
  assignProp: te,
  base64ToUint8Array: Oo,
  base64urlToUint8Array: Es,
  cached: De,
  captureStackTrace: xt,
  cleanEnum: Ts,
  cleanRegex: bn,
  clone: Z,
  cloneDef: Os,
  createTransparentProxy: Ds,
  defineLazy: _,
  esc: yt,
  escapeRegex: W,
  extend: Io,
  finalizeIssue: L,
  floatSafeRemainder: go,
  getElementAtPath: Ns,
  getEnumValues: Ut,
  getLengthableOrigin: kn,
  getParsedType: Zs,
  getSizableOrigin: yn,
  hexToUint8Array: Ls,
  isObject: me,
  isPlainObject: ae,
  issue: fe,
  joinValues: g,
  jsonStringifyReplacer: dn,
  merge: So,
  mergeDefs: q,
  normalizeParams: m,
  nullish: le,
  numKeys: Ps,
  objectClone: js,
  omit: ko,
  optionalKeys: $o,
  partial: wo,
  pick: yo,
  prefixIssues: C,
  primitiveTypes: ho,
  promiseAllObject: Us,
  propertyKeyTypes: mn,
  randomString: xs,
  required: jo,
  safeExtend: zo,
  shallowClone: _n,
  slugify: po,
  stringifyPrimitive: h,
  uint8ArrayToBase64: No,
  uint8ArrayToBase64url: As,
  uint8ArrayToHex: Rs,
  unwrapMessage: we
}, Symbol.toStringTag, { value: "Module" })), Uo = (e, t) => {
  e.name = "$ZodError", Object.defineProperty(e, "_zod", {
    value: e._zod,
    enumerable: !1
  }), Object.defineProperty(e, "issues", {
    value: t,
    enumerable: !1
  }), e.message = JSON.stringify(t, dn, 2), Object.defineProperty(e, "toString", {
    value: () => e.message,
    enumerable: !1
  });
}, Zt = s("$ZodError", Uo), D = s("$ZodError", Uo, { Parent: Error });
function In(e, t = (i) => i.message) {
  const i = {}, r = [];
  for (const n of e.issues)
    n.path.length > 0 ? (i[n.path[0]] = i[n.path[0]] || [], i[n.path[0]].push(t(n))) : r.push(t(n));
  return { formErrors: r, fieldErrors: i };
}
function zn(e, t = (i) => i.message) {
  const i = { _errors: [] }, r = (n) => {
    for (const o of n.issues)
      if (o.code === "invalid_union" && o.errors.length)
        o.errors.map((a) => r({ issues: a }));
      else if (o.code === "invalid_key")
        r({ issues: o.issues });
      else if (o.code === "invalid_element")
        r({ issues: o.issues });
      else if (o.path.length === 0)
        i._errors.push(t(o));
      else {
        let a = i, u = 0;
        for (; u < o.path.length; ) {
          const l = o.path[u];
          u === o.path.length - 1 ? (a[l] = a[l] || { _errors: [] }, a[l]._errors.push(t(o))) : a[l] = a[l] || { _errors: [] }, a = a[l], u++;
        }
      }
  };
  return r(e), i;
}
function Dt(e, t = (i) => i.message) {
  const i = { errors: [] }, r = (n, o = []) => {
    var a, u;
    for (const l of n.issues)
      if (l.code === "invalid_union" && l.errors.length)
        l.errors.map((c) => r({ issues: c }, l.path));
      else if (l.code === "invalid_key")
        r({ issues: l.issues }, l.path);
      else if (l.code === "invalid_element")
        r({ issues: l.issues }, l.path);
      else {
        const c = [...o, ...l.path];
        if (c.length === 0) {
          i.errors.push(t(l));
          continue;
        }
        let d = i, f = 0;
        for (; f < c.length; ) {
          const p = c[f], v = f === c.length - 1;
          typeof p == "string" ? (d.properties ?? (d.properties = {}), (a = d.properties)[p] ?? (a[p] = { errors: [] }), d = d.properties[p]) : (d.items ?? (d.items = []), (u = d.items)[p] ?? (u[p] = { errors: [] }), d = d.items[p]), v && d.errors.push(t(l)), f++;
        }
      }
  };
  return r(e), i;
}
function xo(e) {
  const t = [], i = e.map((r) => typeof r == "object" ? r.key : r);
  for (const r of i)
    typeof r == "number" ? t.push(`[${r}]`) : typeof r == "symbol" ? t.push(`[${JSON.stringify(String(r))}]`) : /[^\w$]/.test(r) ? t.push(`[${JSON.stringify(r)}]`) : (t.length && t.push("."), t.push(r));
  return t.join("");
}
function Tt(e) {
  const t = [], i = [...e.issues].sort((r, n) => (r.path ?? []).length - (n.path ?? []).length);
  for (const r of i)
    t.push(`✖ ${r.message}`), r.path?.length && t.push(`  → at ${xo(r.path)}`);
  return t.join(`
`);
}
const Te = (e) => (t, i, r, n) => {
  const o = r ? Object.assign(r, { async: !1 }) : { async: !1 }, a = t._zod.run({ value: i, issues: [] }, o);
  if (a instanceof Promise)
    throw new ie();
  if (a.issues.length) {
    const u = new (n?.Err ?? e)(a.issues.map((l) => L(l, o, w())));
    throw xt(u, n?.callee), u;
  }
  return a.value;
}, kt = /* @__PURE__ */ Te(D), Ee = (e) => async (t, i, r, n) => {
  const o = r ? Object.assign(r, { async: !0 }) : { async: !0 };
  let a = t._zod.run({ value: i, issues: [] }, o);
  if (a instanceof Promise && (a = await a), a.issues.length) {
    const u = new (n?.Err ?? e)(a.issues.map((l) => L(l, o, w())));
    throw xt(u, n?.callee), u;
  }
  return a.value;
}, It = /* @__PURE__ */ Ee(D), Ae = (e) => (t, i, r) => {
  const n = r ? { ...r, async: !1 } : { async: !1 }, o = t._zod.run({ value: i, issues: [] }, n);
  if (o instanceof Promise)
    throw new ie();
  return o.issues.length ? {
    success: !1,
    error: new (e ?? Zt)(o.issues.map((a) => L(a, n, w())))
  } : { success: !0, data: o.value };
}, Po = /* @__PURE__ */ Ae(D), Le = (e) => async (t, i, r) => {
  const n = r ? Object.assign(r, { async: !0 }) : { async: !0 };
  let o = t._zod.run({ value: i, issues: [] }, n);
  return o instanceof Promise && (o = await o), o.issues.length ? {
    success: !1,
    error: new e(o.issues.map((a) => L(a, n, w())))
  } : { success: !0, data: o.value };
}, Zo = /* @__PURE__ */ Le(D), Et = (e) => (t, i, r) => {
  const n = r ? Object.assign(r, { direction: "backward" }) : { direction: "backward" };
  return Te(e)(t, i, n);
}, Js = /* @__PURE__ */ Et(D), At = (e) => (t, i, r) => Te(e)(t, i, r), Fs = /* @__PURE__ */ At(D), Lt = (e) => async (t, i, r) => {
  const n = r ? Object.assign(r, { direction: "backward" }) : { direction: "backward" };
  return Ee(e)(t, i, n);
}, Ms = /* @__PURE__ */ Lt(D), Rt = (e) => async (t, i, r) => Ee(e)(t, i, r), Gs = /* @__PURE__ */ Rt(D), Ct = (e) => (t, i, r) => {
  const n = r ? Object.assign(r, { direction: "backward" }) : { direction: "backward" };
  return Ae(e)(t, i, n);
}, Vs = /* @__PURE__ */ Ct(D), Jt = (e) => (t, i, r) => Ae(e)(t, i, r), Ks = /* @__PURE__ */ Jt(D), Ft = (e) => async (t, i, r) => {
  const n = r ? Object.assign(r, { direction: "backward" }) : { direction: "backward" };
  return Le(e)(t, i, n);
}, Ws = /* @__PURE__ */ Ft(D), Mt = (e) => async (t, i, r) => Le(e)(t, i, r), Bs = /* @__PURE__ */ Mt(D), Do = /^[cC][^\s-]{8,}$/, To = /^[0-9a-z]+$/, Eo = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/, Ao = /^[0-9a-vA-V]{20}$/, Lo = /^[A-Za-z0-9]{27}$/, Ro = /^[a-zA-Z0-9_-]{21}$/, Co = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/, Xs = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, Jo = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/, ge = (e) => e ? new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${e}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`) : /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/, qs = /* @__PURE__ */ ge(4), Ys = /* @__PURE__ */ ge(6), Hs = /* @__PURE__ */ ge(7), Fo = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/, Qs = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/, ed = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/, Mo = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u, nd = Mo, td = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/, rd = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
function Go() {
  return new RegExp(rd, "u");
}
const Vo = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, Ko = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/, Wo = (e) => {
  const t = W(e ?? ":");
  return new RegExp(`^(?:[0-9A-F]{2}${t}){5}[0-9A-F]{2}$|^(?:[0-9a-f]{2}${t}){5}[0-9a-f]{2}$`);
}, Bo = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/, Xo = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, qo = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/, Gt = /^[A-Za-z0-9_-]*$/, Yo = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/, Ho = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/, Qo = /^\+(?:[0-9]){6,14}[0-9]$/, ea = "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))", na = /* @__PURE__ */ new RegExp(`^${ea}$`);
function ta(e) {
  const t = "(?:[01]\\d|2[0-3]):[0-5]\\d";
  return typeof e.precision == "number" ? e.precision === -1 ? `${t}` : e.precision === 0 ? `${t}:[0-5]\\d` : `${t}:[0-5]\\d\\.\\d{${e.precision}}` : `${t}(?::[0-5]\\d(?:\\.\\d+)?)?`;
}
function ra(e) {
  return new RegExp(`^${ta(e)}$`);
}
function ia(e) {
  const t = ta({ precision: e.precision }), i = ["Z"];
  e.local && i.push(""), e.offset && i.push("([+-](?:[01]\\d|2[0-3]):[0-5]\\d)");
  const r = `${t}(?:${i.join("|")})`;
  return new RegExp(`^${ea}T(?:${r})$`);
}
const oa = (e) => {
  const t = e ? `[\\s\\S]{${e?.minimum ?? 0},${e?.maximum ?? ""}}` : "[\\s\\S]*";
  return new RegExp(`^${t}$`);
}, aa = /^-?\d+n?$/, ua = /^-?\d+$/, ca = /^-?\d+(?:\.\d+)?/, la = /^(?:true|false)$/i, sa = /^null$/i, da = /^undefined$/i, ma = /^[^A-Z]*$/, fa = /^[^a-z]*$/, ga = /^[0-9a-fA-F]*$/;
function Re(e, t) {
  return new RegExp(`^[A-Za-z0-9+/]{${e}}${t}$`);
}
function Ce(e) {
  return new RegExp(`^[A-Za-z0-9_-]{${e}}$`);
}
const id = /^[0-9a-fA-F]{32}$/, od = /* @__PURE__ */ Re(22, "=="), ad = /* @__PURE__ */ Ce(22), ud = /^[0-9a-fA-F]{40}$/, cd = /* @__PURE__ */ Re(27, "="), ld = /* @__PURE__ */ Ce(27), sd = /^[0-9a-fA-F]{64}$/, dd = /* @__PURE__ */ Re(43, "="), md = /* @__PURE__ */ Ce(43), fd = /^[0-9a-fA-F]{96}$/, gd = /* @__PURE__ */ Re(64, ""), pd = /* @__PURE__ */ Ce(64), vd = /^[0-9a-fA-F]{128}$/, hd = /* @__PURE__ */ Re(86, "=="), $d = /* @__PURE__ */ Ce(86), Sn = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64: qo,
  base64url: Gt,
  bigint: aa,
  boolean: la,
  browserEmail: td,
  cidrv4: Bo,
  cidrv6: Xo,
  cuid: Do,
  cuid2: To,
  date: na,
  datetime: ia,
  domain: Ho,
  duration: Co,
  e164: Qo,
  email: Fo,
  emoji: Go,
  extendedDuration: Xs,
  guid: Jo,
  hex: ga,
  hostname: Yo,
  html5Email: Qs,
  idnEmail: nd,
  integer: ua,
  ipv4: Vo,
  ipv6: Ko,
  ksuid: Lo,
  lowercase: ma,
  mac: Wo,
  md5_base64: od,
  md5_base64url: ad,
  md5_hex: id,
  nanoid: Ro,
  null: sa,
  number: ca,
  rfc5322Email: ed,
  sha1_base64: cd,
  sha1_base64url: ld,
  sha1_hex: ud,
  sha256_base64: dd,
  sha256_base64url: md,
  sha256_hex: sd,
  sha384_base64: gd,
  sha384_base64url: pd,
  sha384_hex: fd,
  sha512_base64: hd,
  sha512_base64url: $d,
  sha512_hex: vd,
  string: oa,
  time: ra,
  ulid: Eo,
  undefined: da,
  unicodeEmail: Mo,
  uppercase: fa,
  uuid: ge,
  uuid4: qs,
  uuid6: Ys,
  uuid7: Hs,
  xid: Ao
}, Symbol.toStringTag, { value: "Module" })), S = /* @__PURE__ */ s("$ZodCheck", (e, t) => {
  var i;
  e._zod ?? (e._zod = {}), e._zod.def = t, (i = e._zod).onattach ?? (i.onattach = []);
}), pa = {
  number: "number",
  bigint: "bigint",
  object: "date"
}, Vt = /* @__PURE__ */ s("$ZodCheckLessThan", (e, t) => {
  S.init(e, t);
  const i = pa[typeof t.value];
  e._zod.onattach.push((r) => {
    const n = r._zod.bag, o = (t.inclusive ? n.maximum : n.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    t.value < o && (t.inclusive ? n.maximum = t.value : n.exclusiveMaximum = t.value);
  }), e._zod.check = (r) => {
    (t.inclusive ? r.value <= t.value : r.value < t.value) || r.issues.push({
      origin: i,
      code: "too_big",
      maximum: t.value,
      input: r.value,
      inclusive: t.inclusive,
      inst: e,
      continue: !t.abort
    });
  };
}), Kt = /* @__PURE__ */ s("$ZodCheckGreaterThan", (e, t) => {
  S.init(e, t);
  const i = pa[typeof t.value];
  e._zod.onattach.push((r) => {
    const n = r._zod.bag, o = (t.inclusive ? n.minimum : n.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    t.value > o && (t.inclusive ? n.minimum = t.value : n.exclusiveMinimum = t.value);
  }), e._zod.check = (r) => {
    (t.inclusive ? r.value >= t.value : r.value > t.value) || r.issues.push({
      origin: i,
      code: "too_small",
      minimum: t.value,
      input: r.value,
      inclusive: t.inclusive,
      inst: e,
      continue: !t.abort
    });
  };
}), va = /* @__PURE__ */ s("$ZodCheckMultipleOf", (e, t) => {
  S.init(e, t), e._zod.onattach.push((i) => {
    var r;
    (r = i._zod.bag).multipleOf ?? (r.multipleOf = t.value);
  }), e._zod.check = (i) => {
    if (typeof i.value != typeof t.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    (typeof i.value == "bigint" ? i.value % t.value === BigInt(0) : go(i.value, t.value) === 0) || i.issues.push({
      origin: typeof i.value,
      code: "not_multiple_of",
      divisor: t.value,
      input: i.value,
      inst: e,
      continue: !t.abort
    });
  };
}), ha = /* @__PURE__ */ s("$ZodCheckNumberFormat", (e, t) => {
  S.init(e, t), t.format = t.format || "float64";
  const i = t.format?.includes("int"), r = i ? "int" : "number", [n, o] = bo[t.format];
  e._zod.onattach.push((a) => {
    const u = a._zod.bag;
    u.format = t.format, u.minimum = n, u.maximum = o, i && (u.pattern = ua);
  }), e._zod.check = (a) => {
    const u = a.value;
    if (i) {
      if (!Number.isInteger(u)) {
        a.issues.push({
          expected: r,
          format: t.format,
          code: "invalid_type",
          continue: !1,
          input: u,
          inst: e
        });
        return;
      }
      if (!Number.isSafeInteger(u)) {
        u > 0 ? a.issues.push({
          input: u,
          code: "too_big",
          maximum: Number.MAX_SAFE_INTEGER,
          note: "Integers must be within the safe integer range.",
          inst: e,
          origin: r,
          continue: !t.abort
        }) : a.issues.push({
          input: u,
          code: "too_small",
          minimum: Number.MIN_SAFE_INTEGER,
          note: "Integers must be within the safe integer range.",
          inst: e,
          origin: r,
          continue: !t.abort
        });
        return;
      }
    }
    u < n && a.issues.push({
      origin: "number",
      input: u,
      code: "too_small",
      minimum: n,
      inclusive: !0,
      inst: e,
      continue: !t.abort
    }), u > o && a.issues.push({
      origin: "number",
      input: u,
      code: "too_big",
      maximum: o,
      inst: e
    });
  };
}), $a = /* @__PURE__ */ s("$ZodCheckBigIntFormat", (e, t) => {
  S.init(e, t);
  const [i, r] = _o[t.format];
  e._zod.onattach.push((n) => {
    const o = n._zod.bag;
    o.format = t.format, o.minimum = i, o.maximum = r;
  }), e._zod.check = (n) => {
    const o = n.value;
    o < i && n.issues.push({
      origin: "bigint",
      input: o,
      code: "too_small",
      minimum: i,
      inclusive: !0,
      inst: e,
      continue: !t.abort
    }), o > r && n.issues.push({
      origin: "bigint",
      input: o,
      code: "too_big",
      maximum: r,
      inst: e
    });
  };
}), ba = /* @__PURE__ */ s("$ZodCheckMaxSize", (e, t) => {
  var i;
  S.init(e, t), (i = e._zod.def).when ?? (i.when = (r) => {
    const n = r.value;
    return !le(n) && n.size !== void 0;
  }), e._zod.onattach.push((r) => {
    const n = r._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    t.maximum < n && (r._zod.bag.maximum = t.maximum);
  }), e._zod.check = (r) => {
    const n = r.value;
    n.size <= t.maximum || r.issues.push({
      origin: yn(n),
      code: "too_big",
      maximum: t.maximum,
      inclusive: !0,
      input: n,
      inst: e,
      continue: !t.abort
    });
  };
}), _a = /* @__PURE__ */ s("$ZodCheckMinSize", (e, t) => {
  var i;
  S.init(e, t), (i = e._zod.def).when ?? (i.when = (r) => {
    const n = r.value;
    return !le(n) && n.size !== void 0;
  }), e._zod.onattach.push((r) => {
    const n = r._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    t.minimum > n && (r._zod.bag.minimum = t.minimum);
  }), e._zod.check = (r) => {
    const n = r.value;
    n.size >= t.minimum || r.issues.push({
      origin: yn(n),
      code: "too_small",
      minimum: t.minimum,
      inclusive: !0,
      input: n,
      inst: e,
      continue: !t.abort
    });
  };
}), ya = /* @__PURE__ */ s("$ZodCheckSizeEquals", (e, t) => {
  var i;
  S.init(e, t), (i = e._zod.def).when ?? (i.when = (r) => {
    const n = r.value;
    return !le(n) && n.size !== void 0;
  }), e._zod.onattach.push((r) => {
    const n = r._zod.bag;
    n.minimum = t.size, n.maximum = t.size, n.size = t.size;
  }), e._zod.check = (r) => {
    const n = r.value, o = n.size;
    if (o === t.size)
      return;
    const a = o > t.size;
    r.issues.push({
      origin: yn(n),
      ...a ? { code: "too_big", maximum: t.size } : { code: "too_small", minimum: t.size },
      inclusive: !0,
      exact: !0,
      input: r.value,
      inst: e,
      continue: !t.abort
    });
  };
}), ka = /* @__PURE__ */ s("$ZodCheckMaxLength", (e, t) => {
  var i;
  S.init(e, t), (i = e._zod.def).when ?? (i.when = (r) => {
    const n = r.value;
    return !le(n) && n.length !== void 0;
  }), e._zod.onattach.push((r) => {
    const n = r._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    t.maximum < n && (r._zod.bag.maximum = t.maximum);
  }), e._zod.check = (r) => {
    const n = r.value;
    if (n.length <= t.maximum)
      return;
    const a = kn(n);
    r.issues.push({
      origin: a,
      code: "too_big",
      maximum: t.maximum,
      inclusive: !0,
      input: n,
      inst: e,
      continue: !t.abort
    });
  };
}), Ia = /* @__PURE__ */ s("$ZodCheckMinLength", (e, t) => {
  var i;
  S.init(e, t), (i = e._zod.def).when ?? (i.when = (r) => {
    const n = r.value;
    return !le(n) && n.length !== void 0;
  }), e._zod.onattach.push((r) => {
    const n = r._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    t.minimum > n && (r._zod.bag.minimum = t.minimum);
  }), e._zod.check = (r) => {
    const n = r.value;
    if (n.length >= t.minimum)
      return;
    const a = kn(n);
    r.issues.push({
      origin: a,
      code: "too_small",
      minimum: t.minimum,
      inclusive: !0,
      input: n,
      inst: e,
      continue: !t.abort
    });
  };
}), za = /* @__PURE__ */ s("$ZodCheckLengthEquals", (e, t) => {
  var i;
  S.init(e, t), (i = e._zod.def).when ?? (i.when = (r) => {
    const n = r.value;
    return !le(n) && n.length !== void 0;
  }), e._zod.onattach.push((r) => {
    const n = r._zod.bag;
    n.minimum = t.length, n.maximum = t.length, n.length = t.length;
  }), e._zod.check = (r) => {
    const n = r.value, o = n.length;
    if (o === t.length)
      return;
    const a = kn(n), u = o > t.length;
    r.issues.push({
      origin: a,
      ...u ? { code: "too_big", maximum: t.length } : { code: "too_small", minimum: t.length },
      inclusive: !0,
      exact: !0,
      input: r.value,
      inst: e,
      continue: !t.abort
    });
  };
}), Je = /* @__PURE__ */ s("$ZodCheckStringFormat", (e, t) => {
  var i, r;
  S.init(e, t), e._zod.onattach.push((n) => {
    const o = n._zod.bag;
    o.format = t.format, t.pattern && (o.patterns ?? (o.patterns = /* @__PURE__ */ new Set()), o.patterns.add(t.pattern));
  }), t.pattern ? (i = e._zod).check ?? (i.check = (n) => {
    t.pattern.lastIndex = 0, !t.pattern.test(n.value) && n.issues.push({
      origin: "string",
      code: "invalid_format",
      format: t.format,
      input: n.value,
      ...t.pattern ? { pattern: t.pattern.toString() } : {},
      inst: e,
      continue: !t.abort
    });
  }) : (r = e._zod).check ?? (r.check = () => {
  });
}), Sa = /* @__PURE__ */ s("$ZodCheckRegex", (e, t) => {
  Je.init(e, t), e._zod.check = (i) => {
    t.pattern.lastIndex = 0, !t.pattern.test(i.value) && i.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: i.value,
      pattern: t.pattern.toString(),
      inst: e,
      continue: !t.abort
    });
  };
}), wa = /* @__PURE__ */ s("$ZodCheckLowerCase", (e, t) => {
  t.pattern ?? (t.pattern = ma), Je.init(e, t);
}), ja = /* @__PURE__ */ s("$ZodCheckUpperCase", (e, t) => {
  t.pattern ?? (t.pattern = fa), Je.init(e, t);
}), Oa = /* @__PURE__ */ s("$ZodCheckIncludes", (e, t) => {
  S.init(e, t);
  const i = W(t.includes), r = new RegExp(typeof t.position == "number" ? `^.{${t.position}}${i}` : i);
  t.pattern = r, e._zod.onattach.push((n) => {
    const o = n._zod.bag;
    o.patterns ?? (o.patterns = /* @__PURE__ */ new Set()), o.patterns.add(r);
  }), e._zod.check = (n) => {
    n.value.includes(t.includes, t.position) || n.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: t.includes,
      input: n.value,
      inst: e,
      continue: !t.abort
    });
  };
}), Na = /* @__PURE__ */ s("$ZodCheckStartsWith", (e, t) => {
  S.init(e, t);
  const i = new RegExp(`^${W(t.prefix)}.*`);
  t.pattern ?? (t.pattern = i), e._zod.onattach.push((r) => {
    const n = r._zod.bag;
    n.patterns ?? (n.patterns = /* @__PURE__ */ new Set()), n.patterns.add(i);
  }), e._zod.check = (r) => {
    r.value.startsWith(t.prefix) || r.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: t.prefix,
      input: r.value,
      inst: e,
      continue: !t.abort
    });
  };
}), Ua = /* @__PURE__ */ s("$ZodCheckEndsWith", (e, t) => {
  S.init(e, t);
  const i = new RegExp(`.*${W(t.suffix)}$`);
  t.pattern ?? (t.pattern = i), e._zod.onattach.push((r) => {
    const n = r._zod.bag;
    n.patterns ?? (n.patterns = /* @__PURE__ */ new Set()), n.patterns.add(i);
  }), e._zod.check = (r) => {
    r.value.endsWith(t.suffix) || r.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: t.suffix,
      input: r.value,
      inst: e,
      continue: !t.abort
    });
  };
});
function qi(e, t, i) {
  e.issues.length && t.issues.push(...C(i, e.issues));
}
const xa = /* @__PURE__ */ s("$ZodCheckProperty", (e, t) => {
  S.init(e, t), e._zod.check = (i) => {
    const r = t.schema._zod.run({
      value: i.value[t.property],
      issues: []
    }, {});
    if (r instanceof Promise)
      return r.then((n) => qi(n, i, t.property));
    qi(r, i, t.property);
  };
}), Pa = /* @__PURE__ */ s("$ZodCheckMimeType", (e, t) => {
  S.init(e, t);
  const i = new Set(t.mime);
  e._zod.onattach.push((r) => {
    r._zod.bag.mime = t.mime;
  }), e._zod.check = (r) => {
    i.has(r.value.type) || r.issues.push({
      code: "invalid_value",
      values: t.mime,
      input: r.value.type,
      inst: e,
      continue: !t.abort
    });
  };
}), Za = /* @__PURE__ */ s("$ZodCheckOverwrite", (e, t) => {
  S.init(e, t), e._zod.check = (i) => {
    i.value = t.tx(i.value);
  };
});
class Da {
  constructor(t = []) {
    this.content = [], this.indent = 0, this && (this.args = t);
  }
  indented(t) {
    this.indent += 1, t(this), this.indent -= 1;
  }
  write(t) {
    if (typeof t == "function") {
      t(this, { execution: "sync" }), t(this, { execution: "async" });
      return;
    }
    const r = t.split(`
`).filter((a) => a), n = Math.min(...r.map((a) => a.length - a.trimStart().length)), o = r.map((a) => a.slice(n)).map((a) => " ".repeat(this.indent * 2) + a);
    for (const a of o)
      this.content.push(a);
  }
  compile() {
    const t = Function, i = this?.args, n = [...(this?.content ?? [""]).map((o) => `  ${o}`)];
    return new t(...i, n.join(`
`));
  }
}
const Ta = {
  major: 4,
  minor: 2,
  patch: 0
}, $ = /* @__PURE__ */ s("$ZodType", (e, t) => {
  var i;
  e ?? (e = {}), e._zod.def = t, e._zod.bag = e._zod.bag || {}, e._zod.version = Ta;
  const r = [...e._zod.def.checks ?? []];
  e._zod.traits.has("$ZodCheck") && r.unshift(e);
  for (const n of r)
    for (const o of n._zod.onattach)
      o(e);
  if (r.length === 0)
    (i = e._zod).deferred ?? (i.deferred = []), e._zod.deferred?.push(() => {
      e._zod.run = e._zod.parse;
    });
  else {
    const n = (a, u, l) => {
      let c = re(a), d;
      for (const f of u) {
        if (f._zod.def.when) {
          if (!f._zod.def.when(a))
            continue;
        } else if (c)
          continue;
        const p = a.issues.length, v = f._zod.check(a);
        if (v instanceof Promise && l?.async === !1)
          throw new ie();
        if (d || v instanceof Promise)
          d = (d ?? Promise.resolve()).then(async () => {
            await v, a.issues.length !== p && (c || (c = re(a, p)));
          });
        else {
          if (a.issues.length === p)
            continue;
          c || (c = re(a, p));
        }
      }
      return d ? d.then(() => a) : a;
    }, o = (a, u, l) => {
      if (re(a))
        return a.aborted = !0, a;
      const c = n(u, r, l);
      if (c instanceof Promise) {
        if (l.async === !1)
          throw new ie();
        return c.then((d) => e._zod.parse(d, l));
      }
      return e._zod.parse(c, l);
    };
    e._zod.run = (a, u) => {
      if (u.skipChecks)
        return e._zod.parse(a, u);
      if (u.direction === "backward") {
        const c = e._zod.parse({ value: a.value, issues: [] }, { ...u, skipChecks: !0 });
        return c instanceof Promise ? c.then((d) => o(d, a, u)) : o(c, a, u);
      }
      const l = e._zod.parse(a, u);
      if (l instanceof Promise) {
        if (u.async === !1)
          throw new ie();
        return l.then((c) => n(c, r, u));
      }
      return n(l, r, u);
    };
  }
  e["~standard"] = {
    validate: (n) => {
      try {
        const o = Po(e, n);
        return o.success ? { value: o.data } : { issues: o.error?.issues };
      } catch {
        return Zo(e, n).then((a) => a.success ? { value: a.data } : { issues: a.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  };
}), Fe = /* @__PURE__ */ s("$ZodString", (e, t) => {
  $.init(e, t), e._zod.pattern = [...e?._zod.bag?.patterns ?? []].pop() ?? oa(e._zod.bag), e._zod.parse = (i, r) => {
    if (t.coerce)
      try {
        i.value = String(i.value);
      } catch {
      }
    return typeof i.value == "string" || i.issues.push({
      expected: "string",
      code: "invalid_type",
      input: i.value,
      inst: e
    }), i;
  };
}), I = /* @__PURE__ */ s("$ZodStringFormat", (e, t) => {
  Je.init(e, t), Fe.init(e, t);
}), Ea = /* @__PURE__ */ s("$ZodGUID", (e, t) => {
  t.pattern ?? (t.pattern = Jo), I.init(e, t);
}), Aa = /* @__PURE__ */ s("$ZodUUID", (e, t) => {
  if (t.version) {
    const r = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    }[t.version];
    if (r === void 0)
      throw new Error(`Invalid UUID version: "${t.version}"`);
    t.pattern ?? (t.pattern = ge(r));
  } else
    t.pattern ?? (t.pattern = ge());
  I.init(e, t);
}), La = /* @__PURE__ */ s("$ZodEmail", (e, t) => {
  t.pattern ?? (t.pattern = Fo), I.init(e, t);
}), Ra = /* @__PURE__ */ s("$ZodURL", (e, t) => {
  I.init(e, t), e._zod.check = (i) => {
    try {
      const r = i.value.trim(), n = new URL(r);
      t.hostname && (t.hostname.lastIndex = 0, t.hostname.test(n.hostname) || i.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid hostname",
        pattern: t.hostname.source,
        input: i.value,
        inst: e,
        continue: !t.abort
      })), t.protocol && (t.protocol.lastIndex = 0, t.protocol.test(n.protocol.endsWith(":") ? n.protocol.slice(0, -1) : n.protocol) || i.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid protocol",
        pattern: t.protocol.source,
        input: i.value,
        inst: e,
        continue: !t.abort
      })), t.normalize ? i.value = n.href : i.value = r;
      return;
    } catch {
      i.issues.push({
        code: "invalid_format",
        format: "url",
        input: i.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
}), Ca = /* @__PURE__ */ s("$ZodEmoji", (e, t) => {
  t.pattern ?? (t.pattern = Go()), I.init(e, t);
}), Ja = /* @__PURE__ */ s("$ZodNanoID", (e, t) => {
  t.pattern ?? (t.pattern = Ro), I.init(e, t);
}), Fa = /* @__PURE__ */ s("$ZodCUID", (e, t) => {
  t.pattern ?? (t.pattern = Do), I.init(e, t);
}), Ma = /* @__PURE__ */ s("$ZodCUID2", (e, t) => {
  t.pattern ?? (t.pattern = To), I.init(e, t);
}), Ga = /* @__PURE__ */ s("$ZodULID", (e, t) => {
  t.pattern ?? (t.pattern = Eo), I.init(e, t);
}), Va = /* @__PURE__ */ s("$ZodXID", (e, t) => {
  t.pattern ?? (t.pattern = Ao), I.init(e, t);
}), Ka = /* @__PURE__ */ s("$ZodKSUID", (e, t) => {
  t.pattern ?? (t.pattern = Lo), I.init(e, t);
}), Wa = /* @__PURE__ */ s("$ZodISODateTime", (e, t) => {
  t.pattern ?? (t.pattern = ia(t)), I.init(e, t);
}), Ba = /* @__PURE__ */ s("$ZodISODate", (e, t) => {
  t.pattern ?? (t.pattern = na), I.init(e, t);
}), Xa = /* @__PURE__ */ s("$ZodISOTime", (e, t) => {
  t.pattern ?? (t.pattern = ra(t)), I.init(e, t);
}), qa = /* @__PURE__ */ s("$ZodISODuration", (e, t) => {
  t.pattern ?? (t.pattern = Co), I.init(e, t);
}), Ya = /* @__PURE__ */ s("$ZodIPv4", (e, t) => {
  t.pattern ?? (t.pattern = Vo), I.init(e, t), e._zod.bag.format = "ipv4";
}), Ha = /* @__PURE__ */ s("$ZodIPv6", (e, t) => {
  t.pattern ?? (t.pattern = Ko), I.init(e, t), e._zod.bag.format = "ipv6", e._zod.check = (i) => {
    try {
      new URL(`http://[${i.value}]`);
    } catch {
      i.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: i.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
}), Qa = /* @__PURE__ */ s("$ZodMAC", (e, t) => {
  t.pattern ?? (t.pattern = Wo(t.delimiter)), I.init(e, t), e._zod.bag.format = "mac";
}), eu = /* @__PURE__ */ s("$ZodCIDRv4", (e, t) => {
  t.pattern ?? (t.pattern = Bo), I.init(e, t);
}), nu = /* @__PURE__ */ s("$ZodCIDRv6", (e, t) => {
  t.pattern ?? (t.pattern = Xo), I.init(e, t), e._zod.check = (i) => {
    const r = i.value.split("/");
    try {
      if (r.length !== 2)
        throw new Error();
      const [n, o] = r;
      if (!o)
        throw new Error();
      const a = Number(o);
      if (`${a}` !== o)
        throw new Error();
      if (a < 0 || a > 128)
        throw new Error();
      new URL(`http://[${n}]`);
    } catch {
      i.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: i.value,
        inst: e,
        continue: !t.abort
      });
    }
  };
});
function Wt(e) {
  if (e === "")
    return !0;
  if (e.length % 4 !== 0)
    return !1;
  try {
    return atob(e), !0;
  } catch {
    return !1;
  }
}
const tu = /* @__PURE__ */ s("$ZodBase64", (e, t) => {
  t.pattern ?? (t.pattern = qo), I.init(e, t), e._zod.bag.contentEncoding = "base64", e._zod.check = (i) => {
    Wt(i.value) || i.issues.push({
      code: "invalid_format",
      format: "base64",
      input: i.value,
      inst: e,
      continue: !t.abort
    });
  };
});
function ru(e) {
  if (!Gt.test(e))
    return !1;
  const t = e.replace(/[-_]/g, (r) => r === "-" ? "+" : "/"), i = t.padEnd(Math.ceil(t.length / 4) * 4, "=");
  return Wt(i);
}
const iu = /* @__PURE__ */ s("$ZodBase64URL", (e, t) => {
  t.pattern ?? (t.pattern = Gt), I.init(e, t), e._zod.bag.contentEncoding = "base64url", e._zod.check = (i) => {
    ru(i.value) || i.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: i.value,
      inst: e,
      continue: !t.abort
    });
  };
}), ou = /* @__PURE__ */ s("$ZodE164", (e, t) => {
  t.pattern ?? (t.pattern = Qo), I.init(e, t);
});
function au(e, t = null) {
  try {
    const i = e.split(".");
    if (i.length !== 3)
      return !1;
    const [r] = i;
    if (!r)
      return !1;
    const n = JSON.parse(atob(r));
    return !("typ" in n && n?.typ !== "JWT" || !n.alg || t && (!("alg" in n) || n.alg !== t));
  } catch {
    return !1;
  }
}
const uu = /* @__PURE__ */ s("$ZodJWT", (e, t) => {
  I.init(e, t), e._zod.check = (i) => {
    au(i.value, t.alg) || i.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: i.value,
      inst: e,
      continue: !t.abort
    });
  };
}), cu = /* @__PURE__ */ s("$ZodCustomStringFormat", (e, t) => {
  I.init(e, t), e._zod.check = (i) => {
    t.fn(i.value) || i.issues.push({
      code: "invalid_format",
      format: t.format,
      input: i.value,
      inst: e,
      continue: !t.abort
    });
  };
}), Bt = /* @__PURE__ */ s("$ZodNumber", (e, t) => {
  $.init(e, t), e._zod.pattern = e._zod.bag.pattern ?? ca, e._zod.parse = (i, r) => {
    if (t.coerce)
      try {
        i.value = Number(i.value);
      } catch {
      }
    const n = i.value;
    if (typeof n == "number" && !Number.isNaN(n) && Number.isFinite(n))
      return i;
    const o = typeof n == "number" ? Number.isNaN(n) ? "NaN" : Number.isFinite(n) ? void 0 : "Infinity" : void 0;
    return i.issues.push({
      expected: "number",
      code: "invalid_type",
      input: n,
      inst: e,
      ...o ? { received: o } : {}
    }), i;
  };
}), lu = /* @__PURE__ */ s("$ZodNumberFormat", (e, t) => {
  ha.init(e, t), Bt.init(e, t);
}), Xt = /* @__PURE__ */ s("$ZodBoolean", (e, t) => {
  $.init(e, t), e._zod.pattern = la, e._zod.parse = (i, r) => {
    if (t.coerce)
      try {
        i.value = !!i.value;
      } catch {
      }
    const n = i.value;
    return typeof n == "boolean" || i.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input: n,
      inst: e
    }), i;
  };
}), qt = /* @__PURE__ */ s("$ZodBigInt", (e, t) => {
  $.init(e, t), e._zod.pattern = aa, e._zod.parse = (i, r) => {
    if (t.coerce)
      try {
        i.value = BigInt(i.value);
      } catch {
      }
    return typeof i.value == "bigint" || i.issues.push({
      expected: "bigint",
      code: "invalid_type",
      input: i.value,
      inst: e
    }), i;
  };
}), su = /* @__PURE__ */ s("$ZodBigIntFormat", (e, t) => {
  $a.init(e, t), qt.init(e, t);
}), du = /* @__PURE__ */ s("$ZodSymbol", (e, t) => {
  $.init(e, t), e._zod.parse = (i, r) => {
    const n = i.value;
    return typeof n == "symbol" || i.issues.push({
      expected: "symbol",
      code: "invalid_type",
      input: n,
      inst: e
    }), i;
  };
}), mu = /* @__PURE__ */ s("$ZodUndefined", (e, t) => {
  $.init(e, t), e._zod.pattern = da, e._zod.values = /* @__PURE__ */ new Set([void 0]), e._zod.optin = "optional", e._zod.optout = "optional", e._zod.parse = (i, r) => {
    const n = i.value;
    return typeof n > "u" || i.issues.push({
      expected: "undefined",
      code: "invalid_type",
      input: n,
      inst: e
    }), i;
  };
}), fu = /* @__PURE__ */ s("$ZodNull", (e, t) => {
  $.init(e, t), e._zod.pattern = sa, e._zod.values = /* @__PURE__ */ new Set([null]), e._zod.parse = (i, r) => {
    const n = i.value;
    return n === null || i.issues.push({
      expected: "null",
      code: "invalid_type",
      input: n,
      inst: e
    }), i;
  };
}), gu = /* @__PURE__ */ s("$ZodAny", (e, t) => {
  $.init(e, t), e._zod.parse = (i) => i;
}), pu = /* @__PURE__ */ s("$ZodUnknown", (e, t) => {
  $.init(e, t), e._zod.parse = (i) => i;
}), vu = /* @__PURE__ */ s("$ZodNever", (e, t) => {
  $.init(e, t), e._zod.parse = (i, r) => (i.issues.push({
    expected: "never",
    code: "invalid_type",
    input: i.value,
    inst: e
  }), i);
}), hu = /* @__PURE__ */ s("$ZodVoid", (e, t) => {
  $.init(e, t), e._zod.parse = (i, r) => {
    const n = i.value;
    return typeof n > "u" || i.issues.push({
      expected: "void",
      code: "invalid_type",
      input: n,
      inst: e
    }), i;
  };
}), $u = /* @__PURE__ */ s("$ZodDate", (e, t) => {
  $.init(e, t), e._zod.parse = (i, r) => {
    if (t.coerce)
      try {
        i.value = new Date(i.value);
      } catch {
      }
    const n = i.value, o = n instanceof Date;
    return o && !Number.isNaN(n.getTime()) || i.issues.push({
      expected: "date",
      code: "invalid_type",
      input: n,
      ...o ? { received: "Invalid Date" } : {},
      inst: e
    }), i;
  };
});
function Yi(e, t, i) {
  e.issues.length && t.issues.push(...C(i, e.issues)), t.value[i] = e.value;
}
const bu = /* @__PURE__ */ s("$ZodArray", (e, t) => {
  $.init(e, t), e._zod.parse = (i, r) => {
    const n = i.value;
    if (!Array.isArray(n))
      return i.issues.push({
        expected: "array",
        code: "invalid_type",
        input: n,
        inst: e
      }), i;
    i.value = Array(n.length);
    const o = [];
    for (let a = 0; a < n.length; a++) {
      const u = n[a], l = t.element._zod.run({
        value: u,
        issues: []
      }, r);
      l instanceof Promise ? o.push(l.then((c) => Yi(c, i, a))) : Yi(l, i, a);
    }
    return o.length ? Promise.all(o).then(() => i) : i;
  };
});
function fn(e, t, i, r) {
  e.issues.length && t.issues.push(...C(i, e.issues)), e.value === void 0 ? i in r && (t.value[i] = void 0) : t.value[i] = e.value;
}
function _u(e) {
  const t = Object.keys(e.shape);
  for (const r of t)
    if (!e.shape?.[r]?._zod?.traits?.has("$ZodType"))
      throw new Error(`Invalid element at key "${r}": expected a Zod schema`);
  const i = $o(e.shape);
  return {
    ...e,
    keys: t,
    keySet: new Set(t),
    numKeys: t.length,
    optionalKeys: new Set(i)
  };
}
function yu(e, t, i, r, n, o) {
  const a = [], u = n.keySet, l = n.catchall._zod, c = l.def.type;
  for (const d in t) {
    if (u.has(d))
      continue;
    if (c === "never") {
      a.push(d);
      continue;
    }
    const f = l.run({ value: t[d], issues: [] }, r);
    f instanceof Promise ? e.push(f.then((p) => fn(p, i, d, t))) : fn(f, i, d, t);
  }
  return a.length && i.issues.push({
    code: "unrecognized_keys",
    keys: a,
    input: t,
    inst: o
  }), e.length ? Promise.all(e).then(() => i) : i;
}
const ku = /* @__PURE__ */ s("$ZodObject", (e, t) => {
  if ($.init(e, t), !Object.getOwnPropertyDescriptor(t, "shape")?.get) {
    const u = t.shape;
    Object.defineProperty(t, "shape", {
      get: () => {
        const l = { ...u };
        return Object.defineProperty(t, "shape", {
          value: l
        }), l;
      }
    });
  }
  const r = De(() => _u(t));
  _(e._zod, "propValues", () => {
    const u = t.shape, l = {};
    for (const c in u) {
      const d = u[c]._zod;
      if (d.values) {
        l[c] ?? (l[c] = /* @__PURE__ */ new Set());
        for (const f of d.values)
          l[c].add(f);
      }
    }
    return l;
  });
  const n = me, o = t.catchall;
  let a;
  e._zod.parse = (u, l) => {
    a ?? (a = r.value);
    const c = u.value;
    if (!n(c))
      return u.issues.push({
        expected: "object",
        code: "invalid_type",
        input: c,
        inst: e
      }), u;
    u.value = {};
    const d = [], f = a.shape;
    for (const p of a.keys) {
      const y = f[p]._zod.run({ value: c[p], issues: [] }, l);
      y instanceof Promise ? d.push(y.then((T) => fn(T, u, p, c))) : fn(y, u, p, c);
    }
    return o ? yu(d, c, u, l, r.value, e) : d.length ? Promise.all(d).then(() => u) : u;
  };
}), Iu = /* @__PURE__ */ s("$ZodObjectJIT", (e, t) => {
  ku.init(e, t);
  const i = e._zod.parse, r = De(() => _u(t)), n = (p) => {
    const v = new Da(["shape", "payload", "ctx"]), y = r.value, T = (M) => {
      const J = yt(M);
      return `shape[${J}]._zod.run({ value: input[${J}], issues: [] }, ctx)`;
    };
    v.write("const input = payload.value;");
    const rn = /* @__PURE__ */ Object.create(null);
    let _s = 0;
    for (const M of y.keys)
      rn[M] = `key_${_s++}`;
    v.write("const newResult = {};");
    for (const M of y.keys) {
      const J = rn[M], ze = yt(M);
      v.write(`const ${J} = ${T(M)};`), v.write(`
        if (${J}.issues.length) {
          payload.issues = payload.issues.concat(${J}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${ze}, ...iss.path] : [${ze}]
          })));
        }
        
        
        if (${J}.value === undefined) {
          if (${ze} in input) {
            newResult[${ze}] = undefined;
          }
        } else {
          newResult[${ze}] = ${J}.value;
        }
        
      `);
    }
    v.write("payload.value = newResult;"), v.write("return payload;");
    const ys = v.compile();
    return (M, J) => ys(p, M, J);
  };
  let o;
  const a = me, u = !sn.jitless, c = u && vo.value, d = t.catchall;
  let f;
  e._zod.parse = (p, v) => {
    f ?? (f = r.value);
    const y = p.value;
    return a(y) ? u && c && v?.async === !1 && v.jitless !== !0 ? (o || (o = n(t.shape)), p = o(p, v), d ? yu([], y, p, v, f, e) : p) : i(p, v) : (p.issues.push({
      expected: "object",
      code: "invalid_type",
      input: y,
      inst: e
    }), p);
  };
});
function Hi(e, t, i, r) {
  for (const o of e)
    if (o.issues.length === 0)
      return t.value = o.value, t;
  const n = e.filter((o) => !re(o));
  return n.length === 1 ? (t.value = n[0].value, n[0]) : (t.issues.push({
    code: "invalid_union",
    input: t.value,
    inst: i,
    errors: e.map((o) => o.issues.map((a) => L(a, r, w())))
  }), t);
}
const wn = /* @__PURE__ */ s("$ZodUnion", (e, t) => {
  $.init(e, t), _(e._zod, "optin", () => t.options.some((n) => n._zod.optin === "optional") ? "optional" : void 0), _(e._zod, "optout", () => t.options.some((n) => n._zod.optout === "optional") ? "optional" : void 0), _(e._zod, "values", () => {
    if (t.options.every((n) => n._zod.values))
      return new Set(t.options.flatMap((n) => Array.from(n._zod.values)));
  }), _(e._zod, "pattern", () => {
    if (t.options.every((n) => n._zod.pattern)) {
      const n = t.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${n.map((o) => bn(o.source)).join("|")})$`);
    }
  });
  const i = t.options.length === 1, r = t.options[0]._zod.run;
  e._zod.parse = (n, o) => {
    if (i)
      return r(n, o);
    let a = !1;
    const u = [];
    for (const l of t.options) {
      const c = l._zod.run({
        value: n.value,
        issues: []
      }, o);
      if (c instanceof Promise)
        u.push(c), a = !0;
      else {
        if (c.issues.length === 0)
          return c;
        u.push(c);
      }
    }
    return a ? Promise.all(u).then((l) => Hi(l, n, e, o)) : Hi(u, n, e, o);
  };
});
function Qi(e, t, i, r) {
  const n = e.filter((o) => o.issues.length === 0);
  return n.length === 1 ? (t.value = n[0].value, t) : (n.length === 0 ? t.issues.push({
    code: "invalid_union",
    input: t.value,
    inst: i,
    errors: e.map((o) => o.issues.map((a) => L(a, r, w())))
  }) : t.issues.push({
    code: "invalid_union",
    input: t.value,
    inst: i,
    errors: [],
    inclusive: !1
  }), t);
}
const zu = /* @__PURE__ */ s("$ZodXor", (e, t) => {
  wn.init(e, t), t.inclusive = !1;
  const i = t.options.length === 1, r = t.options[0]._zod.run;
  e._zod.parse = (n, o) => {
    if (i)
      return r(n, o);
    let a = !1;
    const u = [];
    for (const l of t.options) {
      const c = l._zod.run({
        value: n.value,
        issues: []
      }, o);
      c instanceof Promise ? (u.push(c), a = !0) : u.push(c);
    }
    return a ? Promise.all(u).then((l) => Qi(l, n, e, o)) : Qi(u, n, e, o);
  };
}), Su = /* @__PURE__ */ s("$ZodDiscriminatedUnion", (e, t) => {
  t.inclusive = !1, wn.init(e, t);
  const i = e._zod.parse;
  _(e._zod, "propValues", () => {
    const n = {};
    for (const o of t.options) {
      const a = o._zod.propValues;
      if (!a || Object.keys(a).length === 0)
        throw new Error(`Invalid discriminated union option at index "${t.options.indexOf(o)}"`);
      for (const [u, l] of Object.entries(a)) {
        n[u] || (n[u] = /* @__PURE__ */ new Set());
        for (const c of l)
          n[u].add(c);
      }
    }
    return n;
  });
  const r = De(() => {
    const n = t.options, o = /* @__PURE__ */ new Map();
    for (const a of n) {
      const u = a._zod.propValues?.[t.discriminator];
      if (!u || u.size === 0)
        throw new Error(`Invalid discriminated union option at index "${t.options.indexOf(a)}"`);
      for (const l of u) {
        if (o.has(l))
          throw new Error(`Duplicate discriminator value "${String(l)}"`);
        o.set(l, a);
      }
    }
    return o;
  });
  e._zod.parse = (n, o) => {
    const a = n.value;
    if (!me(a))
      return n.issues.push({
        code: "invalid_type",
        expected: "object",
        input: a,
        inst: e
      }), n;
    const u = r.value.get(a?.[t.discriminator]);
    return u ? u._zod.run(n, o) : t.unionFallback ? i(n, o) : (n.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      discriminator: t.discriminator,
      input: a,
      path: [t.discriminator],
      inst: e
    }), n);
  };
}), wu = /* @__PURE__ */ s("$ZodIntersection", (e, t) => {
  $.init(e, t), e._zod.parse = (i, r) => {
    const n = i.value, o = t.left._zod.run({ value: n, issues: [] }, r), a = t.right._zod.run({ value: n, issues: [] }, r);
    return o instanceof Promise || a instanceof Promise ? Promise.all([o, a]).then(([l, c]) => eo(i, l, c)) : eo(i, o, a);
  };
});
function zt(e, t) {
  if (e === t)
    return { valid: !0, data: e };
  if (e instanceof Date && t instanceof Date && +e == +t)
    return { valid: !0, data: e };
  if (ae(e) && ae(t)) {
    const i = Object.keys(t), r = Object.keys(e).filter((o) => i.indexOf(o) !== -1), n = { ...e, ...t };
    for (const o of r) {
      const a = zt(e[o], t[o]);
      if (!a.valid)
        return {
          valid: !1,
          mergeErrorPath: [o, ...a.mergeErrorPath]
        };
      n[o] = a.data;
    }
    return { valid: !0, data: n };
  }
  if (Array.isArray(e) && Array.isArray(t)) {
    if (e.length !== t.length)
      return { valid: !1, mergeErrorPath: [] };
    const i = [];
    for (let r = 0; r < e.length; r++) {
      const n = e[r], o = t[r], a = zt(n, o);
      if (!a.valid)
        return {
          valid: !1,
          mergeErrorPath: [r, ...a.mergeErrorPath]
        };
      i.push(a.data);
    }
    return { valid: !0, data: i };
  }
  return { valid: !1, mergeErrorPath: [] };
}
function eo(e, t, i) {
  if (t.issues.length && e.issues.push(...t.issues), i.issues.length && e.issues.push(...i.issues), re(e))
    return e;
  const r = zt(t.value, i.value);
  if (!r.valid)
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(r.mergeErrorPath)}`);
  return e.value = r.data, e;
}
const Yt = /* @__PURE__ */ s("$ZodTuple", (e, t) => {
  $.init(e, t);
  const i = t.items;
  e._zod.parse = (r, n) => {
    const o = r.value;
    if (!Array.isArray(o))
      return r.issues.push({
        input: o,
        inst: e,
        expected: "tuple",
        code: "invalid_type"
      }), r;
    r.value = [];
    const a = [], u = [...i].reverse().findIndex((d) => d._zod.optin !== "optional"), l = u === -1 ? 0 : i.length - u;
    if (!t.rest) {
      const d = o.length > i.length, f = o.length < l - 1;
      if (d || f)
        return r.issues.push({
          ...d ? { code: "too_big", maximum: i.length } : { code: "too_small", minimum: i.length },
          input: o,
          inst: e,
          origin: "array"
        }), r;
    }
    let c = -1;
    for (const d of i) {
      if (c++, c >= o.length && c >= l)
        continue;
      const f = d._zod.run({
        value: o[c],
        issues: []
      }, n);
      f instanceof Promise ? a.push(f.then((p) => on(p, r, c))) : on(f, r, c);
    }
    if (t.rest) {
      const d = o.slice(i.length);
      for (const f of d) {
        c++;
        const p = t.rest._zod.run({
          value: f,
          issues: []
        }, n);
        p instanceof Promise ? a.push(p.then((v) => on(v, r, c))) : on(p, r, c);
      }
    }
    return a.length ? Promise.all(a).then(() => r) : r;
  };
});
function on(e, t, i) {
  e.issues.length && t.issues.push(...C(i, e.issues)), t.value[i] = e.value;
}
const ju = /* @__PURE__ */ s("$ZodRecord", (e, t) => {
  $.init(e, t), e._zod.parse = (i, r) => {
    const n = i.value;
    if (!ae(n))
      return i.issues.push({
        expected: "record",
        code: "invalid_type",
        input: n,
        inst: e
      }), i;
    const o = [], a = t.keyType._zod.values;
    if (a) {
      i.value = {};
      const u = /* @__PURE__ */ new Set();
      for (const c of a)
        if (typeof c == "string" || typeof c == "number" || typeof c == "symbol") {
          u.add(typeof c == "number" ? c.toString() : c);
          const d = t.valueType._zod.run({ value: n[c], issues: [] }, r);
          d instanceof Promise ? o.push(d.then((f) => {
            f.issues.length && i.issues.push(...C(c, f.issues)), i.value[c] = f.value;
          })) : (d.issues.length && i.issues.push(...C(c, d.issues)), i.value[c] = d.value);
        }
      let l;
      for (const c in n)
        u.has(c) || (l = l ?? [], l.push(c));
      l && l.length > 0 && i.issues.push({
        code: "unrecognized_keys",
        input: n,
        inst: e,
        keys: l
      });
    } else {
      i.value = {};
      for (const u of Reflect.ownKeys(n)) {
        if (u === "__proto__")
          continue;
        const l = t.keyType._zod.run({ value: u, issues: [] }, r);
        if (l instanceof Promise)
          throw new Error("Async schemas not supported in object keys currently");
        if (l.issues.length) {
          t.mode === "loose" ? i.value[u] = n[u] : i.issues.push({
            code: "invalid_key",
            origin: "record",
            issues: l.issues.map((d) => L(d, r, w())),
            input: u,
            path: [u],
            inst: e
          });
          continue;
        }
        const c = t.valueType._zod.run({ value: n[u], issues: [] }, r);
        c instanceof Promise ? o.push(c.then((d) => {
          d.issues.length && i.issues.push(...C(u, d.issues)), i.value[l.value] = d.value;
        })) : (c.issues.length && i.issues.push(...C(u, c.issues)), i.value[l.value] = c.value);
      }
    }
    return o.length ? Promise.all(o).then(() => i) : i;
  };
}), Ou = /* @__PURE__ */ s("$ZodMap", (e, t) => {
  $.init(e, t), e._zod.parse = (i, r) => {
    const n = i.value;
    if (!(n instanceof Map))
      return i.issues.push({
        expected: "map",
        code: "invalid_type",
        input: n,
        inst: e
      }), i;
    const o = [];
    i.value = /* @__PURE__ */ new Map();
    for (const [a, u] of n) {
      const l = t.keyType._zod.run({ value: a, issues: [] }, r), c = t.valueType._zod.run({ value: u, issues: [] }, r);
      l instanceof Promise || c instanceof Promise ? o.push(Promise.all([l, c]).then(([d, f]) => {
        no(d, f, i, a, n, e, r);
      })) : no(l, c, i, a, n, e, r);
    }
    return o.length ? Promise.all(o).then(() => i) : i;
  };
});
function no(e, t, i, r, n, o, a) {
  e.issues.length && (mn.has(typeof r) ? i.issues.push(...C(r, e.issues)) : i.issues.push({
    code: "invalid_key",
    origin: "map",
    input: n,
    inst: o,
    issues: e.issues.map((u) => L(u, a, w()))
  })), t.issues.length && (mn.has(typeof r) ? i.issues.push(...C(r, t.issues)) : i.issues.push({
    origin: "map",
    code: "invalid_element",
    input: n,
    inst: o,
    key: r,
    issues: t.issues.map((u) => L(u, a, w()))
  })), i.value.set(e.value, t.value);
}
const Nu = /* @__PURE__ */ s("$ZodSet", (e, t) => {
  $.init(e, t), e._zod.parse = (i, r) => {
    const n = i.value;
    if (!(n instanceof Set))
      return i.issues.push({
        input: n,
        inst: e,
        expected: "set",
        code: "invalid_type"
      }), i;
    const o = [];
    i.value = /* @__PURE__ */ new Set();
    for (const a of n) {
      const u = t.valueType._zod.run({ value: a, issues: [] }, r);
      u instanceof Promise ? o.push(u.then((l) => to(l, i))) : to(u, i);
    }
    return o.length ? Promise.all(o).then(() => i) : i;
  };
});
function to(e, t) {
  e.issues.length && t.issues.push(...e.issues), t.value.add(e.value);
}
const Uu = /* @__PURE__ */ s("$ZodEnum", (e, t) => {
  $.init(e, t);
  const i = Ut(t.entries), r = new Set(i);
  e._zod.values = r, e._zod.pattern = new RegExp(`^(${i.filter((n) => mn.has(typeof n)).map((n) => typeof n == "string" ? W(n) : n.toString()).join("|")})$`), e._zod.parse = (n, o) => {
    const a = n.value;
    return r.has(a) || n.issues.push({
      code: "invalid_value",
      values: i,
      input: a,
      inst: e
    }), n;
  };
}), xu = /* @__PURE__ */ s("$ZodLiteral", (e, t) => {
  if ($.init(e, t), t.values.length === 0)
    throw new Error("Cannot create literal schema with no valid values");
  const i = new Set(t.values);
  e._zod.values = i, e._zod.pattern = new RegExp(`^(${t.values.map((r) => typeof r == "string" ? W(r) : r ? W(r.toString()) : String(r)).join("|")})$`), e._zod.parse = (r, n) => {
    const o = r.value;
    return i.has(o) || r.issues.push({
      code: "invalid_value",
      values: t.values,
      input: o,
      inst: e
    }), r;
  };
}), Pu = /* @__PURE__ */ s("$ZodFile", (e, t) => {
  $.init(e, t), e._zod.parse = (i, r) => {
    const n = i.value;
    return n instanceof File || i.issues.push({
      expected: "file",
      code: "invalid_type",
      input: n,
      inst: e
    }), i;
  };
}), Zu = /* @__PURE__ */ s("$ZodTransform", (e, t) => {
  $.init(e, t), e._zod.parse = (i, r) => {
    if (r.direction === "backward")
      throw new $n(e.constructor.name);
    const n = t.transform(i.value, i);
    if (r.async)
      return (n instanceof Promise ? n : Promise.resolve(n)).then((a) => (i.value = a, i));
    if (n instanceof Promise)
      throw new ie();
    return i.value = n, i;
  };
});
function ro(e, t) {
  return e.issues.length && t === void 0 ? { issues: [], value: void 0 } : e;
}
const Du = /* @__PURE__ */ s("$ZodOptional", (e, t) => {
  $.init(e, t), e._zod.optin = "optional", e._zod.optout = "optional", _(e._zod, "values", () => t.innerType._zod.values ? /* @__PURE__ */ new Set([...t.innerType._zod.values, void 0]) : void 0), _(e._zod, "pattern", () => {
    const i = t.innerType._zod.pattern;
    return i ? new RegExp(`^(${bn(i.source)})?$`) : void 0;
  }), e._zod.parse = (i, r) => {
    if (t.innerType._zod.optin === "optional") {
      const n = t.innerType._zod.run(i, r);
      return n instanceof Promise ? n.then((o) => ro(o, i.value)) : ro(n, i.value);
    }
    return i.value === void 0 ? i : t.innerType._zod.run(i, r);
  };
}), Tu = /* @__PURE__ */ s("$ZodNullable", (e, t) => {
  $.init(e, t), _(e._zod, "optin", () => t.innerType._zod.optin), _(e._zod, "optout", () => t.innerType._zod.optout), _(e._zod, "pattern", () => {
    const i = t.innerType._zod.pattern;
    return i ? new RegExp(`^(${bn(i.source)}|null)$`) : void 0;
  }), _(e._zod, "values", () => t.innerType._zod.values ? /* @__PURE__ */ new Set([...t.innerType._zod.values, null]) : void 0), e._zod.parse = (i, r) => i.value === null ? i : t.innerType._zod.run(i, r);
}), Eu = /* @__PURE__ */ s("$ZodDefault", (e, t) => {
  $.init(e, t), e._zod.optin = "optional", _(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (i, r) => {
    if (r.direction === "backward")
      return t.innerType._zod.run(i, r);
    if (i.value === void 0)
      return i.value = t.defaultValue, i;
    const n = t.innerType._zod.run(i, r);
    return n instanceof Promise ? n.then((o) => io(o, t)) : io(n, t);
  };
});
function io(e, t) {
  return e.value === void 0 && (e.value = t.defaultValue), e;
}
const Au = /* @__PURE__ */ s("$ZodPrefault", (e, t) => {
  $.init(e, t), e._zod.optin = "optional", _(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (i, r) => (r.direction === "backward" || i.value === void 0 && (i.value = t.defaultValue), t.innerType._zod.run(i, r));
}), Lu = /* @__PURE__ */ s("$ZodNonOptional", (e, t) => {
  $.init(e, t), _(e._zod, "values", () => {
    const i = t.innerType._zod.values;
    return i ? new Set([...i].filter((r) => r !== void 0)) : void 0;
  }), e._zod.parse = (i, r) => {
    const n = t.innerType._zod.run(i, r);
    return n instanceof Promise ? n.then((o) => oo(o, e)) : oo(n, e);
  };
});
function oo(e, t) {
  return !e.issues.length && e.value === void 0 && e.issues.push({
    code: "invalid_type",
    expected: "nonoptional",
    input: e.value,
    inst: t
  }), e;
}
const Ru = /* @__PURE__ */ s("$ZodSuccess", (e, t) => {
  $.init(e, t), e._zod.parse = (i, r) => {
    if (r.direction === "backward")
      throw new $n("ZodSuccess");
    const n = t.innerType._zod.run(i, r);
    return n instanceof Promise ? n.then((o) => (i.value = o.issues.length === 0, i)) : (i.value = n.issues.length === 0, i);
  };
}), Cu = /* @__PURE__ */ s("$ZodCatch", (e, t) => {
  $.init(e, t), _(e._zod, "optin", () => t.innerType._zod.optin), _(e._zod, "optout", () => t.innerType._zod.optout), _(e._zod, "values", () => t.innerType._zod.values), e._zod.parse = (i, r) => {
    if (r.direction === "backward")
      return t.innerType._zod.run(i, r);
    const n = t.innerType._zod.run(i, r);
    return n instanceof Promise ? n.then((o) => (i.value = o.value, o.issues.length && (i.value = t.catchValue({
      ...i,
      error: {
        issues: o.issues.map((a) => L(a, r, w()))
      },
      input: i.value
    }), i.issues = []), i)) : (i.value = n.value, n.issues.length && (i.value = t.catchValue({
      ...i,
      error: {
        issues: n.issues.map((o) => L(o, r, w()))
      },
      input: i.value
    }), i.issues = []), i);
  };
}), Ju = /* @__PURE__ */ s("$ZodNaN", (e, t) => {
  $.init(e, t), e._zod.parse = (i, r) => ((typeof i.value != "number" || !Number.isNaN(i.value)) && i.issues.push({
    input: i.value,
    inst: e,
    expected: "nan",
    code: "invalid_type"
  }), i);
}), Fu = /* @__PURE__ */ s("$ZodPipe", (e, t) => {
  $.init(e, t), _(e._zod, "values", () => t.in._zod.values), _(e._zod, "optin", () => t.in._zod.optin), _(e._zod, "optout", () => t.out._zod.optout), _(e._zod, "propValues", () => t.in._zod.propValues), e._zod.parse = (i, r) => {
    if (r.direction === "backward") {
      const o = t.out._zod.run(i, r);
      return o instanceof Promise ? o.then((a) => an(a, t.in, r)) : an(o, t.in, r);
    }
    const n = t.in._zod.run(i, r);
    return n instanceof Promise ? n.then((o) => an(o, t.out, r)) : an(n, t.out, r);
  };
});
function an(e, t, i) {
  return e.issues.length ? (e.aborted = !0, e) : t._zod.run({ value: e.value, issues: e.issues }, i);
}
const Ht = /* @__PURE__ */ s("$ZodCodec", (e, t) => {
  $.init(e, t), _(e._zod, "values", () => t.in._zod.values), _(e._zod, "optin", () => t.in._zod.optin), _(e._zod, "optout", () => t.out._zod.optout), _(e._zod, "propValues", () => t.in._zod.propValues), e._zod.parse = (i, r) => {
    if ((r.direction || "forward") === "forward") {
      const o = t.in._zod.run(i, r);
      return o instanceof Promise ? o.then((a) => un(a, t, r)) : un(o, t, r);
    } else {
      const o = t.out._zod.run(i, r);
      return o instanceof Promise ? o.then((a) => un(a, t, r)) : un(o, t, r);
    }
  };
});
function un(e, t, i) {
  if (e.issues.length)
    return e.aborted = !0, e;
  if ((i.direction || "forward") === "forward") {
    const n = t.transform(e.value, e);
    return n instanceof Promise ? n.then((o) => cn(e, o, t.out, i)) : cn(e, n, t.out, i);
  } else {
    const n = t.reverseTransform(e.value, e);
    return n instanceof Promise ? n.then((o) => cn(e, o, t.in, i)) : cn(e, n, t.in, i);
  }
}
function cn(e, t, i, r) {
  return e.issues.length ? (e.aborted = !0, e) : i._zod.run({ value: t, issues: e.issues }, r);
}
const Mu = /* @__PURE__ */ s("$ZodReadonly", (e, t) => {
  $.init(e, t), _(e._zod, "propValues", () => t.innerType._zod.propValues), _(e._zod, "values", () => t.innerType._zod.values), _(e._zod, "optin", () => t.innerType?._zod?.optin), _(e._zod, "optout", () => t.innerType?._zod?.optout), e._zod.parse = (i, r) => {
    if (r.direction === "backward")
      return t.innerType._zod.run(i, r);
    const n = t.innerType._zod.run(i, r);
    return n instanceof Promise ? n.then(ao) : ao(n);
  };
});
function ao(e) {
  return e.value = Object.freeze(e.value), e;
}
const Gu = /* @__PURE__ */ s("$ZodTemplateLiteral", (e, t) => {
  $.init(e, t);
  const i = [];
  for (const r of t.parts)
    if (typeof r == "object" && r !== null) {
      if (!r._zod.pattern)
        throw new Error(`Invalid template literal part, no pattern found: ${[...r._zod.traits].shift()}`);
      const n = r._zod.pattern instanceof RegExp ? r._zod.pattern.source : r._zod.pattern;
      if (!n)
        throw new Error(`Invalid template literal part: ${r._zod.traits}`);
      const o = n.startsWith("^") ? 1 : 0, a = n.endsWith("$") ? n.length - 1 : n.length;
      i.push(n.slice(o, a));
    } else if (r === null || ho.has(typeof r))
      i.push(W(`${r}`));
    else
      throw new Error(`Invalid template literal part: ${r}`);
  e._zod.pattern = new RegExp(`^${i.join("")}$`), e._zod.parse = (r, n) => typeof r.value != "string" ? (r.issues.push({
    input: r.value,
    inst: e,
    expected: "template_literal",
    code: "invalid_type"
  }), r) : (e._zod.pattern.lastIndex = 0, e._zod.pattern.test(r.value) || r.issues.push({
    input: r.value,
    inst: e,
    code: "invalid_format",
    format: t.format ?? "template_literal",
    pattern: e._zod.pattern.source
  }), r);
}), Vu = /* @__PURE__ */ s("$ZodFunction", (e, t) => ($.init(e, t), e._def = t, e._zod.def = t, e.implement = (i) => {
  if (typeof i != "function")
    throw new Error("implement() must be called with a function");
  return function(...r) {
    const n = e._def.input ? kt(e._def.input, r) : r, o = Reflect.apply(i, this, n);
    return e._def.output ? kt(e._def.output, o) : o;
  };
}, e.implementAsync = (i) => {
  if (typeof i != "function")
    throw new Error("implementAsync() must be called with a function");
  return async function(...r) {
    const n = e._def.input ? await It(e._def.input, r) : r, o = await Reflect.apply(i, this, n);
    return e._def.output ? await It(e._def.output, o) : o;
  };
}, e._zod.parse = (i, r) => typeof i.value != "function" ? (i.issues.push({
  code: "invalid_type",
  expected: "function",
  input: i.value,
  inst: e
}), i) : (e._def.output && e._def.output._zod.def.type === "promise" ? i.value = e.implementAsync(i.value) : i.value = e.implement(i.value), i), e.input = (...i) => {
  const r = e.constructor;
  return Array.isArray(i[0]) ? new r({
    type: "function",
    input: new Yt({
      type: "tuple",
      items: i[0],
      rest: i[1]
    }),
    output: e._def.output
  }) : new r({
    type: "function",
    input: i[0],
    output: e._def.output
  });
}, e.output = (i) => {
  const r = e.constructor;
  return new r({
    type: "function",
    input: e._def.input,
    output: i
  });
}, e)), Ku = /* @__PURE__ */ s("$ZodPromise", (e, t) => {
  $.init(e, t), e._zod.parse = (i, r) => Promise.resolve(i.value).then((n) => t.innerType._zod.run({ value: n, issues: [] }, r));
}), Wu = /* @__PURE__ */ s("$ZodLazy", (e, t) => {
  $.init(e, t), _(e._zod, "innerType", () => t.getter()), _(e._zod, "pattern", () => e._zod.innerType?._zod?.pattern), _(e._zod, "propValues", () => e._zod.innerType?._zod?.propValues), _(e._zod, "optin", () => e._zod.innerType?._zod?.optin ?? void 0), _(e._zod, "optout", () => e._zod.innerType?._zod?.optout ?? void 0), e._zod.parse = (i, r) => e._zod.innerType._zod.run(i, r);
}), Bu = /* @__PURE__ */ s("$ZodCustom", (e, t) => {
  S.init(e, t), $.init(e, t), e._zod.parse = (i, r) => i, e._zod.check = (i) => {
    const r = i.value, n = t.fn(r);
    if (n instanceof Promise)
      return n.then((o) => uo(o, i, r, e));
    uo(n, i, r, e);
  };
});
function uo(e, t, i, r) {
  if (!e) {
    const n = {
      code: "custom",
      input: i,
      inst: r,
      // incorporates params.error into issue reporting
      path: [...r._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !r._zod.def.abort
      // params: inst._zod.def.params,
    };
    r._zod.def.params && (n.params = r._zod.def.params), t.issues.push(fe(n));
  }
}
const bd = () => {
  const e = {
    string: { unit: "حرف", verb: "أن يحوي" },
    file: { unit: "بايت", verb: "أن يحوي" },
    array: { unit: "عنصر", verb: "أن يحوي" },
    set: { unit: "عنصر", verb: "أن يحوي" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const i = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(n))
          return "array";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, r = {
    regex: "مدخل",
    email: "بريد إلكتروني",
    url: "رابط",
    emoji: "إيموجي",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "تاريخ ووقت بمعيار ISO",
    date: "تاريخ بمعيار ISO",
    time: "وقت بمعيار ISO",
    duration: "مدة بمعيار ISO",
    ipv4: "عنوان IPv4",
    ipv6: "عنوان IPv6",
    cidrv4: "مدى عناوين بصيغة IPv4",
    cidrv6: "مدى عناوين بصيغة IPv6",
    base64: "نَص بترميز base64-encoded",
    base64url: "نَص بترميز base64url-encoded",
    json_string: "نَص على هيئة JSON",
    e164: "رقم هاتف بمعيار E.164",
    jwt: "JWT",
    template_literal: "مدخل"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `مدخلات غير مقبولة: يفترض إدخال ${n.expected}، ولكن تم إدخال ${i(n.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `مدخلات غير مقبولة: يفترض إدخال ${h(n.values[0])}` : `اختيار غير مقبول: يتوقع انتقاء أحد هذه الخيارات: ${g(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? ` أكبر من اللازم: يفترض أن تكون ${n.origin ?? "القيمة"} ${o} ${n.maximum.toString()} ${a.unit ?? "عنصر"}` : `أكبر من اللازم: يفترض أن تكون ${n.origin ?? "القيمة"} ${o} ${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `أصغر من اللازم: يفترض لـ ${n.origin} أن يكون ${o} ${n.minimum.toString()} ${a.unit}` : `أصغر من اللازم: يفترض لـ ${n.origin} أن يكون ${o} ${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `نَص غير مقبول: يجب أن يبدأ بـ "${n.prefix}"` : o.format === "ends_with" ? `نَص غير مقبول: يجب أن ينتهي بـ "${o.suffix}"` : o.format === "includes" ? `نَص غير مقبول: يجب أن يتضمَّن "${o.includes}"` : o.format === "regex" ? `نَص غير مقبول: يجب أن يطابق النمط ${o.pattern}` : `${r[o.format] ?? n.format} غير مقبول`;
      }
      case "not_multiple_of":
        return `رقم غير مقبول: يجب أن يكون من مضاعفات ${n.divisor}`;
      case "unrecognized_keys":
        return `معرف${n.keys.length > 1 ? "ات" : ""} غريب${n.keys.length > 1 ? "ة" : ""}: ${g(n.keys, "، ")}`;
      case "invalid_key":
        return `معرف غير مقبول في ${n.origin}`;
      case "invalid_union":
        return "مدخل غير مقبول";
      case "invalid_element":
        return `مدخل غير مقبول في ${n.origin}`;
      default:
        return "مدخل غير مقبول";
    }
  };
};
function _d() {
  return {
    localeError: bd()
  };
}
const yd = () => {
  const e = {
    string: { unit: "simvol", verb: "olmalıdır" },
    file: { unit: "bayt", verb: "olmalıdır" },
    array: { unit: "element", verb: "olmalıdır" },
    set: { unit: "element", verb: "olmalıdır" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const i = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(n))
          return "array";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, r = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Yanlış dəyər: gözlənilən ${n.expected}, daxil olan ${i(n.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `Yanlış dəyər: gözlənilən ${h(n.values[0])}` : `Yanlış seçim: aşağıdakılardan biri olmalıdır: ${g(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `Çox böyük: gözlənilən ${n.origin ?? "dəyər"} ${o}${n.maximum.toString()} ${a.unit ?? "element"}` : `Çox böyük: gözlənilən ${n.origin ?? "dəyər"} ${o}${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `Çox kiçik: gözlənilən ${n.origin} ${o}${n.minimum.toString()} ${a.unit}` : `Çox kiçik: gözlənilən ${n.origin} ${o}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `Yanlış mətn: "${o.prefix}" ilə başlamalıdır` : o.format === "ends_with" ? `Yanlış mətn: "${o.suffix}" ilə bitməlidir` : o.format === "includes" ? `Yanlış mətn: "${o.includes}" daxil olmalıdır` : o.format === "regex" ? `Yanlış mətn: ${o.pattern} şablonuna uyğun olmalıdır` : `Yanlış ${r[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Yanlış ədəd: ${n.divisor} ilə bölünə bilən olmalıdır`;
      case "unrecognized_keys":
        return `Tanınmayan açar${n.keys.length > 1 ? "lar" : ""}: ${g(n.keys, ", ")}`;
      case "invalid_key":
        return `${n.origin} daxilində yanlış açar`;
      case "invalid_union":
        return "Yanlış dəyər";
      case "invalid_element":
        return `${n.origin} daxilində yanlış dəyər`;
      default:
        return "Yanlış dəyər";
    }
  };
};
function kd() {
  return {
    localeError: yd()
  };
}
function co(e, t, i, r) {
  const n = Math.abs(e), o = n % 10, a = n % 100;
  return a >= 11 && a <= 19 ? r : o === 1 ? t : o >= 2 && o <= 4 ? i : r;
}
const Id = () => {
  const e = {
    string: {
      unit: {
        one: "сімвал",
        few: "сімвалы",
        many: "сімвалаў"
      },
      verb: "мець"
    },
    array: {
      unit: {
        one: "элемент",
        few: "элементы",
        many: "элементаў"
      },
      verb: "мець"
    },
    set: {
      unit: {
        one: "элемент",
        few: "элементы",
        many: "элементаў"
      },
      verb: "мець"
    },
    file: {
      unit: {
        one: "байт",
        few: "байты",
        many: "байтаў"
      },
      verb: "мець"
    }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const i = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "лік";
      case "object": {
        if (Array.isArray(n))
          return "масіў";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, r = {
    regex: "увод",
    email: "email адрас",
    url: "URL",
    emoji: "эмодзі",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO дата і час",
    date: "ISO дата",
    time: "ISO час",
    duration: "ISO працягласць",
    ipv4: "IPv4 адрас",
    ipv6: "IPv6 адрас",
    cidrv4: "IPv4 дыяпазон",
    cidrv6: "IPv6 дыяпазон",
    base64: "радок у фармаце base64",
    base64url: "радок у фармаце base64url",
    json_string: "JSON радок",
    e164: "нумар E.164",
    jwt: "JWT",
    template_literal: "увод"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Няправільны ўвод: чакаўся ${n.expected}, атрымана ${i(n.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `Няправільны ўвод: чакалася ${h(n.values[0])}` : `Няправільны варыянт: чакаўся адзін з ${g(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", a = t(n.origin);
        if (a) {
          const u = Number(n.maximum), l = co(u, a.unit.one, a.unit.few, a.unit.many);
          return `Занадта вялікі: чакалася, што ${n.origin ?? "значэнне"} павінна ${a.verb} ${o}${n.maximum.toString()} ${l}`;
        }
        return `Занадта вялікі: чакалася, што ${n.origin ?? "значэнне"} павінна быць ${o}${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", a = t(n.origin);
        if (a) {
          const u = Number(n.minimum), l = co(u, a.unit.one, a.unit.few, a.unit.many);
          return `Занадта малы: чакалася, што ${n.origin} павінна ${a.verb} ${o}${n.minimum.toString()} ${l}`;
        }
        return `Занадта малы: чакалася, што ${n.origin} павінна быць ${o}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `Няправільны радок: павінен пачынацца з "${o.prefix}"` : o.format === "ends_with" ? `Няправільны радок: павінен заканчвацца на "${o.suffix}"` : o.format === "includes" ? `Няправільны радок: павінен змяшчаць "${o.includes}"` : o.format === "regex" ? `Няправільны радок: павінен адпавядаць шаблону ${o.pattern}` : `Няправільны ${r[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Няправільны лік: павінен быць кратным ${n.divisor}`;
      case "unrecognized_keys":
        return `Нераспазнаны ${n.keys.length > 1 ? "ключы" : "ключ"}: ${g(n.keys, ", ")}`;
      case "invalid_key":
        return `Няправільны ключ у ${n.origin}`;
      case "invalid_union":
        return "Няправільны ўвод";
      case "invalid_element":
        return `Няправільнае значэнне ў ${n.origin}`;
      default:
        return "Няправільны ўвод";
    }
  };
};
function zd() {
  return {
    localeError: Id()
  };
}
const Sd = (e) => {
  const t = typeof e;
  switch (t) {
    case "number":
      return Number.isNaN(e) ? "NaN" : "число";
    case "object": {
      if (Array.isArray(e))
        return "масив";
      if (e === null)
        return "null";
      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
        return e.constructor.name;
    }
  }
  return t;
}, wd = () => {
  const e = {
    string: { unit: "символа", verb: "да съдържа" },
    file: { unit: "байта", verb: "да съдържа" },
    array: { unit: "елемента", verb: "да съдържа" },
    set: { unit: "елемента", verb: "да съдържа" }
  };
  function t(r) {
    return e[r] ?? null;
  }
  const i = {
    regex: "вход",
    email: "имейл адрес",
    url: "URL",
    emoji: "емоджи",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO време",
    date: "ISO дата",
    time: "ISO време",
    duration: "ISO продължителност",
    ipv4: "IPv4 адрес",
    ipv6: "IPv6 адрес",
    cidrv4: "IPv4 диапазон",
    cidrv6: "IPv6 диапазон",
    base64: "base64-кодиран низ",
    base64url: "base64url-кодиран низ",
    json_string: "JSON низ",
    e164: "E.164 номер",
    jwt: "JWT",
    template_literal: "вход"
  };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return `Невалиден вход: очакван ${r.expected}, получен ${Sd(r.input)}`;
      case "invalid_value":
        return r.values.length === 1 ? `Невалиден вход: очакван ${h(r.values[0])}` : `Невалидна опция: очаквано едно от ${g(r.values, "|")}`;
      case "too_big": {
        const n = r.inclusive ? "<=" : "<", o = t(r.origin);
        return o ? `Твърде голямо: очаква се ${r.origin ?? "стойност"} да съдържа ${n}${r.maximum.toString()} ${o.unit ?? "елемента"}` : `Твърде голямо: очаква се ${r.origin ?? "стойност"} да бъде ${n}${r.maximum.toString()}`;
      }
      case "too_small": {
        const n = r.inclusive ? ">=" : ">", o = t(r.origin);
        return o ? `Твърде малко: очаква се ${r.origin} да съдържа ${n}${r.minimum.toString()} ${o.unit}` : `Твърде малко: очаква се ${r.origin} да бъде ${n}${r.minimum.toString()}`;
      }
      case "invalid_format": {
        const n = r;
        if (n.format === "starts_with")
          return `Невалиден низ: трябва да започва с "${n.prefix}"`;
        if (n.format === "ends_with")
          return `Невалиден низ: трябва да завършва с "${n.suffix}"`;
        if (n.format === "includes")
          return `Невалиден низ: трябва да включва "${n.includes}"`;
        if (n.format === "regex")
          return `Невалиден низ: трябва да съвпада с ${n.pattern}`;
        let o = "Невалиден";
        return n.format === "emoji" && (o = "Невалидно"), n.format === "datetime" && (o = "Невалидно"), n.format === "date" && (o = "Невалидна"), n.format === "time" && (o = "Невалидно"), n.format === "duration" && (o = "Невалидна"), `${o} ${i[n.format] ?? r.format}`;
      }
      case "not_multiple_of":
        return `Невалидно число: трябва да бъде кратно на ${r.divisor}`;
      case "unrecognized_keys":
        return `Неразпознат${r.keys.length > 1 ? "и" : ""} ключ${r.keys.length > 1 ? "ове" : ""}: ${g(r.keys, ", ")}`;
      case "invalid_key":
        return `Невалиден ключ в ${r.origin}`;
      case "invalid_union":
        return "Невалиден вход";
      case "invalid_element":
        return `Невалидна стойност в ${r.origin}`;
      default:
        return "Невалиден вход";
    }
  };
};
function jd() {
  return {
    localeError: wd()
  };
}
const Od = () => {
  const e = {
    string: { unit: "caràcters", verb: "contenir" },
    file: { unit: "bytes", verb: "contenir" },
    array: { unit: "elements", verb: "contenir" },
    set: { unit: "elements", verb: "contenir" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const i = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(n))
          return "array";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, r = {
    regex: "entrada",
    email: "adreça electrònica",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durada ISO",
    ipv4: "adreça IPv4",
    ipv6: "adreça IPv6",
    cidrv4: "rang IPv4",
    cidrv6: "rang IPv6",
    base64: "cadena codificada en base64",
    base64url: "cadena codificada en base64url",
    json_string: "cadena JSON",
    e164: "número E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Tipus invàlid: s'esperava ${n.expected}, s'ha rebut ${i(n.input)}`;
      // return `Tipus invàlid: s'esperava ${issue.expected}, s'ha rebut ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `Valor invàlid: s'esperava ${h(n.values[0])}` : `Opció invàlida: s'esperava una de ${g(n.values, " o ")}`;
      case "too_big": {
        const o = n.inclusive ? "com a màxim" : "menys de", a = t(n.origin);
        return a ? `Massa gran: s'esperava que ${n.origin ?? "el valor"} contingués ${o} ${n.maximum.toString()} ${a.unit ?? "elements"}` : `Massa gran: s'esperava que ${n.origin ?? "el valor"} fos ${o} ${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? "com a mínim" : "més de", a = t(n.origin);
        return a ? `Massa petit: s'esperava que ${n.origin} contingués ${o} ${n.minimum.toString()} ${a.unit}` : `Massa petit: s'esperava que ${n.origin} fos ${o} ${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `Format invàlid: ha de començar amb "${o.prefix}"` : o.format === "ends_with" ? `Format invàlid: ha d'acabar amb "${o.suffix}"` : o.format === "includes" ? `Format invàlid: ha d'incloure "${o.includes}"` : o.format === "regex" ? `Format invàlid: ha de coincidir amb el patró ${o.pattern}` : `Format invàlid per a ${r[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Número invàlid: ha de ser múltiple de ${n.divisor}`;
      case "unrecognized_keys":
        return `Clau${n.keys.length > 1 ? "s" : ""} no reconeguda${n.keys.length > 1 ? "s" : ""}: ${g(n.keys, ", ")}`;
      case "invalid_key":
        return `Clau invàlida a ${n.origin}`;
      case "invalid_union":
        return "Entrada invàlida";
      // Could also be "Tipus d'unió invàlid" but "Entrada invàlida" is more general
      case "invalid_element":
        return `Element invàlid a ${n.origin}`;
      default:
        return "Entrada invàlida";
    }
  };
};
function Nd() {
  return {
    localeError: Od()
  };
}
const Ud = () => {
  const e = {
    string: { unit: "znaků", verb: "mít" },
    file: { unit: "bajtů", verb: "mít" },
    array: { unit: "prvků", verb: "mít" },
    set: { unit: "prvků", verb: "mít" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const i = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "číslo";
      case "string":
        return "řetězec";
      case "boolean":
        return "boolean";
      case "bigint":
        return "bigint";
      case "function":
        return "funkce";
      case "symbol":
        return "symbol";
      case "undefined":
        return "undefined";
      case "object": {
        if (Array.isArray(n))
          return "pole";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, r = {
    regex: "regulární výraz",
    email: "e-mailová adresa",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "datum a čas ve formátu ISO",
    date: "datum ve formátu ISO",
    time: "čas ve formátu ISO",
    duration: "doba trvání ISO",
    ipv4: "IPv4 adresa",
    ipv6: "IPv6 adresa",
    cidrv4: "rozsah IPv4",
    cidrv6: "rozsah IPv6",
    base64: "řetězec zakódovaný ve formátu base64",
    base64url: "řetězec zakódovaný ve formátu base64url",
    json_string: "řetězec ve formátu JSON",
    e164: "číslo E.164",
    jwt: "JWT",
    template_literal: "vstup"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Neplatný vstup: očekáváno ${n.expected}, obdrženo ${i(n.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `Neplatný vstup: očekáváno ${h(n.values[0])}` : `Neplatná možnost: očekávána jedna z hodnot ${g(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `Hodnota je příliš velká: ${n.origin ?? "hodnota"} musí mít ${o}${n.maximum.toString()} ${a.unit ?? "prvků"}` : `Hodnota je příliš velká: ${n.origin ?? "hodnota"} musí být ${o}${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `Hodnota je příliš malá: ${n.origin ?? "hodnota"} musí mít ${o}${n.minimum.toString()} ${a.unit ?? "prvků"}` : `Hodnota je příliš malá: ${n.origin ?? "hodnota"} musí být ${o}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `Neplatný řetězec: musí začínat na "${o.prefix}"` : o.format === "ends_with" ? `Neplatný řetězec: musí končit na "${o.suffix}"` : o.format === "includes" ? `Neplatný řetězec: musí obsahovat "${o.includes}"` : o.format === "regex" ? `Neplatný řetězec: musí odpovídat vzoru ${o.pattern}` : `Neplatný formát ${r[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Neplatné číslo: musí být násobkem ${n.divisor}`;
      case "unrecognized_keys":
        return `Neznámé klíče: ${g(n.keys, ", ")}`;
      case "invalid_key":
        return `Neplatný klíč v ${n.origin}`;
      case "invalid_union":
        return "Neplatný vstup";
      case "invalid_element":
        return `Neplatná hodnota v ${n.origin}`;
      default:
        return "Neplatný vstup";
    }
  };
};
function xd() {
  return {
    localeError: Ud()
  };
}
const Pd = () => {
  const e = {
    string: { unit: "tegn", verb: "havde" },
    file: { unit: "bytes", verb: "havde" },
    array: { unit: "elementer", verb: "indeholdt" },
    set: { unit: "elementer", verb: "indeholdt" }
  }, t = {
    string: "streng",
    number: "tal",
    boolean: "boolean",
    array: "liste",
    object: "objekt",
    set: "sæt",
    file: "fil"
  };
  function i(a) {
    return e[a] ?? null;
  }
  function r(a) {
    return t[a] ?? a;
  }
  const n = (a) => {
    const u = typeof a;
    switch (u) {
      case "number":
        return Number.isNaN(a) ? "NaN" : "tal";
      case "object":
        return Array.isArray(a) ? "liste" : a === null ? "null" : Object.getPrototypeOf(a) !== Object.prototype && a.constructor ? a.constructor.name : "objekt";
    }
    return u;
  }, o = {
    regex: "input",
    email: "e-mailadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslæt",
    date: "ISO-dato",
    time: "ISO-klokkeslæt",
    duration: "ISO-varighed",
    ipv4: "IPv4-område",
    ipv6: "IPv6-område",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodet streng",
    base64url: "base64url-kodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  return (a) => {
    switch (a.code) {
      case "invalid_type":
        return `Ugyldigt input: forventede ${r(a.expected)}, fik ${r(n(a.input))}`;
      case "invalid_value":
        return a.values.length === 1 ? `Ugyldig værdi: forventede ${h(a.values[0])}` : `Ugyldigt valg: forventede en af følgende ${g(a.values, "|")}`;
      case "too_big": {
        const u = a.inclusive ? "<=" : "<", l = i(a.origin), c = r(a.origin);
        return l ? `For stor: forventede ${c ?? "value"} ${l.verb} ${u} ${a.maximum.toString()} ${l.unit ?? "elementer"}` : `For stor: forventede ${c ?? "value"} havde ${u} ${a.maximum.toString()}`;
      }
      case "too_small": {
        const u = a.inclusive ? ">=" : ">", l = i(a.origin), c = r(a.origin);
        return l ? `For lille: forventede ${c} ${l.verb} ${u} ${a.minimum.toString()} ${l.unit}` : `For lille: forventede ${c} havde ${u} ${a.minimum.toString()}`;
      }
      case "invalid_format": {
        const u = a;
        return u.format === "starts_with" ? `Ugyldig streng: skal starte med "${u.prefix}"` : u.format === "ends_with" ? `Ugyldig streng: skal ende med "${u.suffix}"` : u.format === "includes" ? `Ugyldig streng: skal indeholde "${u.includes}"` : u.format === "regex" ? `Ugyldig streng: skal matche mønsteret ${u.pattern}` : `Ugyldig ${o[u.format] ?? a.format}`;
      }
      case "not_multiple_of":
        return `Ugyldigt tal: skal være deleligt med ${a.divisor}`;
      case "unrecognized_keys":
        return `${a.keys.length > 1 ? "Ukendte nøgler" : "Ukendt nøgle"}: ${g(a.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig nøgle i ${a.origin}`;
      case "invalid_union":
        return "Ugyldigt input: matcher ingen af de tilladte typer";
      case "invalid_element":
        return `Ugyldig værdi i ${a.origin}`;
      default:
        return "Ugyldigt input";
    }
  };
};
function Zd() {
  return {
    localeError: Pd()
  };
}
const Dd = () => {
  const e = {
    string: { unit: "Zeichen", verb: "zu haben" },
    file: { unit: "Bytes", verb: "zu haben" },
    array: { unit: "Elemente", verb: "zu haben" },
    set: { unit: "Elemente", verb: "zu haben" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const i = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "Zahl";
      case "object": {
        if (Array.isArray(n))
          return "Array";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, r = {
    regex: "Eingabe",
    email: "E-Mail-Adresse",
    url: "URL",
    emoji: "Emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-Datum und -Uhrzeit",
    date: "ISO-Datum",
    time: "ISO-Uhrzeit",
    duration: "ISO-Dauer",
    ipv4: "IPv4-Adresse",
    ipv6: "IPv6-Adresse",
    cidrv4: "IPv4-Bereich",
    cidrv6: "IPv6-Bereich",
    base64: "Base64-codierter String",
    base64url: "Base64-URL-codierter String",
    json_string: "JSON-String",
    e164: "E.164-Nummer",
    jwt: "JWT",
    template_literal: "Eingabe"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Ungültige Eingabe: erwartet ${n.expected}, erhalten ${i(n.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `Ungültige Eingabe: erwartet ${h(n.values[0])}` : `Ungültige Option: erwartet eine von ${g(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `Zu groß: erwartet, dass ${n.origin ?? "Wert"} ${o}${n.maximum.toString()} ${a.unit ?? "Elemente"} hat` : `Zu groß: erwartet, dass ${n.origin ?? "Wert"} ${o}${n.maximum.toString()} ist`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `Zu klein: erwartet, dass ${n.origin} ${o}${n.minimum.toString()} ${a.unit} hat` : `Zu klein: erwartet, dass ${n.origin} ${o}${n.minimum.toString()} ist`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `Ungültiger String: muss mit "${o.prefix}" beginnen` : o.format === "ends_with" ? `Ungültiger String: muss mit "${o.suffix}" enden` : o.format === "includes" ? `Ungültiger String: muss "${o.includes}" enthalten` : o.format === "regex" ? `Ungültiger String: muss dem Muster ${o.pattern} entsprechen` : `Ungültig: ${r[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Ungültige Zahl: muss ein Vielfaches von ${n.divisor} sein`;
      case "unrecognized_keys":
        return `${n.keys.length > 1 ? "Unbekannte Schlüssel" : "Unbekannter Schlüssel"}: ${g(n.keys, ", ")}`;
      case "invalid_key":
        return `Ungültiger Schlüssel in ${n.origin}`;
      case "invalid_union":
        return "Ungültige Eingabe";
      case "invalid_element":
        return `Ungültiger Wert in ${n.origin}`;
      default:
        return "Ungültige Eingabe";
    }
  };
};
function Td() {
  return {
    localeError: Dd()
  };
}
const Ed = (e) => {
  const t = typeof e;
  switch (t) {
    case "number":
      return Number.isNaN(e) ? "NaN" : "number";
    case "object": {
      if (Array.isArray(e))
        return "array";
      if (e === null)
        return "null";
      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
        return e.constructor.name;
    }
  }
  return t;
}, Ad = () => {
  const e = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" }
  };
  function t(r) {
    return e[r] ?? null;
  }
  const i = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    mac: "MAC address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return `Invalid input: expected ${r.expected}, received ${Ed(r.input)}`;
      case "invalid_value":
        return r.values.length === 1 ? `Invalid input: expected ${h(r.values[0])}` : `Invalid option: expected one of ${g(r.values, "|")}`;
      case "too_big": {
        const n = r.inclusive ? "<=" : "<", o = t(r.origin);
        return o ? `Too big: expected ${r.origin ?? "value"} to have ${n}${r.maximum.toString()} ${o.unit ?? "elements"}` : `Too big: expected ${r.origin ?? "value"} to be ${n}${r.maximum.toString()}`;
      }
      case "too_small": {
        const n = r.inclusive ? ">=" : ">", o = t(r.origin);
        return o ? `Too small: expected ${r.origin} to have ${n}${r.minimum.toString()} ${o.unit}` : `Too small: expected ${r.origin} to be ${n}${r.minimum.toString()}`;
      }
      case "invalid_format": {
        const n = r;
        return n.format === "starts_with" ? `Invalid string: must start with "${n.prefix}"` : n.format === "ends_with" ? `Invalid string: must end with "${n.suffix}"` : n.format === "includes" ? `Invalid string: must include "${n.includes}"` : n.format === "regex" ? `Invalid string: must match pattern ${n.pattern}` : `Invalid ${i[n.format] ?? r.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${r.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${r.keys.length > 1 ? "s" : ""}: ${g(r.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${r.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${r.origin}`;
      default:
        return "Invalid input";
    }
  };
};
function Xu() {
  return {
    localeError: Ad()
  };
}
const Ld = (e) => {
  const t = typeof e;
  switch (t) {
    case "number":
      return Number.isNaN(e) ? "NaN" : "nombro";
    case "object": {
      if (Array.isArray(e))
        return "tabelo";
      if (e === null)
        return "senvalora";
      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
        return e.constructor.name;
    }
  }
  return t;
}, Rd = () => {
  const e = {
    string: { unit: "karaktrojn", verb: "havi" },
    file: { unit: "bajtojn", verb: "havi" },
    array: { unit: "elementojn", verb: "havi" },
    set: { unit: "elementojn", verb: "havi" }
  };
  function t(r) {
    return e[r] ?? null;
  }
  const i = {
    regex: "enigo",
    email: "retadreso",
    url: "URL",
    emoji: "emoĝio",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datotempo",
    date: "ISO-dato",
    time: "ISO-tempo",
    duration: "ISO-daŭro",
    ipv4: "IPv4-adreso",
    ipv6: "IPv6-adreso",
    cidrv4: "IPv4-rango",
    cidrv6: "IPv6-rango",
    base64: "64-ume kodita karaktraro",
    base64url: "URL-64-ume kodita karaktraro",
    json_string: "JSON-karaktraro",
    e164: "E.164-nombro",
    jwt: "JWT",
    template_literal: "enigo"
  };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return `Nevalida enigo: atendiĝis ${r.expected}, riceviĝis ${Ld(r.input)}`;
      case "invalid_value":
        return r.values.length === 1 ? `Nevalida enigo: atendiĝis ${h(r.values[0])}` : `Nevalida opcio: atendiĝis unu el ${g(r.values, "|")}`;
      case "too_big": {
        const n = r.inclusive ? "<=" : "<", o = t(r.origin);
        return o ? `Tro granda: atendiĝis ke ${r.origin ?? "valoro"} havu ${n}${r.maximum.toString()} ${o.unit ?? "elementojn"}` : `Tro granda: atendiĝis ke ${r.origin ?? "valoro"} havu ${n}${r.maximum.toString()}`;
      }
      case "too_small": {
        const n = r.inclusive ? ">=" : ">", o = t(r.origin);
        return o ? `Tro malgranda: atendiĝis ke ${r.origin} havu ${n}${r.minimum.toString()} ${o.unit}` : `Tro malgranda: atendiĝis ke ${r.origin} estu ${n}${r.minimum.toString()}`;
      }
      case "invalid_format": {
        const n = r;
        return n.format === "starts_with" ? `Nevalida karaktraro: devas komenciĝi per "${n.prefix}"` : n.format === "ends_with" ? `Nevalida karaktraro: devas finiĝi per "${n.suffix}"` : n.format === "includes" ? `Nevalida karaktraro: devas inkluzivi "${n.includes}"` : n.format === "regex" ? `Nevalida karaktraro: devas kongrui kun la modelo ${n.pattern}` : `Nevalida ${i[n.format] ?? r.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${r.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${r.keys.length > 1 ? "j" : ""} ŝlosilo${r.keys.length > 1 ? "j" : ""}: ${g(r.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida ŝlosilo en ${r.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${r.origin}`;
      default:
        return "Nevalida enigo";
    }
  };
};
function Cd() {
  return {
    localeError: Rd()
  };
}
const Jd = () => {
  const e = {
    string: { unit: "caracteres", verb: "tener" },
    file: { unit: "bytes", verb: "tener" },
    array: { unit: "elementos", verb: "tener" },
    set: { unit: "elementos", verb: "tener" }
  }, t = {
    string: "texto",
    number: "número",
    boolean: "booleano",
    array: "arreglo",
    object: "objeto",
    set: "conjunto",
    file: "archivo",
    date: "fecha",
    bigint: "número grande",
    symbol: "símbolo",
    undefined: "indefinido",
    null: "nulo",
    function: "función",
    map: "mapa",
    record: "registro",
    tuple: "tupla",
    enum: "enumeración",
    union: "unión",
    literal: "literal",
    promise: "promesa",
    void: "vacío",
    never: "nunca",
    unknown: "desconocido",
    any: "cualquiera"
  };
  function i(a) {
    return e[a] ?? null;
  }
  function r(a) {
    return t[a] ?? a;
  }
  const n = (a) => {
    const u = typeof a;
    switch (u) {
      case "number":
        return Number.isNaN(a) ? "NaN" : "number";
      case "object":
        return Array.isArray(a) ? "array" : a === null ? "null" : Object.getPrototypeOf(a) !== Object.prototype ? a.constructor.name : "object";
    }
    return u;
  }, o = {
    regex: "entrada",
    email: "dirección de correo electrónico",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "fecha y hora ISO",
    date: "fecha ISO",
    time: "hora ISO",
    duration: "duración ISO",
    ipv4: "dirección IPv4",
    ipv6: "dirección IPv6",
    cidrv4: "rango IPv4",
    cidrv6: "rango IPv6",
    base64: "cadena codificada en base64",
    base64url: "URL codificada en base64",
    json_string: "cadena JSON",
    e164: "número E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (a) => {
    switch (a.code) {
      case "invalid_type":
        return `Entrada inválida: se esperaba ${r(a.expected)}, recibido ${r(n(a.input))}`;
      // return `Entrada inválida: se esperaba ${issue.expected}, recibido ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        return a.values.length === 1 ? `Entrada inválida: se esperaba ${h(a.values[0])}` : `Opción inválida: se esperaba una de ${g(a.values, "|")}`;
      case "too_big": {
        const u = a.inclusive ? "<=" : "<", l = i(a.origin), c = r(a.origin);
        return l ? `Demasiado grande: se esperaba que ${c ?? "valor"} tuviera ${u}${a.maximum.toString()} ${l.unit ?? "elementos"}` : `Demasiado grande: se esperaba que ${c ?? "valor"} fuera ${u}${a.maximum.toString()}`;
      }
      case "too_small": {
        const u = a.inclusive ? ">=" : ">", l = i(a.origin), c = r(a.origin);
        return l ? `Demasiado pequeño: se esperaba que ${c} tuviera ${u}${a.minimum.toString()} ${l.unit}` : `Demasiado pequeño: se esperaba que ${c} fuera ${u}${a.minimum.toString()}`;
      }
      case "invalid_format": {
        const u = a;
        return u.format === "starts_with" ? `Cadena inválida: debe comenzar con "${u.prefix}"` : u.format === "ends_with" ? `Cadena inválida: debe terminar en "${u.suffix}"` : u.format === "includes" ? `Cadena inválida: debe incluir "${u.includes}"` : u.format === "regex" ? `Cadena inválida: debe coincidir con el patrón ${u.pattern}` : `Inválido ${o[u.format] ?? a.format}`;
      }
      case "not_multiple_of":
        return `Número inválido: debe ser múltiplo de ${a.divisor}`;
      case "unrecognized_keys":
        return `Llave${a.keys.length > 1 ? "s" : ""} desconocida${a.keys.length > 1 ? "s" : ""}: ${g(a.keys, ", ")}`;
      case "invalid_key":
        return `Llave inválida en ${r(a.origin)}`;
      case "invalid_union":
        return "Entrada inválida";
      case "invalid_element":
        return `Valor inválido en ${r(a.origin)}`;
      default:
        return "Entrada inválida";
    }
  };
};
function Fd() {
  return {
    localeError: Jd()
  };
}
const Md = () => {
  const e = {
    string: { unit: "کاراکتر", verb: "داشته باشد" },
    file: { unit: "بایت", verb: "داشته باشد" },
    array: { unit: "آیتم", verb: "داشته باشد" },
    set: { unit: "آیتم", verb: "داشته باشد" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const i = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "عدد";
      case "object": {
        if (Array.isArray(n))
          return "آرایه";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, r = {
    regex: "ورودی",
    email: "آدرس ایمیل",
    url: "URL",
    emoji: "ایموجی",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "تاریخ و زمان ایزو",
    date: "تاریخ ایزو",
    time: "زمان ایزو",
    duration: "مدت زمان ایزو",
    ipv4: "IPv4 آدرس",
    ipv6: "IPv6 آدرس",
    cidrv4: "IPv4 دامنه",
    cidrv6: "IPv6 دامنه",
    base64: "base64-encoded رشته",
    base64url: "base64url-encoded رشته",
    json_string: "JSON رشته",
    e164: "E.164 عدد",
    jwt: "JWT",
    template_literal: "ورودی"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `ورودی نامعتبر: می‌بایست ${n.expected} می‌بود، ${i(n.input)} دریافت شد`;
      case "invalid_value":
        return n.values.length === 1 ? `ورودی نامعتبر: می‌بایست ${h(n.values[0])} می‌بود` : `گزینه نامعتبر: می‌بایست یکی از ${g(n.values, "|")} می‌بود`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `خیلی بزرگ: ${n.origin ?? "مقدار"} باید ${o}${n.maximum.toString()} ${a.unit ?? "عنصر"} باشد` : `خیلی بزرگ: ${n.origin ?? "مقدار"} باید ${o}${n.maximum.toString()} باشد`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `خیلی کوچک: ${n.origin} باید ${o}${n.minimum.toString()} ${a.unit} باشد` : `خیلی کوچک: ${n.origin} باید ${o}${n.minimum.toString()} باشد`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `رشته نامعتبر: باید با "${o.prefix}" شروع شود` : o.format === "ends_with" ? `رشته نامعتبر: باید با "${o.suffix}" تمام شود` : o.format === "includes" ? `رشته نامعتبر: باید شامل "${o.includes}" باشد` : o.format === "regex" ? `رشته نامعتبر: باید با الگوی ${o.pattern} مطابقت داشته باشد` : `${r[o.format] ?? n.format} نامعتبر`;
      }
      case "not_multiple_of":
        return `عدد نامعتبر: باید مضرب ${n.divisor} باشد`;
      case "unrecognized_keys":
        return `کلید${n.keys.length > 1 ? "های" : ""} ناشناس: ${g(n.keys, ", ")}`;
      case "invalid_key":
        return `کلید ناشناس در ${n.origin}`;
      case "invalid_union":
        return "ورودی نامعتبر";
      case "invalid_element":
        return `مقدار نامعتبر در ${n.origin}`;
      default:
        return "ورودی نامعتبر";
    }
  };
};
function Gd() {
  return {
    localeError: Md()
  };
}
const Vd = () => {
  const e = {
    string: { unit: "merkkiä", subject: "merkkijonon" },
    file: { unit: "tavua", subject: "tiedoston" },
    array: { unit: "alkiota", subject: "listan" },
    set: { unit: "alkiota", subject: "joukon" },
    number: { unit: "", subject: "luvun" },
    bigint: { unit: "", subject: "suuren kokonaisluvun" },
    int: { unit: "", subject: "kokonaisluvun" },
    date: { unit: "", subject: "päivämäärän" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const i = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(n))
          return "array";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, r = {
    regex: "säännöllinen lauseke",
    email: "sähköpostiosoite",
    url: "URL-osoite",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-aikaleima",
    date: "ISO-päivämäärä",
    time: "ISO-aika",
    duration: "ISO-kesto",
    ipv4: "IPv4-osoite",
    ipv6: "IPv6-osoite",
    cidrv4: "IPv4-alue",
    cidrv6: "IPv6-alue",
    base64: "base64-koodattu merkkijono",
    base64url: "base64url-koodattu merkkijono",
    json_string: "JSON-merkkijono",
    e164: "E.164-luku",
    jwt: "JWT",
    template_literal: "templaattimerkkijono"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Virheellinen tyyppi: odotettiin ${n.expected}, oli ${i(n.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `Virheellinen syöte: täytyy olla ${h(n.values[0])}` : `Virheellinen valinta: täytyy olla yksi seuraavista: ${g(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `Liian suuri: ${a.subject} täytyy olla ${o}${n.maximum.toString()} ${a.unit}`.trim() : `Liian suuri: arvon täytyy olla ${o}${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `Liian pieni: ${a.subject} täytyy olla ${o}${n.minimum.toString()} ${a.unit}`.trim() : `Liian pieni: arvon täytyy olla ${o}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `Virheellinen syöte: täytyy alkaa "${o.prefix}"` : o.format === "ends_with" ? `Virheellinen syöte: täytyy loppua "${o.suffix}"` : o.format === "includes" ? `Virheellinen syöte: täytyy sisältää "${o.includes}"` : o.format === "regex" ? `Virheellinen syöte: täytyy vastata säännöllistä lauseketta ${o.pattern}` : `Virheellinen ${r[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: täytyy olla luvun ${n.divisor} monikerta`;
      case "unrecognized_keys":
        return `${n.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${g(n.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return "Virheellinen syöte";
    }
  };
};
function Kd() {
  return {
    localeError: Vd()
  };
}
const Wd = () => {
  const e = {
    string: { unit: "caractères", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "éléments", verb: "avoir" },
    set: { unit: "éléments", verb: "avoir" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const i = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "nombre";
      case "object": {
        if (Array.isArray(n))
          return "tableau";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, r = {
    regex: "entrée",
    email: "adresse e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date et heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "durée ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "chaîne encodée en base64",
    base64url: "chaîne encodée en base64url",
    json_string: "chaîne JSON",
    e164: "numéro E.164",
    jwt: "JWT",
    template_literal: "entrée"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Entrée invalide : ${n.expected} attendu, ${i(n.input)} reçu`;
      case "invalid_value":
        return n.values.length === 1 ? `Entrée invalide : ${h(n.values[0])} attendu` : `Option invalide : une valeur parmi ${g(n.values, "|")} attendue`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `Trop grand : ${n.origin ?? "valeur"} doit ${a.verb} ${o}${n.maximum.toString()} ${a.unit ?? "élément(s)"}` : `Trop grand : ${n.origin ?? "valeur"} doit être ${o}${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `Trop petit : ${n.origin} doit ${a.verb} ${o}${n.minimum.toString()} ${a.unit}` : `Trop petit : ${n.origin} doit être ${o}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `Chaîne invalide : doit commencer par "${o.prefix}"` : o.format === "ends_with" ? `Chaîne invalide : doit se terminer par "${o.suffix}"` : o.format === "includes" ? `Chaîne invalide : doit inclure "${o.includes}"` : o.format === "regex" ? `Chaîne invalide : doit correspondre au modèle ${o.pattern}` : `${r[o.format] ?? n.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit être un multiple de ${n.divisor}`;
      case "unrecognized_keys":
        return `Clé${n.keys.length > 1 ? "s" : ""} non reconnue${n.keys.length > 1 ? "s" : ""} : ${g(n.keys, ", ")}`;
      case "invalid_key":
        return `Clé invalide dans ${n.origin}`;
      case "invalid_union":
        return "Entrée invalide";
      case "invalid_element":
        return `Valeur invalide dans ${n.origin}`;
      default:
        return "Entrée invalide";
    }
  };
};
function Bd() {
  return {
    localeError: Wd()
  };
}
const Xd = () => {
  const e = {
    string: { unit: "caractères", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "éléments", verb: "avoir" },
    set: { unit: "éléments", verb: "avoir" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const i = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(n))
          return "array";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, r = {
    regex: "entrée",
    email: "adresse courriel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date-heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "durée ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "chaîne encodée en base64",
    base64url: "chaîne encodée en base64url",
    json_string: "chaîne JSON",
    e164: "numéro E.164",
    jwt: "JWT",
    template_literal: "entrée"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Entrée invalide : attendu ${n.expected}, reçu ${i(n.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `Entrée invalide : attendu ${h(n.values[0])}` : `Option invalide : attendu l'une des valeurs suivantes ${g(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "≤" : "<", a = t(n.origin);
        return a ? `Trop grand : attendu que ${n.origin ?? "la valeur"} ait ${o}${n.maximum.toString()} ${a.unit}` : `Trop grand : attendu que ${n.origin ?? "la valeur"} soit ${o}${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? "≥" : ">", a = t(n.origin);
        return a ? `Trop petit : attendu que ${n.origin} ait ${o}${n.minimum.toString()} ${a.unit}` : `Trop petit : attendu que ${n.origin} soit ${o}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `Chaîne invalide : doit commencer par "${o.prefix}"` : o.format === "ends_with" ? `Chaîne invalide : doit se terminer par "${o.suffix}"` : o.format === "includes" ? `Chaîne invalide : doit inclure "${o.includes}"` : o.format === "regex" ? `Chaîne invalide : doit correspondre au motif ${o.pattern}` : `${r[o.format] ?? n.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit être un multiple de ${n.divisor}`;
      case "unrecognized_keys":
        return `Clé${n.keys.length > 1 ? "s" : ""} non reconnue${n.keys.length > 1 ? "s" : ""} : ${g(n.keys, ", ")}`;
      case "invalid_key":
        return `Clé invalide dans ${n.origin}`;
      case "invalid_union":
        return "Entrée invalide";
      case "invalid_element":
        return `Valeur invalide dans ${n.origin}`;
      default:
        return "Entrée invalide";
    }
  };
};
function qd() {
  return {
    localeError: Xd()
  };
}
const Yd = () => {
  const e = {
    string: { label: "מחרוזת", gender: "f" },
    number: { label: "מספר", gender: "m" },
    boolean: { label: "ערך בוליאני", gender: "m" },
    bigint: { label: "BigInt", gender: "m" },
    date: { label: "תאריך", gender: "m" },
    array: { label: "מערך", gender: "m" },
    object: { label: "אובייקט", gender: "m" },
    null: { label: "ערך ריק (null)", gender: "m" },
    undefined: { label: "ערך לא מוגדר (undefined)", gender: "m" },
    symbol: { label: "סימבול (Symbol)", gender: "m" },
    function: { label: "פונקציה", gender: "f" },
    map: { label: "מפה (Map)", gender: "f" },
    set: { label: "קבוצה (Set)", gender: "f" },
    file: { label: "קובץ", gender: "m" },
    promise: { label: "Promise", gender: "m" },
    NaN: { label: "NaN", gender: "m" },
    unknown: { label: "ערך לא ידוע", gender: "m" },
    value: { label: "ערך", gender: "m" }
  }, t = {
    string: { unit: "תווים", shortLabel: "קצר", longLabel: "ארוך" },
    file: { unit: "בייטים", shortLabel: "קטן", longLabel: "גדול" },
    array: { unit: "פריטים", shortLabel: "קטן", longLabel: "גדול" },
    set: { unit: "פריטים", shortLabel: "קטן", longLabel: "גדול" },
    number: { unit: "", shortLabel: "קטן", longLabel: "גדול" }
    // no unit
  }, i = (c) => c ? e[c] : void 0, r = (c) => {
    const d = i(c);
    return d ? d.label : c ?? e.unknown.label;
  }, n = (c) => `ה${r(c)}`, o = (c) => (i(c)?.gender ?? "m") === "f" ? "צריכה להיות" : "צריך להיות", a = (c) => c ? t[c] ?? null : null, u = (c) => {
    const d = typeof c;
    switch (d) {
      case "number":
        return Number.isNaN(c) ? "NaN" : "number";
      case "object":
        return Array.isArray(c) ? "array" : c === null ? "null" : Object.getPrototypeOf(c) !== Object.prototype && c.constructor ? c.constructor.name : "object";
      default:
        return d;
    }
  }, l = {
    regex: { label: "קלט", gender: "m" },
    email: { label: "כתובת אימייל", gender: "f" },
    url: { label: "כתובת רשת", gender: "f" },
    emoji: { label: "אימוג'י", gender: "m" },
    uuid: { label: "UUID", gender: "m" },
    nanoid: { label: "nanoid", gender: "m" },
    guid: { label: "GUID", gender: "m" },
    cuid: { label: "cuid", gender: "m" },
    cuid2: { label: "cuid2", gender: "m" },
    ulid: { label: "ULID", gender: "m" },
    xid: { label: "XID", gender: "m" },
    ksuid: { label: "KSUID", gender: "m" },
    datetime: { label: "תאריך וזמן ISO", gender: "m" },
    date: { label: "תאריך ISO", gender: "m" },
    time: { label: "זמן ISO", gender: "m" },
    duration: { label: "משך זמן ISO", gender: "m" },
    ipv4: { label: "כתובת IPv4", gender: "f" },
    ipv6: { label: "כתובת IPv6", gender: "f" },
    cidrv4: { label: "טווח IPv4", gender: "m" },
    cidrv6: { label: "טווח IPv6", gender: "m" },
    base64: { label: "מחרוזת בבסיס 64", gender: "f" },
    base64url: { label: "מחרוזת בבסיס 64 לכתובות רשת", gender: "f" },
    json_string: { label: "מחרוזת JSON", gender: "f" },
    e164: { label: "מספר E.164", gender: "m" },
    jwt: { label: "JWT", gender: "m" },
    ends_with: { label: "קלט", gender: "m" },
    includes: { label: "קלט", gender: "m" },
    lowercase: { label: "קלט", gender: "m" },
    starts_with: { label: "קלט", gender: "m" },
    uppercase: { label: "קלט", gender: "m" }
  };
  return (c) => {
    switch (c.code) {
      case "invalid_type": {
        const d = c.expected, f = r(d), p = u(c.input), v = e[p]?.label ?? p;
        return `קלט לא תקין: צריך להיות ${f}, התקבל ${v}`;
      }
      case "invalid_value": {
        if (c.values.length === 1)
          return `ערך לא תקין: הערך חייב להיות ${h(c.values[0])}`;
        const d = c.values.map((v) => h(v));
        if (c.values.length === 2)
          return `ערך לא תקין: האפשרויות המתאימות הן ${d[0]} או ${d[1]}`;
        const f = d[d.length - 1];
        return `ערך לא תקין: האפשרויות המתאימות הן ${d.slice(0, -1).join(", ")} או ${f}`;
      }
      case "too_big": {
        const d = a(c.origin), f = n(c.origin ?? "value");
        if (c.origin === "string")
          return `${d?.longLabel ?? "ארוך"} מדי: ${f} צריכה להכיל ${c.maximum.toString()} ${d?.unit ?? ""} ${c.inclusive ? "או פחות" : "לכל היותר"}`.trim();
        if (c.origin === "number") {
          const y = c.inclusive ? `קטן או שווה ל-${c.maximum}` : `קטן מ-${c.maximum}`;
          return `גדול מדי: ${f} צריך להיות ${y}`;
        }
        if (c.origin === "array" || c.origin === "set") {
          const y = c.origin === "set" ? "צריכה" : "צריך", T = c.inclusive ? `${c.maximum} ${d?.unit ?? ""} או פחות` : `פחות מ-${c.maximum} ${d?.unit ?? ""}`;
          return `גדול מדי: ${f} ${y} להכיל ${T}`.trim();
        }
        const p = c.inclusive ? "<=" : "<", v = o(c.origin ?? "value");
        return d?.unit ? `${d.longLabel} מדי: ${f} ${v} ${p}${c.maximum.toString()} ${d.unit}` : `${d?.longLabel ?? "גדול"} מדי: ${f} ${v} ${p}${c.maximum.toString()}`;
      }
      case "too_small": {
        const d = a(c.origin), f = n(c.origin ?? "value");
        if (c.origin === "string")
          return `${d?.shortLabel ?? "קצר"} מדי: ${f} צריכה להכיל ${c.minimum.toString()} ${d?.unit ?? ""} ${c.inclusive ? "או יותר" : "לפחות"}`.trim();
        if (c.origin === "number") {
          const y = c.inclusive ? `גדול או שווה ל-${c.minimum}` : `גדול מ-${c.minimum}`;
          return `קטן מדי: ${f} צריך להיות ${y}`;
        }
        if (c.origin === "array" || c.origin === "set") {
          const y = c.origin === "set" ? "צריכה" : "צריך";
          if (c.minimum === 1 && c.inclusive) {
            const rn = (c.origin === "set", "לפחות פריט אחד");
            return `קטן מדי: ${f} ${y} להכיל ${rn}`;
          }
          const T = c.inclusive ? `${c.minimum} ${d?.unit ?? ""} או יותר` : `יותר מ-${c.minimum} ${d?.unit ?? ""}`;
          return `קטן מדי: ${f} ${y} להכיל ${T}`.trim();
        }
        const p = c.inclusive ? ">=" : ">", v = o(c.origin ?? "value");
        return d?.unit ? `${d.shortLabel} מדי: ${f} ${v} ${p}${c.minimum.toString()} ${d.unit}` : `${d?.shortLabel ?? "קטן"} מדי: ${f} ${v} ${p}${c.minimum.toString()}`;
      }
      case "invalid_format": {
        const d = c;
        if (d.format === "starts_with")
          return `המחרוזת חייבת להתחיל ב "${d.prefix}"`;
        if (d.format === "ends_with")
          return `המחרוזת חייבת להסתיים ב "${d.suffix}"`;
        if (d.format === "includes")
          return `המחרוזת חייבת לכלול "${d.includes}"`;
        if (d.format === "regex")
          return `המחרוזת חייבת להתאים לתבנית ${d.pattern}`;
        const f = l[d.format], p = f?.label ?? d.format, y = (f?.gender ?? "m") === "f" ? "תקינה" : "תקין";
        return `${p} לא ${y}`;
      }
      case "not_multiple_of":
        return `מספר לא תקין: חייב להיות מכפלה של ${c.divisor}`;
      case "unrecognized_keys":
        return `מפתח${c.keys.length > 1 ? "ות" : ""} לא מזוה${c.keys.length > 1 ? "ים" : "ה"}: ${g(c.keys, ", ")}`;
      case "invalid_key":
        return "שדה לא תקין באובייקט";
      case "invalid_union":
        return "קלט לא תקין";
      case "invalid_element":
        return `ערך לא תקין ב${n(c.origin ?? "array")}`;
      default:
        return "קלט לא תקין";
    }
  };
};
function Hd() {
  return {
    localeError: Yd()
  };
}
const Qd = () => {
  const e = {
    string: { unit: "karakter", verb: "legyen" },
    file: { unit: "byte", verb: "legyen" },
    array: { unit: "elem", verb: "legyen" },
    set: { unit: "elem", verb: "legyen" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const i = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "szám";
      case "object": {
        if (Array.isArray(n))
          return "tömb";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, r = {
    regex: "bemenet",
    email: "email cím",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO időbélyeg",
    date: "ISO dátum",
    time: "ISO idő",
    duration: "ISO időintervallum",
    ipv4: "IPv4 cím",
    ipv6: "IPv6 cím",
    cidrv4: "IPv4 tartomány",
    cidrv6: "IPv6 tartomány",
    base64: "base64-kódolt string",
    base64url: "base64url-kódolt string",
    json_string: "JSON string",
    e164: "E.164 szám",
    jwt: "JWT",
    template_literal: "bemenet"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Érvénytelen bemenet: a várt érték ${n.expected}, a kapott érték ${i(n.input)}`;
      // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `Érvénytelen bemenet: a várt érték ${h(n.values[0])}` : `Érvénytelen opció: valamelyik érték várt ${g(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `Túl nagy: ${n.origin ?? "érték"} mérete túl nagy ${o}${n.maximum.toString()} ${a.unit ?? "elem"}` : `Túl nagy: a bemeneti érték ${n.origin ?? "érték"} túl nagy: ${o}${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `Túl kicsi: a bemeneti érték ${n.origin} mérete túl kicsi ${o}${n.minimum.toString()} ${a.unit}` : `Túl kicsi: a bemeneti érték ${n.origin} túl kicsi ${o}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `Érvénytelen string: "${o.prefix}" értékkel kell kezdődnie` : o.format === "ends_with" ? `Érvénytelen string: "${o.suffix}" értékkel kell végződnie` : o.format === "includes" ? `Érvénytelen string: "${o.includes}" értéket kell tartalmaznia` : o.format === "regex" ? `Érvénytelen string: ${o.pattern} mintának kell megfelelnie` : `Érvénytelen ${r[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Érvénytelen szám: ${n.divisor} többszörösének kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${n.keys.length > 1 ? "s" : ""}: ${g(n.keys, ", ")}`;
      case "invalid_key":
        return `Érvénytelen kulcs ${n.origin}`;
      case "invalid_union":
        return "Érvénytelen bemenet";
      case "invalid_element":
        return `Érvénytelen érték: ${n.origin}`;
      default:
        return "Érvénytelen bemenet";
    }
  };
};
function em() {
  return {
    localeError: Qd()
  };
}
const nm = () => {
  const e = {
    string: { unit: "karakter", verb: "memiliki" },
    file: { unit: "byte", verb: "memiliki" },
    array: { unit: "item", verb: "memiliki" },
    set: { unit: "item", verb: "memiliki" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const i = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(n))
          return "array";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, r = {
    regex: "input",
    email: "alamat email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tanggal dan waktu format ISO",
    date: "tanggal format ISO",
    time: "jam format ISO",
    duration: "durasi format ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "rentang alamat IPv4",
    cidrv6: "rentang alamat IPv6",
    base64: "string dengan enkode base64",
    base64url: "string dengan enkode base64url",
    json_string: "string JSON",
    e164: "angka E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Input tidak valid: diharapkan ${n.expected}, diterima ${i(n.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `Input tidak valid: diharapkan ${h(n.values[0])}` : `Pilihan tidak valid: diharapkan salah satu dari ${g(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `Terlalu besar: diharapkan ${n.origin ?? "value"} memiliki ${o}${n.maximum.toString()} ${a.unit ?? "elemen"}` : `Terlalu besar: diharapkan ${n.origin ?? "value"} menjadi ${o}${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `Terlalu kecil: diharapkan ${n.origin} memiliki ${o}${n.minimum.toString()} ${a.unit}` : `Terlalu kecil: diharapkan ${n.origin} menjadi ${o}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `String tidak valid: harus dimulai dengan "${o.prefix}"` : o.format === "ends_with" ? `String tidak valid: harus berakhir dengan "${o.suffix}"` : o.format === "includes" ? `String tidak valid: harus menyertakan "${o.includes}"` : o.format === "regex" ? `String tidak valid: harus sesuai pola ${o.pattern}` : `${r[o.format] ?? n.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${n.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${n.keys.length > 1 ? "s" : ""}: ${g(n.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${n.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${n.origin}`;
      default:
        return "Input tidak valid";
    }
  };
};
function tm() {
  return {
    localeError: nm()
  };
}
const rm = (e) => {
  const t = typeof e;
  switch (t) {
    case "number":
      return Number.isNaN(e) ? "NaN" : "númer";
    case "object": {
      if (Array.isArray(e))
        return "fylki";
      if (e === null)
        return "null";
      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
        return e.constructor.name;
    }
  }
  return t;
}, im = () => {
  const e = {
    string: { unit: "stafi", verb: "að hafa" },
    file: { unit: "bæti", verb: "að hafa" },
    array: { unit: "hluti", verb: "að hafa" },
    set: { unit: "hluti", verb: "að hafa" }
  };
  function t(r) {
    return e[r] ?? null;
  }
  const i = {
    regex: "gildi",
    email: "netfang",
    url: "vefslóð",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dagsetning og tími",
    date: "ISO dagsetning",
    time: "ISO tími",
    duration: "ISO tímalengd",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded strengur",
    base64url: "base64url-encoded strengur",
    json_string: "JSON strengur",
    e164: "E.164 tölugildi",
    jwt: "JWT",
    template_literal: "gildi"
  };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return `Rangt gildi: Þú slóst inn ${rm(r.input)} þar sem á að vera ${r.expected}`;
      case "invalid_value":
        return r.values.length === 1 ? `Rangt gildi: gert ráð fyrir ${h(r.values[0])}` : `Ógilt val: má vera eitt af eftirfarandi ${g(r.values, "|")}`;
      case "too_big": {
        const n = r.inclusive ? "<=" : "<", o = t(r.origin);
        return o ? `Of stórt: gert er ráð fyrir að ${r.origin ?? "gildi"} hafi ${n}${r.maximum.toString()} ${o.unit ?? "hluti"}` : `Of stórt: gert er ráð fyrir að ${r.origin ?? "gildi"} sé ${n}${r.maximum.toString()}`;
      }
      case "too_small": {
        const n = r.inclusive ? ">=" : ">", o = t(r.origin);
        return o ? `Of lítið: gert er ráð fyrir að ${r.origin} hafi ${n}${r.minimum.toString()} ${o.unit}` : `Of lítið: gert er ráð fyrir að ${r.origin} sé ${n}${r.minimum.toString()}`;
      }
      case "invalid_format": {
        const n = r;
        return n.format === "starts_with" ? `Ógildur strengur: verður að byrja á "${n.prefix}"` : n.format === "ends_with" ? `Ógildur strengur: verður að enda á "${n.suffix}"` : n.format === "includes" ? `Ógildur strengur: verður að innihalda "${n.includes}"` : n.format === "regex" ? `Ógildur strengur: verður að fylgja mynstri ${n.pattern}` : `Rangt ${i[n.format] ?? r.format}`;
      }
      case "not_multiple_of":
        return `Röng tala: verður að vera margfeldi af ${r.divisor}`;
      case "unrecognized_keys":
        return `Óþekkt ${r.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${g(r.keys, ", ")}`;
      case "invalid_key":
        return `Rangur lykill í ${r.origin}`;
      case "invalid_union":
        return "Rangt gildi";
      case "invalid_element":
        return `Rangt gildi í ${r.origin}`;
      default:
        return "Rangt gildi";
    }
  };
};
function om() {
  return {
    localeError: im()
  };
}
const am = () => {
  const e = {
    string: { unit: "caratteri", verb: "avere" },
    file: { unit: "byte", verb: "avere" },
    array: { unit: "elementi", verb: "avere" },
    set: { unit: "elementi", verb: "avere" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const i = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "numero";
      case "object": {
        if (Array.isArray(n))
          return "vettore";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, r = {
    regex: "input",
    email: "indirizzo email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e ora ISO",
    date: "data ISO",
    time: "ora ISO",
    duration: "durata ISO",
    ipv4: "indirizzo IPv4",
    ipv6: "indirizzo IPv6",
    cidrv4: "intervallo IPv4",
    cidrv6: "intervallo IPv6",
    base64: "stringa codificata in base64",
    base64url: "URL codificata in base64",
    json_string: "stringa JSON",
    e164: "numero E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Input non valido: atteso ${n.expected}, ricevuto ${i(n.input)}`;
      // return `Input non valido: atteso ${issue.expected}, ricevuto ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `Input non valido: atteso ${h(n.values[0])}` : `Opzione non valida: atteso uno tra ${g(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `Troppo grande: ${n.origin ?? "valore"} deve avere ${o}${n.maximum.toString()} ${a.unit ?? "elementi"}` : `Troppo grande: ${n.origin ?? "valore"} deve essere ${o}${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `Troppo piccolo: ${n.origin} deve avere ${o}${n.minimum.toString()} ${a.unit}` : `Troppo piccolo: ${n.origin} deve essere ${o}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `Stringa non valida: deve iniziare con "${o.prefix}"` : o.format === "ends_with" ? `Stringa non valida: deve terminare con "${o.suffix}"` : o.format === "includes" ? `Stringa non valida: deve includere "${o.includes}"` : o.format === "regex" ? `Stringa non valida: deve corrispondere al pattern ${o.pattern}` : `Invalid ${r[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${n.divisor}`;
      case "unrecognized_keys":
        return `Chiav${n.keys.length > 1 ? "i" : "e"} non riconosciut${n.keys.length > 1 ? "e" : "a"}: ${g(n.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${n.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${n.origin}`;
      default:
        return "Input non valido";
    }
  };
};
function um() {
  return {
    localeError: am()
  };
}
const cm = () => {
  const e = {
    string: { unit: "文字", verb: "である" },
    file: { unit: "バイト", verb: "である" },
    array: { unit: "要素", verb: "である" },
    set: { unit: "要素", verb: "である" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const i = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "数値";
      case "object": {
        if (Array.isArray(n))
          return "配列";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, r = {
    regex: "入力値",
    email: "メールアドレス",
    url: "URL",
    emoji: "絵文字",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO日時",
    date: "ISO日付",
    time: "ISO時刻",
    duration: "ISO期間",
    ipv4: "IPv4アドレス",
    ipv6: "IPv6アドレス",
    cidrv4: "IPv4範囲",
    cidrv6: "IPv6範囲",
    base64: "base64エンコード文字列",
    base64url: "base64urlエンコード文字列",
    json_string: "JSON文字列",
    e164: "E.164番号",
    jwt: "JWT",
    template_literal: "入力値"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `無効な入力: ${n.expected}が期待されましたが、${i(n.input)}が入力されました`;
      case "invalid_value":
        return n.values.length === 1 ? `無効な入力: ${h(n.values[0])}が期待されました` : `無効な選択: ${g(n.values, "、")}のいずれかである必要があります`;
      case "too_big": {
        const o = n.inclusive ? "以下である" : "より小さい", a = t(n.origin);
        return a ? `大きすぎる値: ${n.origin ?? "値"}は${n.maximum.toString()}${a.unit ?? "要素"}${o}必要があります` : `大きすぎる値: ${n.origin ?? "値"}は${n.maximum.toString()}${o}必要があります`;
      }
      case "too_small": {
        const o = n.inclusive ? "以上である" : "より大きい", a = t(n.origin);
        return a ? `小さすぎる値: ${n.origin}は${n.minimum.toString()}${a.unit}${o}必要があります` : `小さすぎる値: ${n.origin}は${n.minimum.toString()}${o}必要があります`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `無効な文字列: "${o.prefix}"で始まる必要があります` : o.format === "ends_with" ? `無効な文字列: "${o.suffix}"で終わる必要があります` : o.format === "includes" ? `無効な文字列: "${o.includes}"を含む必要があります` : o.format === "regex" ? `無効な文字列: パターン${o.pattern}に一致する必要があります` : `無効な${r[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `無効な数値: ${n.divisor}の倍数である必要があります`;
      case "unrecognized_keys":
        return `認識されていないキー${n.keys.length > 1 ? "群" : ""}: ${g(n.keys, "、")}`;
      case "invalid_key":
        return `${n.origin}内の無効なキー`;
      case "invalid_union":
        return "無効な入力";
      case "invalid_element":
        return `${n.origin}内の無効な値`;
      default:
        return "無効な入力";
    }
  };
};
function lm() {
  return {
    localeError: cm()
  };
}
const sm = (e) => {
  const t = typeof e;
  switch (t) {
    case "number":
      return Number.isNaN(e) ? "NaN" : "რიცხვი";
    case "object": {
      if (Array.isArray(e))
        return "მასივი";
      if (e === null)
        return "null";
      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
        return e.constructor.name;
    }
  }
  return {
    string: "სტრინგი",
    boolean: "ბულეანი",
    undefined: "undefined",
    bigint: "bigint",
    symbol: "symbol",
    function: "ფუნქცია"
  }[t] ?? t;
}, dm = () => {
  const e = {
    string: { unit: "სიმბოლო", verb: "უნდა შეიცავდეს" },
    file: { unit: "ბაიტი", verb: "უნდა შეიცავდეს" },
    array: { unit: "ელემენტი", verb: "უნდა შეიცავდეს" },
    set: { unit: "ელემენტი", verb: "უნდა შეიცავდეს" }
  };
  function t(r) {
    return e[r] ?? null;
  }
  const i = {
    regex: "შეყვანა",
    email: "ელ-ფოსტის მისამართი",
    url: "URL",
    emoji: "ემოჯი",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "თარიღი-დრო",
    date: "თარიღი",
    time: "დრო",
    duration: "ხანგრძლივობა",
    ipv4: "IPv4 მისამართი",
    ipv6: "IPv6 მისამართი",
    cidrv4: "IPv4 დიაპაზონი",
    cidrv6: "IPv6 დიაპაზონი",
    base64: "base64-კოდირებული სტრინგი",
    base64url: "base64url-კოდირებული სტრინგი",
    json_string: "JSON სტრინგი",
    e164: "E.164 ნომერი",
    jwt: "JWT",
    template_literal: "შეყვანა"
  };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return `არასწორი შეყვანა: მოსალოდნელი ${r.expected}, მიღებული ${sm(r.input)}`;
      case "invalid_value":
        return r.values.length === 1 ? `არასწორი შეყვანა: მოსალოდნელი ${h(r.values[0])}` : `არასწორი ვარიანტი: მოსალოდნელია ერთ-ერთი ${g(r.values, "|")}-დან`;
      case "too_big": {
        const n = r.inclusive ? "<=" : "<", o = t(r.origin);
        return o ? `ზედმეტად დიდი: მოსალოდნელი ${r.origin ?? "მნიშვნელობა"} ${o.verb} ${n}${r.maximum.toString()} ${o.unit}` : `ზედმეტად დიდი: მოსალოდნელი ${r.origin ?? "მნიშვნელობა"} იყოს ${n}${r.maximum.toString()}`;
      }
      case "too_small": {
        const n = r.inclusive ? ">=" : ">", o = t(r.origin);
        return o ? `ზედმეტად პატარა: მოსალოდნელი ${r.origin} ${o.verb} ${n}${r.minimum.toString()} ${o.unit}` : `ზედმეტად პატარა: მოსალოდნელი ${r.origin} იყოს ${n}${r.minimum.toString()}`;
      }
      case "invalid_format": {
        const n = r;
        return n.format === "starts_with" ? `არასწორი სტრინგი: უნდა იწყებოდეს "${n.prefix}"-ით` : n.format === "ends_with" ? `არასწორი სტრინგი: უნდა მთავრდებოდეს "${n.suffix}"-ით` : n.format === "includes" ? `არასწორი სტრინგი: უნდა შეიცავდეს "${n.includes}"-ს` : n.format === "regex" ? `არასწორი სტრინგი: უნდა შეესაბამებოდეს შაბლონს ${n.pattern}` : `არასწორი ${i[n.format] ?? r.format}`;
      }
      case "not_multiple_of":
        return `არასწორი რიცხვი: უნდა იყოს ${r.divisor}-ის ჯერადი`;
      case "unrecognized_keys":
        return `უცნობი გასაღებ${r.keys.length > 1 ? "ები" : "ი"}: ${g(r.keys, ", ")}`;
      case "invalid_key":
        return `არასწორი გასაღები ${r.origin}-ში`;
      case "invalid_union":
        return "არასწორი შეყვანა";
      case "invalid_element":
        return `არასწორი მნიშვნელობა ${r.origin}-ში`;
      default:
        return "არასწორი შეყვანა";
    }
  };
};
function mm() {
  return {
    localeError: dm()
  };
}
const fm = () => {
  const e = {
    string: { unit: "តួអក្សរ", verb: "គួរមាន" },
    file: { unit: "បៃ", verb: "គួរមាន" },
    array: { unit: "ធាតុ", verb: "គួរមាន" },
    set: { unit: "ធាតុ", verb: "គួរមាន" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const i = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "មិនមែនជាលេខ (NaN)" : "លេខ";
      case "object": {
        if (Array.isArray(n))
          return "អារេ (Array)";
        if (n === null)
          return "គ្មានតម្លៃ (null)";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, r = {
    regex: "ទិន្នន័យបញ្ចូល",
    email: "អាសយដ្ឋានអ៊ីមែល",
    url: "URL",
    emoji: "សញ្ញាអារម្មណ៍",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "កាលបរិច្ឆេទ និងម៉ោង ISO",
    date: "កាលបរិច្ឆេទ ISO",
    time: "ម៉ោង ISO",
    duration: "រយៈពេល ISO",
    ipv4: "អាសយដ្ឋាន IPv4",
    ipv6: "អាសយដ្ឋាន IPv6",
    cidrv4: "ដែនអាសយដ្ឋាន IPv4",
    cidrv6: "ដែនអាសយដ្ឋាន IPv6",
    base64: "ខ្សែអក្សរអ៊ិកូដ base64",
    base64url: "ខ្សែអក្សរអ៊ិកូដ base64url",
    json_string: "ខ្សែអក្សរ JSON",
    e164: "លេខ E.164",
    jwt: "JWT",
    template_literal: "ទិន្នន័យបញ្ចូល"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `ទិន្នន័យបញ្ចូលមិនត្រឹមត្រូវ៖ ត្រូវការ ${n.expected} ប៉ុន្តែទទួលបាន ${i(n.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `ទិន្នន័យបញ្ចូលមិនត្រឹមត្រូវ៖ ត្រូវការ ${h(n.values[0])}` : `ជម្រើសមិនត្រឹមត្រូវ៖ ត្រូវជាមួយក្នុងចំណោម ${g(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `ធំពេក៖ ត្រូវការ ${n.origin ?? "តម្លៃ"} ${o} ${n.maximum.toString()} ${a.unit ?? "ធាតុ"}` : `ធំពេក៖ ត្រូវការ ${n.origin ?? "តម្លៃ"} ${o} ${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `តូចពេក៖ ត្រូវការ ${n.origin} ${o} ${n.minimum.toString()} ${a.unit}` : `តូចពេក៖ ត្រូវការ ${n.origin} ${o} ${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវចាប់ផ្តើមដោយ "${o.prefix}"` : o.format === "ends_with" ? `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវបញ្ចប់ដោយ "${o.suffix}"` : o.format === "includes" ? `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវមាន "${o.includes}"` : o.format === "regex" ? `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវតែផ្គូផ្គងនឹងទម្រង់ដែលបានកំណត់ ${o.pattern}` : `មិនត្រឹមត្រូវ៖ ${r[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `លេខមិនត្រឹមត្រូវ៖ ត្រូវតែជាពហុគុណនៃ ${n.divisor}`;
      case "unrecognized_keys":
        return `រកឃើញសោមិនស្គាល់៖ ${g(n.keys, ", ")}`;
      case "invalid_key":
        return `សោមិនត្រឹមត្រូវនៅក្នុង ${n.origin}`;
      case "invalid_union":
        return "ទិន្នន័យមិនត្រឹមត្រូវ";
      case "invalid_element":
        return `ទិន្នន័យមិនត្រឹមត្រូវនៅក្នុង ${n.origin}`;
      default:
        return "ទិន្នន័យមិនត្រឹមត្រូវ";
    }
  };
};
function qu() {
  return {
    localeError: fm()
  };
}
function gm() {
  return qu();
}
const pm = () => {
  const e = {
    string: { unit: "문자", verb: "to have" },
    file: { unit: "바이트", verb: "to have" },
    array: { unit: "개", verb: "to have" },
    set: { unit: "개", verb: "to have" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const i = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(n))
          return "array";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, r = {
    regex: "입력",
    email: "이메일 주소",
    url: "URL",
    emoji: "이모지",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO 날짜시간",
    date: "ISO 날짜",
    time: "ISO 시간",
    duration: "ISO 기간",
    ipv4: "IPv4 주소",
    ipv6: "IPv6 주소",
    cidrv4: "IPv4 범위",
    cidrv6: "IPv6 범위",
    base64: "base64 인코딩 문자열",
    base64url: "base64url 인코딩 문자열",
    json_string: "JSON 문자열",
    e164: "E.164 번호",
    jwt: "JWT",
    template_literal: "입력"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `잘못된 입력: 예상 타입은 ${n.expected}, 받은 타입은 ${i(n.input)}입니다`;
      case "invalid_value":
        return n.values.length === 1 ? `잘못된 입력: 값은 ${h(n.values[0])} 이어야 합니다` : `잘못된 옵션: ${g(n.values, "또는 ")} 중 하나여야 합니다`;
      case "too_big": {
        const o = n.inclusive ? "이하" : "미만", a = o === "미만" ? "이어야 합니다" : "여야 합니다", u = t(n.origin), l = u?.unit ?? "요소";
        return u ? `${n.origin ?? "값"}이 너무 큽니다: ${n.maximum.toString()}${l} ${o}${a}` : `${n.origin ?? "값"}이 너무 큽니다: ${n.maximum.toString()} ${o}${a}`;
      }
      case "too_small": {
        const o = n.inclusive ? "이상" : "초과", a = o === "이상" ? "이어야 합니다" : "여야 합니다", u = t(n.origin), l = u?.unit ?? "요소";
        return u ? `${n.origin ?? "값"}이 너무 작습니다: ${n.minimum.toString()}${l} ${o}${a}` : `${n.origin ?? "값"}이 너무 작습니다: ${n.minimum.toString()} ${o}${a}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `잘못된 문자열: "${o.prefix}"(으)로 시작해야 합니다` : o.format === "ends_with" ? `잘못된 문자열: "${o.suffix}"(으)로 끝나야 합니다` : o.format === "includes" ? `잘못된 문자열: "${o.includes}"을(를) 포함해야 합니다` : o.format === "regex" ? `잘못된 문자열: 정규식 ${o.pattern} 패턴과 일치해야 합니다` : `잘못된 ${r[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `잘못된 숫자: ${n.divisor}의 배수여야 합니다`;
      case "unrecognized_keys":
        return `인식할 수 없는 키: ${g(n.keys, ", ")}`;
      case "invalid_key":
        return `잘못된 키: ${n.origin}`;
      case "invalid_union":
        return "잘못된 입력";
      case "invalid_element":
        return `잘못된 값: ${n.origin}`;
      default:
        return "잘못된 입력";
    }
  };
};
function vm() {
  return {
    localeError: pm()
  };
}
const hm = (e) => je(typeof e, e), je = (e, t = void 0) => {
  switch (e) {
    case "number":
      return Number.isNaN(t) ? "NaN" : "skaičius";
    case "bigint":
      return "sveikasis skaičius";
    case "string":
      return "eilutė";
    case "boolean":
      return "loginė reikšmė";
    case "undefined":
    case "void":
      return "neapibrėžta reikšmė";
    case "function":
      return "funkcija";
    case "symbol":
      return "simbolis";
    case "object":
      return t === void 0 ? "nežinomas objektas" : t === null ? "nulinė reikšmė" : Array.isArray(t) ? "masyvas" : Object.getPrototypeOf(t) !== Object.prototype && t.constructor ? t.constructor.name : "objektas";
    //Zod types below
    case "null":
      return "nulinė reikšmė";
  }
  return e;
}, Se = (e) => e.charAt(0).toUpperCase() + e.slice(1);
function lo(e) {
  const t = Math.abs(e), i = t % 10, r = t % 100;
  return r >= 11 && r <= 19 || i === 0 ? "many" : i === 1 ? "one" : "few";
}
const $m = () => {
  const e = {
    string: {
      unit: {
        one: "simbolis",
        few: "simboliai",
        many: "simbolių"
      },
      verb: {
        smaller: {
          inclusive: "turi būti ne ilgesnė kaip",
          notInclusive: "turi būti trumpesnė kaip"
        },
        bigger: {
          inclusive: "turi būti ne trumpesnė kaip",
          notInclusive: "turi būti ilgesnė kaip"
        }
      }
    },
    file: {
      unit: {
        one: "baitas",
        few: "baitai",
        many: "baitų"
      },
      verb: {
        smaller: {
          inclusive: "turi būti ne didesnis kaip",
          notInclusive: "turi būti mažesnis kaip"
        },
        bigger: {
          inclusive: "turi būti ne mažesnis kaip",
          notInclusive: "turi būti didesnis kaip"
        }
      }
    },
    array: {
      unit: {
        one: "elementą",
        few: "elementus",
        many: "elementų"
      },
      verb: {
        smaller: {
          inclusive: "turi turėti ne daugiau kaip",
          notInclusive: "turi turėti mažiau kaip"
        },
        bigger: {
          inclusive: "turi turėti ne mažiau kaip",
          notInclusive: "turi turėti daugiau kaip"
        }
      }
    },
    set: {
      unit: {
        one: "elementą",
        few: "elementus",
        many: "elementų"
      },
      verb: {
        smaller: {
          inclusive: "turi turėti ne daugiau kaip",
          notInclusive: "turi turėti mažiau kaip"
        },
        bigger: {
          inclusive: "turi turėti ne mažiau kaip",
          notInclusive: "turi turėti daugiau kaip"
        }
      }
    }
  };
  function t(r, n, o, a) {
    const u = e[r] ?? null;
    return u === null ? u : {
      unit: u.unit[n],
      verb: u.verb[a][o ? "inclusive" : "notInclusive"]
    };
  }
  const i = {
    regex: "įvestis",
    email: "el. pašto adresas",
    url: "URL",
    emoji: "jaustukas",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO data ir laikas",
    date: "ISO data",
    time: "ISO laikas",
    duration: "ISO trukmė",
    ipv4: "IPv4 adresas",
    ipv6: "IPv6 adresas",
    cidrv4: "IPv4 tinklo prefiksas (CIDR)",
    cidrv6: "IPv6 tinklo prefiksas (CIDR)",
    base64: "base64 užkoduota eilutė",
    base64url: "base64url užkoduota eilutė",
    json_string: "JSON eilutė",
    e164: "E.164 numeris",
    jwt: "JWT",
    template_literal: "įvestis"
  };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return `Gautas tipas ${hm(r.input)}, o tikėtasi - ${je(r.expected)}`;
      case "invalid_value":
        return r.values.length === 1 ? `Privalo būti ${h(r.values[0])}` : `Privalo būti vienas iš ${g(r.values, "|")} pasirinkimų`;
      case "too_big": {
        const n = je(r.origin), o = t(r.origin, lo(Number(r.maximum)), r.inclusive ?? !1, "smaller");
        if (o?.verb)
          return `${Se(n ?? r.origin ?? "reikšmė")} ${o.verb} ${r.maximum.toString()} ${o.unit ?? "elementų"}`;
        const a = r.inclusive ? "ne didesnis kaip" : "mažesnis kaip";
        return `${Se(n ?? r.origin ?? "reikšmė")} turi būti ${a} ${r.maximum.toString()} ${o?.unit}`;
      }
      case "too_small": {
        const n = je(r.origin), o = t(r.origin, lo(Number(r.minimum)), r.inclusive ?? !1, "bigger");
        if (o?.verb)
          return `${Se(n ?? r.origin ?? "reikšmė")} ${o.verb} ${r.minimum.toString()} ${o.unit ?? "elementų"}`;
        const a = r.inclusive ? "ne mažesnis kaip" : "didesnis kaip";
        return `${Se(n ?? r.origin ?? "reikšmė")} turi būti ${a} ${r.minimum.toString()} ${o?.unit}`;
      }
      case "invalid_format": {
        const n = r;
        return n.format === "starts_with" ? `Eilutė privalo prasidėti "${n.prefix}"` : n.format === "ends_with" ? `Eilutė privalo pasibaigti "${n.suffix}"` : n.format === "includes" ? `Eilutė privalo įtraukti "${n.includes}"` : n.format === "regex" ? `Eilutė privalo atitikti ${n.pattern}` : `Neteisingas ${i[n.format] ?? r.format}`;
      }
      case "not_multiple_of":
        return `Skaičius privalo būti ${r.divisor} kartotinis.`;
      case "unrecognized_keys":
        return `Neatpažint${r.keys.length > 1 ? "i" : "as"} rakt${r.keys.length > 1 ? "ai" : "as"}: ${g(r.keys, ", ")}`;
      case "invalid_key":
        return "Rastas klaidingas raktas";
      case "invalid_union":
        return "Klaidinga įvestis";
      case "invalid_element": {
        const n = je(r.origin);
        return `${Se(n ?? r.origin ?? "reikšmė")} turi klaidingą įvestį`;
      }
      default:
        return "Klaidinga įvestis";
    }
  };
};
function bm() {
  return {
    localeError: $m()
  };
}
const _m = () => {
  const e = {
    string: { unit: "знаци", verb: "да имаат" },
    file: { unit: "бајти", verb: "да имаат" },
    array: { unit: "ставки", verb: "да имаат" },
    set: { unit: "ставки", verb: "да имаат" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const i = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "број";
      case "object": {
        if (Array.isArray(n))
          return "низа";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, r = {
    regex: "внес",
    email: "адреса на е-пошта",
    url: "URL",
    emoji: "емоџи",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO датум и време",
    date: "ISO датум",
    time: "ISO време",
    duration: "ISO времетраење",
    ipv4: "IPv4 адреса",
    ipv6: "IPv6 адреса",
    cidrv4: "IPv4 опсег",
    cidrv6: "IPv6 опсег",
    base64: "base64-енкодирана низа",
    base64url: "base64url-енкодирана низа",
    json_string: "JSON низа",
    e164: "E.164 број",
    jwt: "JWT",
    template_literal: "внес"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Грешен внес: се очекува ${n.expected}, примено ${i(n.input)}`;
      // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `Invalid input: expected ${h(n.values[0])}` : `Грешана опција: се очекува една ${g(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `Премногу голем: се очекува ${n.origin ?? "вредноста"} да има ${o}${n.maximum.toString()} ${a.unit ?? "елементи"}` : `Премногу голем: се очекува ${n.origin ?? "вредноста"} да биде ${o}${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `Премногу мал: се очекува ${n.origin} да има ${o}${n.minimum.toString()} ${a.unit}` : `Премногу мал: се очекува ${n.origin} да биде ${o}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `Неважечка низа: мора да започнува со "${o.prefix}"` : o.format === "ends_with" ? `Неважечка низа: мора да завршува со "${o.suffix}"` : o.format === "includes" ? `Неважечка низа: мора да вклучува "${o.includes}"` : o.format === "regex" ? `Неважечка низа: мора да одгоара на патернот ${o.pattern}` : `Invalid ${r[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Грешен број: мора да биде делив со ${n.divisor}`;
      case "unrecognized_keys":
        return `${n.keys.length > 1 ? "Непрепознаени клучеви" : "Непрепознаен клуч"}: ${g(n.keys, ", ")}`;
      case "invalid_key":
        return `Грешен клуч во ${n.origin}`;
      case "invalid_union":
        return "Грешен внес";
      case "invalid_element":
        return `Грешна вредност во ${n.origin}`;
      default:
        return "Грешен внес";
    }
  };
};
function ym() {
  return {
    localeError: _m()
  };
}
const km = () => {
  const e = {
    string: { unit: "aksara", verb: "mempunyai" },
    file: { unit: "bait", verb: "mempunyai" },
    array: { unit: "elemen", verb: "mempunyai" },
    set: { unit: "elemen", verb: "mempunyai" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const i = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "nombor";
      case "object": {
        if (Array.isArray(n))
          return "array";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, r = {
    regex: "input",
    email: "alamat e-mel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tarikh masa ISO",
    date: "tarikh ISO",
    time: "masa ISO",
    duration: "tempoh ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "julat IPv4",
    cidrv6: "julat IPv6",
    base64: "string dikodkan base64",
    base64url: "string dikodkan base64url",
    json_string: "string JSON",
    e164: "nombor E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Input tidak sah: dijangka ${n.expected}, diterima ${i(n.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `Input tidak sah: dijangka ${h(n.values[0])}` : `Pilihan tidak sah: dijangka salah satu daripada ${g(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `Terlalu besar: dijangka ${n.origin ?? "nilai"} ${a.verb} ${o}${n.maximum.toString()} ${a.unit ?? "elemen"}` : `Terlalu besar: dijangka ${n.origin ?? "nilai"} adalah ${o}${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `Terlalu kecil: dijangka ${n.origin} ${a.verb} ${o}${n.minimum.toString()} ${a.unit}` : `Terlalu kecil: dijangka ${n.origin} adalah ${o}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `String tidak sah: mesti bermula dengan "${o.prefix}"` : o.format === "ends_with" ? `String tidak sah: mesti berakhir dengan "${o.suffix}"` : o.format === "includes" ? `String tidak sah: mesti mengandungi "${o.includes}"` : o.format === "regex" ? `String tidak sah: mesti sepadan dengan corak ${o.pattern}` : `${r[o.format] ?? n.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${n.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${g(n.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${n.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${n.origin}`;
      default:
        return "Input tidak sah";
    }
  };
};
function Im() {
  return {
    localeError: km()
  };
}
const zm = () => {
  const e = {
    string: { unit: "tekens", verb: "te hebben" },
    file: { unit: "bytes", verb: "te hebben" },
    array: { unit: "elementen", verb: "te hebben" },
    set: { unit: "elementen", verb: "te hebben" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const i = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "getal";
      case "object": {
        if (Array.isArray(n))
          return "array";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, r = {
    regex: "invoer",
    email: "emailadres",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum en tijd",
    date: "ISO datum",
    time: "ISO tijd",
    duration: "ISO duur",
    ipv4: "IPv4-adres",
    ipv6: "IPv6-adres",
    cidrv4: "IPv4-bereik",
    cidrv6: "IPv6-bereik",
    base64: "base64-gecodeerde tekst",
    base64url: "base64 URL-gecodeerde tekst",
    json_string: "JSON string",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "invoer"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Ongeldige invoer: verwacht ${n.expected}, ontving ${i(n.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `Ongeldige invoer: verwacht ${h(n.values[0])}` : `Ongeldige optie: verwacht één van ${g(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `Te groot: verwacht dat ${n.origin ?? "waarde"} ${a.verb} ${o}${n.maximum.toString()} ${a.unit ?? "elementen"}` : `Te groot: verwacht dat ${n.origin ?? "waarde"} ${o}${n.maximum.toString()} is`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `Te klein: verwacht dat ${n.origin} ${a.verb} ${o}${n.minimum.toString()} ${a.unit}` : `Te klein: verwacht dat ${n.origin} ${o}${n.minimum.toString()} is`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `Ongeldige tekst: moet met "${o.prefix}" beginnen` : o.format === "ends_with" ? `Ongeldige tekst: moet op "${o.suffix}" eindigen` : o.format === "includes" ? `Ongeldige tekst: moet "${o.includes}" bevatten` : o.format === "regex" ? `Ongeldige tekst: moet overeenkomen met patroon ${o.pattern}` : `Ongeldig: ${r[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${n.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${n.keys.length > 1 ? "s" : ""}: ${g(n.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${n.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${n.origin}`;
      default:
        return "Ongeldige invoer";
    }
  };
};
function Sm() {
  return {
    localeError: zm()
  };
}
const wm = () => {
  const e = {
    string: { unit: "tegn", verb: "å ha" },
    file: { unit: "bytes", verb: "å ha" },
    array: { unit: "elementer", verb: "å inneholde" },
    set: { unit: "elementer", verb: "å inneholde" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const i = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "tall";
      case "object": {
        if (Array.isArray(n))
          return "liste";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, r = {
    regex: "input",
    email: "e-postadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslett",
    date: "ISO-dato",
    time: "ISO-klokkeslett",
    duration: "ISO-varighet",
    ipv4: "IPv4-område",
    ipv6: "IPv6-område",
    cidrv4: "IPv4-spekter",
    cidrv6: "IPv6-spekter",
    base64: "base64-enkodet streng",
    base64url: "base64url-enkodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Ugyldig input: forventet ${n.expected}, fikk ${i(n.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `Ugyldig verdi: forventet ${h(n.values[0])}` : `Ugyldig valg: forventet en av ${g(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `For stor(t): forventet ${n.origin ?? "value"} til å ha ${o}${n.maximum.toString()} ${a.unit ?? "elementer"}` : `For stor(t): forventet ${n.origin ?? "value"} til å ha ${o}${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `For lite(n): forventet ${n.origin} til å ha ${o}${n.minimum.toString()} ${a.unit}` : `For lite(n): forventet ${n.origin} til å ha ${o}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `Ugyldig streng: må starte med "${o.prefix}"` : o.format === "ends_with" ? `Ugyldig streng: må ende med "${o.suffix}"` : o.format === "includes" ? `Ugyldig streng: må inneholde "${o.includes}"` : o.format === "regex" ? `Ugyldig streng: må matche mønsteret ${o.pattern}` : `Ugyldig ${r[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: må være et multiplum av ${n.divisor}`;
      case "unrecognized_keys":
        return `${n.keys.length > 1 ? "Ukjente nøkler" : "Ukjent nøkkel"}: ${g(n.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig nøkkel i ${n.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${n.origin}`;
      default:
        return "Ugyldig input";
    }
  };
};
function jm() {
  return {
    localeError: wm()
  };
}
const Om = () => {
  const e = {
    string: { unit: "harf", verb: "olmalıdır" },
    file: { unit: "bayt", verb: "olmalıdır" },
    array: { unit: "unsur", verb: "olmalıdır" },
    set: { unit: "unsur", verb: "olmalıdır" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const i = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "numara";
      case "object": {
        if (Array.isArray(n))
          return "saf";
        if (n === null)
          return "gayb";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, r = {
    regex: "giren",
    email: "epostagâh",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO hengâmı",
    date: "ISO tarihi",
    time: "ISO zamanı",
    duration: "ISO müddeti",
    ipv4: "IPv4 nişânı",
    ipv6: "IPv6 nişânı",
    cidrv4: "IPv4 menzili",
    cidrv6: "IPv6 menzili",
    base64: "base64-şifreli metin",
    base64url: "base64url-şifreli metin",
    json_string: "JSON metin",
    e164: "E.164 sayısı",
    jwt: "JWT",
    template_literal: "giren"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Fâsit giren: umulan ${n.expected}, alınan ${i(n.input)}`;
      // return `Fâsit giren: umulan ${issue.expected}, alınan ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `Fâsit giren: umulan ${h(n.values[0])}` : `Fâsit tercih: mûteberler ${g(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `Fazla büyük: ${n.origin ?? "value"}, ${o}${n.maximum.toString()} ${a.unit ?? "elements"} sahip olmalıydı.` : `Fazla büyük: ${n.origin ?? "value"}, ${o}${n.maximum.toString()} olmalıydı.`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `Fazla küçük: ${n.origin}, ${o}${n.minimum.toString()} ${a.unit} sahip olmalıydı.` : `Fazla küçük: ${n.origin}, ${o}${n.minimum.toString()} olmalıydı.`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `Fâsit metin: "${o.prefix}" ile başlamalı.` : o.format === "ends_with" ? `Fâsit metin: "${o.suffix}" ile bitmeli.` : o.format === "includes" ? `Fâsit metin: "${o.includes}" ihtivâ etmeli.` : o.format === "regex" ? `Fâsit metin: ${o.pattern} nakşına uymalı.` : `Fâsit ${r[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Fâsit sayı: ${n.divisor} katı olmalıydı.`;
      case "unrecognized_keys":
        return `Tanınmayan anahtar ${n.keys.length > 1 ? "s" : ""}: ${g(n.keys, ", ")}`;
      case "invalid_key":
        return `${n.origin} için tanınmayan anahtar var.`;
      case "invalid_union":
        return "Giren tanınamadı.";
      case "invalid_element":
        return `${n.origin} için tanınmayan kıymet var.`;
      default:
        return "Kıymet tanınamadı.";
    }
  };
};
function Nm() {
  return {
    localeError: Om()
  };
}
const Um = () => {
  const e = {
    string: { unit: "توکي", verb: "ولري" },
    file: { unit: "بایټس", verb: "ولري" },
    array: { unit: "توکي", verb: "ولري" },
    set: { unit: "توکي", verb: "ولري" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const i = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "عدد";
      case "object": {
        if (Array.isArray(n))
          return "ارې";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, r = {
    regex: "ورودي",
    email: "بریښنالیک",
    url: "یو آر ال",
    emoji: "ایموجي",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "نیټه او وخت",
    date: "نېټه",
    time: "وخت",
    duration: "موده",
    ipv4: "د IPv4 پته",
    ipv6: "د IPv6 پته",
    cidrv4: "د IPv4 ساحه",
    cidrv6: "د IPv6 ساحه",
    base64: "base64-encoded متن",
    base64url: "base64url-encoded متن",
    json_string: "JSON متن",
    e164: "د E.164 شمېره",
    jwt: "JWT",
    template_literal: "ورودي"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `ناسم ورودي: باید ${n.expected} وای, مګر ${i(n.input)} ترلاسه شو`;
      case "invalid_value":
        return n.values.length === 1 ? `ناسم ورودي: باید ${h(n.values[0])} وای` : `ناسم انتخاب: باید یو له ${g(n.values, "|")} څخه وای`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `ډیر لوی: ${n.origin ?? "ارزښت"} باید ${o}${n.maximum.toString()} ${a.unit ?? "عنصرونه"} ولري` : `ډیر لوی: ${n.origin ?? "ارزښت"} باید ${o}${n.maximum.toString()} وي`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `ډیر کوچنی: ${n.origin} باید ${o}${n.minimum.toString()} ${a.unit} ولري` : `ډیر کوچنی: ${n.origin} باید ${o}${n.minimum.toString()} وي`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `ناسم متن: باید د "${o.prefix}" سره پیل شي` : o.format === "ends_with" ? `ناسم متن: باید د "${o.suffix}" سره پای ته ورسيږي` : o.format === "includes" ? `ناسم متن: باید "${o.includes}" ولري` : o.format === "regex" ? `ناسم متن: باید د ${o.pattern} سره مطابقت ولري` : `${r[o.format] ?? n.format} ناسم دی`;
      }
      case "not_multiple_of":
        return `ناسم عدد: باید د ${n.divisor} مضرب وي`;
      case "unrecognized_keys":
        return `ناسم ${n.keys.length > 1 ? "کلیډونه" : "کلیډ"}: ${g(n.keys, ", ")}`;
      case "invalid_key":
        return `ناسم کلیډ په ${n.origin} کې`;
      case "invalid_union":
        return "ناسمه ورودي";
      case "invalid_element":
        return `ناسم عنصر په ${n.origin} کې`;
      default:
        return "ناسمه ورودي";
    }
  };
};
function xm() {
  return {
    localeError: Um()
  };
}
const Pm = () => {
  const e = {
    string: { unit: "znaków", verb: "mieć" },
    file: { unit: "bajtów", verb: "mieć" },
    array: { unit: "elementów", verb: "mieć" },
    set: { unit: "elementów", verb: "mieć" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const i = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "liczba";
      case "object": {
        if (Array.isArray(n))
          return "tablica";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, r = {
    regex: "wyrażenie",
    email: "adres email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i godzina w formacie ISO",
    date: "data w formacie ISO",
    time: "godzina w formacie ISO",
    duration: "czas trwania ISO",
    ipv4: "adres IPv4",
    ipv6: "adres IPv6",
    cidrv4: "zakres IPv4",
    cidrv6: "zakres IPv6",
    base64: "ciąg znaków zakodowany w formacie base64",
    base64url: "ciąg znaków zakodowany w formacie base64url",
    json_string: "ciąg znaków w formacie JSON",
    e164: "liczba E.164",
    jwt: "JWT",
    template_literal: "wejście"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Nieprawidłowe dane wejściowe: oczekiwano ${n.expected}, otrzymano ${i(n.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `Nieprawidłowe dane wejściowe: oczekiwano ${h(n.values[0])}` : `Nieprawidłowa opcja: oczekiwano jednej z wartości ${g(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `Za duża wartość: oczekiwano, że ${n.origin ?? "wartość"} będzie mieć ${o}${n.maximum.toString()} ${a.unit ?? "elementów"}` : `Zbyt duż(y/a/e): oczekiwano, że ${n.origin ?? "wartość"} będzie wynosić ${o}${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `Za mała wartość: oczekiwano, że ${n.origin ?? "wartość"} będzie mieć ${o}${n.minimum.toString()} ${a.unit ?? "elementów"}` : `Zbyt mał(y/a/e): oczekiwano, że ${n.origin ?? "wartość"} będzie wynosić ${o}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `Nieprawidłowy ciąg znaków: musi zaczynać się od "${o.prefix}"` : o.format === "ends_with" ? `Nieprawidłowy ciąg znaków: musi kończyć się na "${o.suffix}"` : o.format === "includes" ? `Nieprawidłowy ciąg znaków: musi zawierać "${o.includes}"` : o.format === "regex" ? `Nieprawidłowy ciąg znaków: musi odpowiadać wzorcowi ${o.pattern}` : `Nieprawidłow(y/a/e) ${r[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Nieprawidłowa liczba: musi być wielokrotnością ${n.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${n.keys.length > 1 ? "s" : ""}: ${g(n.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawidłowy klucz w ${n.origin}`;
      case "invalid_union":
        return "Nieprawidłowe dane wejściowe";
      case "invalid_element":
        return `Nieprawidłowa wartość w ${n.origin}`;
      default:
        return "Nieprawidłowe dane wejściowe";
    }
  };
};
function Zm() {
  return {
    localeError: Pm()
  };
}
const Dm = () => {
  const e = {
    string: { unit: "caracteres", verb: "ter" },
    file: { unit: "bytes", verb: "ter" },
    array: { unit: "itens", verb: "ter" },
    set: { unit: "itens", verb: "ter" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const i = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "número";
      case "object": {
        if (Array.isArray(n))
          return "array";
        if (n === null)
          return "nulo";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, r = {
    regex: "padrão",
    email: "endereço de e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "duração ISO",
    ipv4: "endereço IPv4",
    ipv6: "endereço IPv6",
    cidrv4: "faixa de IPv4",
    cidrv6: "faixa de IPv6",
    base64: "texto codificado em base64",
    base64url: "URL codificada em base64",
    json_string: "texto JSON",
    e164: "número E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Tipo inválido: esperado ${n.expected}, recebido ${i(n.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `Entrada inválida: esperado ${h(n.values[0])}` : `Opção inválida: esperada uma das ${g(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `Muito grande: esperado que ${n.origin ?? "valor"} tivesse ${o}${n.maximum.toString()} ${a.unit ?? "elementos"}` : `Muito grande: esperado que ${n.origin ?? "valor"} fosse ${o}${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `Muito pequeno: esperado que ${n.origin} tivesse ${o}${n.minimum.toString()} ${a.unit}` : `Muito pequeno: esperado que ${n.origin} fosse ${o}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `Texto inválido: deve começar com "${o.prefix}"` : o.format === "ends_with" ? `Texto inválido: deve terminar com "${o.suffix}"` : o.format === "includes" ? `Texto inválido: deve incluir "${o.includes}"` : o.format === "regex" ? `Texto inválido: deve corresponder ao padrão ${o.pattern}` : `${r[o.format] ?? n.format} inválido`;
      }
      case "not_multiple_of":
        return `Número inválido: deve ser múltiplo de ${n.divisor}`;
      case "unrecognized_keys":
        return `Chave${n.keys.length > 1 ? "s" : ""} desconhecida${n.keys.length > 1 ? "s" : ""}: ${g(n.keys, ", ")}`;
      case "invalid_key":
        return `Chave inválida em ${n.origin}`;
      case "invalid_union":
        return "Entrada inválida";
      case "invalid_element":
        return `Valor inválido em ${n.origin}`;
      default:
        return "Campo inválido";
    }
  };
};
function Tm() {
  return {
    localeError: Dm()
  };
}
function so(e, t, i, r) {
  const n = Math.abs(e), o = n % 10, a = n % 100;
  return a >= 11 && a <= 19 ? r : o === 1 ? t : o >= 2 && o <= 4 ? i : r;
}
const Em = () => {
  const e = {
    string: {
      unit: {
        one: "символ",
        few: "символа",
        many: "символов"
      },
      verb: "иметь"
    },
    file: {
      unit: {
        one: "байт",
        few: "байта",
        many: "байт"
      },
      verb: "иметь"
    },
    array: {
      unit: {
        one: "элемент",
        few: "элемента",
        many: "элементов"
      },
      verb: "иметь"
    },
    set: {
      unit: {
        one: "элемент",
        few: "элемента",
        many: "элементов"
      },
      verb: "иметь"
    }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const i = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "число";
      case "object": {
        if (Array.isArray(n))
          return "массив";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, r = {
    regex: "ввод",
    email: "email адрес",
    url: "URL",
    emoji: "эмодзи",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO дата и время",
    date: "ISO дата",
    time: "ISO время",
    duration: "ISO длительность",
    ipv4: "IPv4 адрес",
    ipv6: "IPv6 адрес",
    cidrv4: "IPv4 диапазон",
    cidrv6: "IPv6 диапазон",
    base64: "строка в формате base64",
    base64url: "строка в формате base64url",
    json_string: "JSON строка",
    e164: "номер E.164",
    jwt: "JWT",
    template_literal: "ввод"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Неверный ввод: ожидалось ${n.expected}, получено ${i(n.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `Неверный ввод: ожидалось ${h(n.values[0])}` : `Неверный вариант: ожидалось одно из ${g(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", a = t(n.origin);
        if (a) {
          const u = Number(n.maximum), l = so(u, a.unit.one, a.unit.few, a.unit.many);
          return `Слишком большое значение: ожидалось, что ${n.origin ?? "значение"} будет иметь ${o}${n.maximum.toString()} ${l}`;
        }
        return `Слишком большое значение: ожидалось, что ${n.origin ?? "значение"} будет ${o}${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", a = t(n.origin);
        if (a) {
          const u = Number(n.minimum), l = so(u, a.unit.one, a.unit.few, a.unit.many);
          return `Слишком маленькое значение: ожидалось, что ${n.origin} будет иметь ${o}${n.minimum.toString()} ${l}`;
        }
        return `Слишком маленькое значение: ожидалось, что ${n.origin} будет ${o}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `Неверная строка: должна начинаться с "${o.prefix}"` : o.format === "ends_with" ? `Неверная строка: должна заканчиваться на "${o.suffix}"` : o.format === "includes" ? `Неверная строка: должна содержать "${o.includes}"` : o.format === "regex" ? `Неверная строка: должна соответствовать шаблону ${o.pattern}` : `Неверный ${r[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Неверное число: должно быть кратным ${n.divisor}`;
      case "unrecognized_keys":
        return `Нераспознанн${n.keys.length > 1 ? "ые" : "ый"} ключ${n.keys.length > 1 ? "и" : ""}: ${g(n.keys, ", ")}`;
      case "invalid_key":
        return `Неверный ключ в ${n.origin}`;
      case "invalid_union":
        return "Неверные входные данные";
      case "invalid_element":
        return `Неверное значение в ${n.origin}`;
      default:
        return "Неверные входные данные";
    }
  };
};
function Am() {
  return {
    localeError: Em()
  };
}
const Lm = () => {
  const e = {
    string: { unit: "znakov", verb: "imeti" },
    file: { unit: "bajtov", verb: "imeti" },
    array: { unit: "elementov", verb: "imeti" },
    set: { unit: "elementov", verb: "imeti" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const i = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "število";
      case "object": {
        if (Array.isArray(n))
          return "tabela";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, r = {
    regex: "vnos",
    email: "e-poštni naslov",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum in čas",
    date: "ISO datum",
    time: "ISO čas",
    duration: "ISO trajanje",
    ipv4: "IPv4 naslov",
    ipv6: "IPv6 naslov",
    cidrv4: "obseg IPv4",
    cidrv6: "obseg IPv6",
    base64: "base64 kodiran niz",
    base64url: "base64url kodiran niz",
    json_string: "JSON niz",
    e164: "E.164 številka",
    jwt: "JWT",
    template_literal: "vnos"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Neveljaven vnos: pričakovano ${n.expected}, prejeto ${i(n.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `Neveljaven vnos: pričakovano ${h(n.values[0])}` : `Neveljavna možnost: pričakovano eno izmed ${g(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `Preveliko: pričakovano, da bo ${n.origin ?? "vrednost"} imelo ${o}${n.maximum.toString()} ${a.unit ?? "elementov"}` : `Preveliko: pričakovano, da bo ${n.origin ?? "vrednost"} ${o}${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `Premajhno: pričakovano, da bo ${n.origin} imelo ${o}${n.minimum.toString()} ${a.unit}` : `Premajhno: pričakovano, da bo ${n.origin} ${o}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `Neveljaven niz: mora se začeti z "${o.prefix}"` : o.format === "ends_with" ? `Neveljaven niz: mora se končati z "${o.suffix}"` : o.format === "includes" ? `Neveljaven niz: mora vsebovati "${o.includes}"` : o.format === "regex" ? `Neveljaven niz: mora ustrezati vzorcu ${o.pattern}` : `Neveljaven ${r[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno število: mora biti večkratnik ${n.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${n.keys.length > 1 ? "i ključi" : " ključ"}: ${g(n.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven ključ v ${n.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${n.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
};
function Rm() {
  return {
    localeError: Lm()
  };
}
const Cm = () => {
  const e = {
    string: { unit: "tecken", verb: "att ha" },
    file: { unit: "bytes", verb: "att ha" },
    array: { unit: "objekt", verb: "att innehålla" },
    set: { unit: "objekt", verb: "att innehålla" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const i = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "antal";
      case "object": {
        if (Array.isArray(n))
          return "lista";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, r = {
    regex: "reguljärt uttryck",
    email: "e-postadress",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datum och tid",
    date: "ISO-datum",
    time: "ISO-tid",
    duration: "ISO-varaktighet",
    ipv4: "IPv4-intervall",
    ipv6: "IPv6-intervall",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodad sträng",
    base64url: "base64url-kodad sträng",
    json_string: "JSON-sträng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "mall-literal"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Ogiltig inmatning: förväntat ${n.expected}, fick ${i(n.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `Ogiltig inmatning: förväntat ${h(n.values[0])}` : `Ogiltigt val: förväntade en av ${g(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `För stor(t): förväntade ${n.origin ?? "värdet"} att ha ${o}${n.maximum.toString()} ${a.unit ?? "element"}` : `För stor(t): förväntat ${n.origin ?? "värdet"} att ha ${o}${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `För lite(t): förväntade ${n.origin ?? "värdet"} att ha ${o}${n.minimum.toString()} ${a.unit}` : `För lite(t): förväntade ${n.origin ?? "värdet"} att ha ${o}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `Ogiltig sträng: måste börja med "${o.prefix}"` : o.format === "ends_with" ? `Ogiltig sträng: måste sluta med "${o.suffix}"` : o.format === "includes" ? `Ogiltig sträng: måste innehålla "${o.includes}"` : o.format === "regex" ? `Ogiltig sträng: måste matcha mönstret "${o.pattern}"` : `Ogiltig(t) ${r[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: måste vara en multipel av ${n.divisor}`;
      case "unrecognized_keys":
        return `${n.keys.length > 1 ? "Okända nycklar" : "Okänd nyckel"}: ${g(n.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${n.origin ?? "värdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt värde i ${n.origin ?? "värdet"}`;
      default:
        return "Ogiltig input";
    }
  };
};
function Jm() {
  return {
    localeError: Cm()
  };
}
const Fm = () => {
  const e = {
    string: { unit: "எழுத்துக்கள்", verb: "கொண்டிருக்க வேண்டும்" },
    file: { unit: "பைட்டுகள்", verb: "கொண்டிருக்க வேண்டும்" },
    array: { unit: "உறுப்புகள்", verb: "கொண்டிருக்க வேண்டும்" },
    set: { unit: "உறுப்புகள்", verb: "கொண்டிருக்க வேண்டும்" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const i = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "எண் அல்லாதது" : "எண்";
      case "object": {
        if (Array.isArray(n))
          return "அணி";
        if (n === null)
          return "வெறுமை";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, r = {
    regex: "உள்ளீடு",
    email: "மின்னஞ்சல் முகவரி",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO தேதி நேரம்",
    date: "ISO தேதி",
    time: "ISO நேரம்",
    duration: "ISO கால அளவு",
    ipv4: "IPv4 முகவரி",
    ipv6: "IPv6 முகவரி",
    cidrv4: "IPv4 வரம்பு",
    cidrv6: "IPv6 வரம்பு",
    base64: "base64-encoded சரம்",
    base64url: "base64url-encoded சரம்",
    json_string: "JSON சரம்",
    e164: "E.164 எண்",
    jwt: "JWT",
    template_literal: "input"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `தவறான உள்ளீடு: எதிர்பார்க்கப்பட்டது ${n.expected}, பெறப்பட்டது ${i(n.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `தவறான உள்ளீடு: எதிர்பார்க்கப்பட்டது ${h(n.values[0])}` : `தவறான விருப்பம்: எதிர்பார்க்கப்பட்டது ${g(n.values, "|")} இல் ஒன்று`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `மிக பெரியது: எதிர்பார்க்கப்பட்டது ${n.origin ?? "மதிப்பு"} ${o}${n.maximum.toString()} ${a.unit ?? "உறுப்புகள்"} ஆக இருக்க வேண்டும்` : `மிக பெரியது: எதிர்பார்க்கப்பட்டது ${n.origin ?? "மதிப்பு"} ${o}${n.maximum.toString()} ஆக இருக்க வேண்டும்`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `மிகச் சிறியது: எதிர்பார்க்கப்பட்டது ${n.origin} ${o}${n.minimum.toString()} ${a.unit} ஆக இருக்க வேண்டும்` : `மிகச் சிறியது: எதிர்பார்க்கப்பட்டது ${n.origin} ${o}${n.minimum.toString()} ஆக இருக்க வேண்டும்`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `தவறான சரம்: "${o.prefix}" இல் தொடங்க வேண்டும்` : o.format === "ends_with" ? `தவறான சரம்: "${o.suffix}" இல் முடிவடைய வேண்டும்` : o.format === "includes" ? `தவறான சரம்: "${o.includes}" ஐ உள்ளடக்க வேண்டும்` : o.format === "regex" ? `தவறான சரம்: ${o.pattern} முறைபாட்டுடன் பொருந்த வேண்டும்` : `தவறான ${r[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `தவறான எண்: ${n.divisor} இன் பலமாக இருக்க வேண்டும்`;
      case "unrecognized_keys":
        return `அடையாளம் தெரியாத விசை${n.keys.length > 1 ? "கள்" : ""}: ${g(n.keys, ", ")}`;
      case "invalid_key":
        return `${n.origin} இல் தவறான விசை`;
      case "invalid_union":
        return "தவறான உள்ளீடு";
      case "invalid_element":
        return `${n.origin} இல் தவறான மதிப்பு`;
      default:
        return "தவறான உள்ளீடு";
    }
  };
};
function Mm() {
  return {
    localeError: Fm()
  };
}
const Gm = () => {
  const e = {
    string: { unit: "ตัวอักษร", verb: "ควรมี" },
    file: { unit: "ไบต์", verb: "ควรมี" },
    array: { unit: "รายการ", verb: "ควรมี" },
    set: { unit: "รายการ", verb: "ควรมี" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const i = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "ไม่ใช่ตัวเลข (NaN)" : "ตัวเลข";
      case "object": {
        if (Array.isArray(n))
          return "อาร์เรย์ (Array)";
        if (n === null)
          return "ไม่มีค่า (null)";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, r = {
    regex: "ข้อมูลที่ป้อน",
    email: "ที่อยู่อีเมล",
    url: "URL",
    emoji: "อิโมจิ",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "วันที่เวลาแบบ ISO",
    date: "วันที่แบบ ISO",
    time: "เวลาแบบ ISO",
    duration: "ช่วงเวลาแบบ ISO",
    ipv4: "ที่อยู่ IPv4",
    ipv6: "ที่อยู่ IPv6",
    cidrv4: "ช่วง IP แบบ IPv4",
    cidrv6: "ช่วง IP แบบ IPv6",
    base64: "ข้อความแบบ Base64",
    base64url: "ข้อความแบบ Base64 สำหรับ URL",
    json_string: "ข้อความแบบ JSON",
    e164: "เบอร์โทรศัพท์ระหว่างประเทศ (E.164)",
    jwt: "โทเคน JWT",
    template_literal: "ข้อมูลที่ป้อน"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `ประเภทข้อมูลไม่ถูกต้อง: ควรเป็น ${n.expected} แต่ได้รับ ${i(n.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `ค่าไม่ถูกต้อง: ควรเป็น ${h(n.values[0])}` : `ตัวเลือกไม่ถูกต้อง: ควรเป็นหนึ่งใน ${g(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "ไม่เกิน" : "น้อยกว่า", a = t(n.origin);
        return a ? `เกินกำหนด: ${n.origin ?? "ค่า"} ควรมี${o} ${n.maximum.toString()} ${a.unit ?? "รายการ"}` : `เกินกำหนด: ${n.origin ?? "ค่า"} ควรมี${o} ${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? "อย่างน้อย" : "มากกว่า", a = t(n.origin);
        return a ? `น้อยกว่ากำหนด: ${n.origin} ควรมี${o} ${n.minimum.toString()} ${a.unit}` : `น้อยกว่ากำหนด: ${n.origin} ควรมี${o} ${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `รูปแบบไม่ถูกต้อง: ข้อความต้องขึ้นต้นด้วย "${o.prefix}"` : o.format === "ends_with" ? `รูปแบบไม่ถูกต้อง: ข้อความต้องลงท้ายด้วย "${o.suffix}"` : o.format === "includes" ? `รูปแบบไม่ถูกต้อง: ข้อความต้องมี "${o.includes}" อยู่ในข้อความ` : o.format === "regex" ? `รูปแบบไม่ถูกต้อง: ต้องตรงกับรูปแบบที่กำหนด ${o.pattern}` : `รูปแบบไม่ถูกต้อง: ${r[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `ตัวเลขไม่ถูกต้อง: ต้องเป็นจำนวนที่หารด้วย ${n.divisor} ได้ลงตัว`;
      case "unrecognized_keys":
        return `พบคีย์ที่ไม่รู้จัก: ${g(n.keys, ", ")}`;
      case "invalid_key":
        return `คีย์ไม่ถูกต้องใน ${n.origin}`;
      case "invalid_union":
        return "ข้อมูลไม่ถูกต้อง: ไม่ตรงกับรูปแบบยูเนียนที่กำหนดไว้";
      case "invalid_element":
        return `ข้อมูลไม่ถูกต้องใน ${n.origin}`;
      default:
        return "ข้อมูลไม่ถูกต้อง";
    }
  };
};
function Vm() {
  return {
    localeError: Gm()
  };
}
const Km = (e) => {
  const t = typeof e;
  switch (t) {
    case "number":
      return Number.isNaN(e) ? "NaN" : "number";
    case "object": {
      if (Array.isArray(e))
        return "array";
      if (e === null)
        return "null";
      if (Object.getPrototypeOf(e) !== Object.prototype && e.constructor)
        return e.constructor.name;
    }
  }
  return t;
}, Wm = () => {
  const e = {
    string: { unit: "karakter", verb: "olmalı" },
    file: { unit: "bayt", verb: "olmalı" },
    array: { unit: "öğe", verb: "olmalı" },
    set: { unit: "öğe", verb: "olmalı" }
  };
  function t(r) {
    return e[r] ?? null;
  }
  const i = {
    regex: "girdi",
    email: "e-posta adresi",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO tarih ve saat",
    date: "ISO tarih",
    time: "ISO saat",
    duration: "ISO süre",
    ipv4: "IPv4 adresi",
    ipv6: "IPv6 adresi",
    cidrv4: "IPv4 aralığı",
    cidrv6: "IPv6 aralığı",
    base64: "base64 ile şifrelenmiş metin",
    base64url: "base64url ile şifrelenmiş metin",
    json_string: "JSON dizesi",
    e164: "E.164 sayısı",
    jwt: "JWT",
    template_literal: "Şablon dizesi"
  };
  return (r) => {
    switch (r.code) {
      case "invalid_type":
        return `Geçersiz değer: beklenen ${r.expected}, alınan ${Km(r.input)}`;
      case "invalid_value":
        return r.values.length === 1 ? `Geçersiz değer: beklenen ${h(r.values[0])}` : `Geçersiz seçenek: aşağıdakilerden biri olmalı: ${g(r.values, "|")}`;
      case "too_big": {
        const n = r.inclusive ? "<=" : "<", o = t(r.origin);
        return o ? `Çok büyük: beklenen ${r.origin ?? "değer"} ${n}${r.maximum.toString()} ${o.unit ?? "öğe"}` : `Çok büyük: beklenen ${r.origin ?? "değer"} ${n}${r.maximum.toString()}`;
      }
      case "too_small": {
        const n = r.inclusive ? ">=" : ">", o = t(r.origin);
        return o ? `Çok küçük: beklenen ${r.origin} ${n}${r.minimum.toString()} ${o.unit}` : `Çok küçük: beklenen ${r.origin} ${n}${r.minimum.toString()}`;
      }
      case "invalid_format": {
        const n = r;
        return n.format === "starts_with" ? `Geçersiz metin: "${n.prefix}" ile başlamalı` : n.format === "ends_with" ? `Geçersiz metin: "${n.suffix}" ile bitmeli` : n.format === "includes" ? `Geçersiz metin: "${n.includes}" içermeli` : n.format === "regex" ? `Geçersiz metin: ${n.pattern} desenine uymalı` : `Geçersiz ${i[n.format] ?? r.format}`;
      }
      case "not_multiple_of":
        return `Geçersiz sayı: ${r.divisor} ile tam bölünebilmeli`;
      case "unrecognized_keys":
        return `Tanınmayan anahtar${r.keys.length > 1 ? "lar" : ""}: ${g(r.keys, ", ")}`;
      case "invalid_key":
        return `${r.origin} içinde geçersiz anahtar`;
      case "invalid_union":
        return "Geçersiz değer";
      case "invalid_element":
        return `${r.origin} içinde geçersiz değer`;
      default:
        return "Geçersiz değer";
    }
  };
};
function Bm() {
  return {
    localeError: Wm()
  };
}
const Xm = () => {
  const e = {
    string: { unit: "символів", verb: "матиме" },
    file: { unit: "байтів", verb: "матиме" },
    array: { unit: "елементів", verb: "матиме" },
    set: { unit: "елементів", verb: "матиме" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const i = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "число";
      case "object": {
        if (Array.isArray(n))
          return "масив";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, r = {
    regex: "вхідні дані",
    email: "адреса електронної пошти",
    url: "URL",
    emoji: "емодзі",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "дата та час ISO",
    date: "дата ISO",
    time: "час ISO",
    duration: "тривалість ISO",
    ipv4: "адреса IPv4",
    ipv6: "адреса IPv6",
    cidrv4: "діапазон IPv4",
    cidrv6: "діапазон IPv6",
    base64: "рядок у кодуванні base64",
    base64url: "рядок у кодуванні base64url",
    json_string: "рядок JSON",
    e164: "номер E.164",
    jwt: "JWT",
    template_literal: "вхідні дані"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Неправильні вхідні дані: очікується ${n.expected}, отримано ${i(n.input)}`;
      // return `Неправильні вхідні дані: очікується ${issue.expected}, отримано ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `Неправильні вхідні дані: очікується ${h(n.values[0])}` : `Неправильна опція: очікується одне з ${g(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `Занадто велике: очікується, що ${n.origin ?? "значення"} ${a.verb} ${o}${n.maximum.toString()} ${a.unit ?? "елементів"}` : `Занадто велике: очікується, що ${n.origin ?? "значення"} буде ${o}${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `Занадто мале: очікується, що ${n.origin} ${a.verb} ${o}${n.minimum.toString()} ${a.unit}` : `Занадто мале: очікується, що ${n.origin} буде ${o}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `Неправильний рядок: повинен починатися з "${o.prefix}"` : o.format === "ends_with" ? `Неправильний рядок: повинен закінчуватися на "${o.suffix}"` : o.format === "includes" ? `Неправильний рядок: повинен містити "${o.includes}"` : o.format === "regex" ? `Неправильний рядок: повинен відповідати шаблону ${o.pattern}` : `Неправильний ${r[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Неправильне число: повинно бути кратним ${n.divisor}`;
      case "unrecognized_keys":
        return `Нерозпізнаний ключ${n.keys.length > 1 ? "і" : ""}: ${g(n.keys, ", ")}`;
      case "invalid_key":
        return `Неправильний ключ у ${n.origin}`;
      case "invalid_union":
        return "Неправильні вхідні дані";
      case "invalid_element":
        return `Неправильне значення у ${n.origin}`;
      default:
        return "Неправильні вхідні дані";
    }
  };
};
function Yu() {
  return {
    localeError: Xm()
  };
}
function qm() {
  return Yu();
}
const Ym = () => {
  const e = {
    string: { unit: "حروف", verb: "ہونا" },
    file: { unit: "بائٹس", verb: "ہونا" },
    array: { unit: "آئٹمز", verb: "ہونا" },
    set: { unit: "آئٹمز", verb: "ہونا" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const i = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "نمبر";
      case "object": {
        if (Array.isArray(n))
          return "آرے";
        if (n === null)
          return "نل";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, r = {
    regex: "ان پٹ",
    email: "ای میل ایڈریس",
    url: "یو آر ایل",
    emoji: "ایموجی",
    uuid: "یو یو آئی ڈی",
    uuidv4: "یو یو آئی ڈی وی 4",
    uuidv6: "یو یو آئی ڈی وی 6",
    nanoid: "نینو آئی ڈی",
    guid: "جی یو آئی ڈی",
    cuid: "سی یو آئی ڈی",
    cuid2: "سی یو آئی ڈی 2",
    ulid: "یو ایل آئی ڈی",
    xid: "ایکس آئی ڈی",
    ksuid: "کے ایس یو آئی ڈی",
    datetime: "آئی ایس او ڈیٹ ٹائم",
    date: "آئی ایس او تاریخ",
    time: "آئی ایس او وقت",
    duration: "آئی ایس او مدت",
    ipv4: "آئی پی وی 4 ایڈریس",
    ipv6: "آئی پی وی 6 ایڈریس",
    cidrv4: "آئی پی وی 4 رینج",
    cidrv6: "آئی پی وی 6 رینج",
    base64: "بیس 64 ان کوڈڈ سٹرنگ",
    base64url: "بیس 64 یو آر ایل ان کوڈڈ سٹرنگ",
    json_string: "جے ایس او این سٹرنگ",
    e164: "ای 164 نمبر",
    jwt: "جے ڈبلیو ٹی",
    template_literal: "ان پٹ"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `غلط ان پٹ: ${n.expected} متوقع تھا، ${i(n.input)} موصول ہوا`;
      case "invalid_value":
        return n.values.length === 1 ? `غلط ان پٹ: ${h(n.values[0])} متوقع تھا` : `غلط آپشن: ${g(n.values, "|")} میں سے ایک متوقع تھا`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `بہت بڑا: ${n.origin ?? "ویلیو"} کے ${o}${n.maximum.toString()} ${a.unit ?? "عناصر"} ہونے متوقع تھے` : `بہت بڑا: ${n.origin ?? "ویلیو"} کا ${o}${n.maximum.toString()} ہونا متوقع تھا`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `بہت چھوٹا: ${n.origin} کے ${o}${n.minimum.toString()} ${a.unit} ہونے متوقع تھے` : `بہت چھوٹا: ${n.origin} کا ${o}${n.minimum.toString()} ہونا متوقع تھا`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `غلط سٹرنگ: "${o.prefix}" سے شروع ہونا چاہیے` : o.format === "ends_with" ? `غلط سٹرنگ: "${o.suffix}" پر ختم ہونا چاہیے` : o.format === "includes" ? `غلط سٹرنگ: "${o.includes}" شامل ہونا چاہیے` : o.format === "regex" ? `غلط سٹرنگ: پیٹرن ${o.pattern} سے میچ ہونا چاہیے` : `غلط ${r[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `غلط نمبر: ${n.divisor} کا مضاعف ہونا چاہیے`;
      case "unrecognized_keys":
        return `غیر تسلیم شدہ کی${n.keys.length > 1 ? "ز" : ""}: ${g(n.keys, "، ")}`;
      case "invalid_key":
        return `${n.origin} میں غلط کی`;
      case "invalid_union":
        return "غلط ان پٹ";
      case "invalid_element":
        return `${n.origin} میں غلط ویلیو`;
      default:
        return "غلط ان پٹ";
    }
  };
};
function Hm() {
  return {
    localeError: Ym()
  };
}
const Qm = () => {
  const e = {
    string: { unit: "ký tự", verb: "có" },
    file: { unit: "byte", verb: "có" },
    array: { unit: "phần tử", verb: "có" },
    set: { unit: "phần tử", verb: "có" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const i = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "số";
      case "object": {
        if (Array.isArray(n))
          return "mảng";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, r = {
    regex: "đầu vào",
    email: "địa chỉ email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ngày giờ ISO",
    date: "ngày ISO",
    time: "giờ ISO",
    duration: "khoảng thời gian ISO",
    ipv4: "địa chỉ IPv4",
    ipv6: "địa chỉ IPv6",
    cidrv4: "dải IPv4",
    cidrv6: "dải IPv6",
    base64: "chuỗi mã hóa base64",
    base64url: "chuỗi mã hóa base64url",
    json_string: "chuỗi JSON",
    e164: "số E.164",
    jwt: "JWT",
    template_literal: "đầu vào"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Đầu vào không hợp lệ: mong đợi ${n.expected}, nhận được ${i(n.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `Đầu vào không hợp lệ: mong đợi ${h(n.values[0])}` : `Tùy chọn không hợp lệ: mong đợi một trong các giá trị ${g(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `Quá lớn: mong đợi ${n.origin ?? "giá trị"} ${a.verb} ${o}${n.maximum.toString()} ${a.unit ?? "phần tử"}` : `Quá lớn: mong đợi ${n.origin ?? "giá trị"} ${o}${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `Quá nhỏ: mong đợi ${n.origin} ${a.verb} ${o}${n.minimum.toString()} ${a.unit}` : `Quá nhỏ: mong đợi ${n.origin} ${o}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `Chuỗi không hợp lệ: phải bắt đầu bằng "${o.prefix}"` : o.format === "ends_with" ? `Chuỗi không hợp lệ: phải kết thúc bằng "${o.suffix}"` : o.format === "includes" ? `Chuỗi không hợp lệ: phải bao gồm "${o.includes}"` : o.format === "regex" ? `Chuỗi không hợp lệ: phải khớp với mẫu ${o.pattern}` : `${r[o.format] ?? n.format} không hợp lệ`;
      }
      case "not_multiple_of":
        return `Số không hợp lệ: phải là bội số của ${n.divisor}`;
      case "unrecognized_keys":
        return `Khóa không được nhận dạng: ${g(n.keys, ", ")}`;
      case "invalid_key":
        return `Khóa không hợp lệ trong ${n.origin}`;
      case "invalid_union":
        return "Đầu vào không hợp lệ";
      case "invalid_element":
        return `Giá trị không hợp lệ trong ${n.origin}`;
      default:
        return "Đầu vào không hợp lệ";
    }
  };
};
function ef() {
  return {
    localeError: Qm()
  };
}
const nf = () => {
  const e = {
    string: { unit: "字符", verb: "包含" },
    file: { unit: "字节", verb: "包含" },
    array: { unit: "项", verb: "包含" },
    set: { unit: "项", verb: "包含" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const i = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "非数字(NaN)" : "数字";
      case "object": {
        if (Array.isArray(n))
          return "数组";
        if (n === null)
          return "空值(null)";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, r = {
    regex: "输入",
    email: "电子邮件",
    url: "URL",
    emoji: "表情符号",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO日期时间",
    date: "ISO日期",
    time: "ISO时间",
    duration: "ISO时长",
    ipv4: "IPv4地址",
    ipv6: "IPv6地址",
    cidrv4: "IPv4网段",
    cidrv6: "IPv6网段",
    base64: "base64编码字符串",
    base64url: "base64url编码字符串",
    json_string: "JSON字符串",
    e164: "E.164号码",
    jwt: "JWT",
    template_literal: "输入"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `无效输入：期望 ${n.expected}，实际接收 ${i(n.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `无效输入：期望 ${h(n.values[0])}` : `无效选项：期望以下之一 ${g(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `数值过大：期望 ${n.origin ?? "值"} ${o}${n.maximum.toString()} ${a.unit ?? "个元素"}` : `数值过大：期望 ${n.origin ?? "值"} ${o}${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `数值过小：期望 ${n.origin} ${o}${n.minimum.toString()} ${a.unit}` : `数值过小：期望 ${n.origin} ${o}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `无效字符串：必须以 "${o.prefix}" 开头` : o.format === "ends_with" ? `无效字符串：必须以 "${o.suffix}" 结尾` : o.format === "includes" ? `无效字符串：必须包含 "${o.includes}"` : o.format === "regex" ? `无效字符串：必须满足正则表达式 ${o.pattern}` : `无效${r[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `无效数字：必须是 ${n.divisor} 的倍数`;
      case "unrecognized_keys":
        return `出现未知的键(key): ${g(n.keys, ", ")}`;
      case "invalid_key":
        return `${n.origin} 中的键(key)无效`;
      case "invalid_union":
        return "无效输入";
      case "invalid_element":
        return `${n.origin} 中包含无效值(value)`;
      default:
        return "无效输入";
    }
  };
};
function tf() {
  return {
    localeError: nf()
  };
}
const rf = () => {
  const e = {
    string: { unit: "字元", verb: "擁有" },
    file: { unit: "位元組", verb: "擁有" },
    array: { unit: "項目", verb: "擁有" },
    set: { unit: "項目", verb: "擁有" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const i = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(n))
          return "array";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, r = {
    regex: "輸入",
    email: "郵件地址",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO 日期時間",
    date: "ISO 日期",
    time: "ISO 時間",
    duration: "ISO 期間",
    ipv4: "IPv4 位址",
    ipv6: "IPv6 位址",
    cidrv4: "IPv4 範圍",
    cidrv6: "IPv6 範圍",
    base64: "base64 編碼字串",
    base64url: "base64url 編碼字串",
    json_string: "JSON 字串",
    e164: "E.164 數值",
    jwt: "JWT",
    template_literal: "輸入"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `無效的輸入值：預期為 ${n.expected}，但收到 ${i(n.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `無效的輸入值：預期為 ${h(n.values[0])}` : `無效的選項：預期為以下其中之一 ${g(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `數值過大：預期 ${n.origin ?? "值"} 應為 ${o}${n.maximum.toString()} ${a.unit ?? "個元素"}` : `數值過大：預期 ${n.origin ?? "值"} 應為 ${o}${n.maximum.toString()}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `數值過小：預期 ${n.origin} 應為 ${o}${n.minimum.toString()} ${a.unit}` : `數值過小：預期 ${n.origin} 應為 ${o}${n.minimum.toString()}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `無效的字串：必須以 "${o.prefix}" 開頭` : o.format === "ends_with" ? `無效的字串：必須以 "${o.suffix}" 結尾` : o.format === "includes" ? `無效的字串：必須包含 "${o.includes}"` : o.format === "regex" ? `無效的字串：必須符合格式 ${o.pattern}` : `無效的 ${r[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `無效的數字：必須為 ${n.divisor} 的倍數`;
      case "unrecognized_keys":
        return `無法識別的鍵值${n.keys.length > 1 ? "們" : ""}：${g(n.keys, "、")}`;
      case "invalid_key":
        return `${n.origin} 中有無效的鍵值`;
      case "invalid_union":
        return "無效的輸入值";
      case "invalid_element":
        return `${n.origin} 中有無效的值`;
      default:
        return "無效的輸入值";
    }
  };
};
function of() {
  return {
    localeError: rf()
  };
}
const af = () => {
  const e = {
    string: { unit: "àmi", verb: "ní" },
    file: { unit: "bytes", verb: "ní" },
    array: { unit: "nkan", verb: "ní" },
    set: { unit: "nkan", verb: "ní" }
  };
  function t(n) {
    return e[n] ?? null;
  }
  const i = (n) => {
    const o = typeof n;
    switch (o) {
      case "number":
        return Number.isNaN(n) ? "NaN" : "nọ́mbà";
      case "object": {
        if (Array.isArray(n))
          return "akopọ";
        if (n === null)
          return "null";
        if (Object.getPrototypeOf(n) !== Object.prototype && n.constructor)
          return n.constructor.name;
      }
    }
    return o;
  }, r = {
    regex: "ẹ̀rọ ìbáwọlé",
    email: "àdírẹ́sì ìmẹ́lì",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "àkókò ISO",
    date: "ọjọ́ ISO",
    time: "àkókò ISO",
    duration: "àkókò tó pé ISO",
    ipv4: "àdírẹ́sì IPv4",
    ipv6: "àdírẹ́sì IPv6",
    cidrv4: "àgbègbè IPv4",
    cidrv6: "àgbègbè IPv6",
    base64: "ọ̀rọ̀ tí a kọ́ ní base64",
    base64url: "ọ̀rọ̀ base64url",
    json_string: "ọ̀rọ̀ JSON",
    e164: "nọ́mbà E.164",
    jwt: "JWT",
    template_literal: "ẹ̀rọ ìbáwọlé"
  };
  return (n) => {
    switch (n.code) {
      case "invalid_type":
        return `Ìbáwọlé aṣìṣe: a ní láti fi ${n.expected}, àmọ̀ a rí ${i(n.input)}`;
      case "invalid_value":
        return n.values.length === 1 ? `Ìbáwọlé aṣìṣe: a ní láti fi ${h(n.values[0])}` : `Àṣàyàn aṣìṣe: yan ọ̀kan lára ${g(n.values, "|")}`;
      case "too_big": {
        const o = n.inclusive ? "<=" : "<", a = t(n.origin);
        return a ? `Tó pọ̀ jù: a ní láti jẹ́ pé ${n.origin ?? "iye"} ${a.verb} ${o}${n.maximum} ${a.unit}` : `Tó pọ̀ jù: a ní láti jẹ́ ${o}${n.maximum}`;
      }
      case "too_small": {
        const o = n.inclusive ? ">=" : ">", a = t(n.origin);
        return a ? `Kéré ju: a ní láti jẹ́ pé ${n.origin} ${a.verb} ${o}${n.minimum} ${a.unit}` : `Kéré ju: a ní láti jẹ́ ${o}${n.minimum}`;
      }
      case "invalid_format": {
        const o = n;
        return o.format === "starts_with" ? `Ọ̀rọ̀ aṣìṣe: gbọ́dọ̀ bẹ̀rẹ̀ pẹ̀lú "${o.prefix}"` : o.format === "ends_with" ? `Ọ̀rọ̀ aṣìṣe: gbọ́dọ̀ parí pẹ̀lú "${o.suffix}"` : o.format === "includes" ? `Ọ̀rọ̀ aṣìṣe: gbọ́dọ̀ ní "${o.includes}"` : o.format === "regex" ? `Ọ̀rọ̀ aṣìṣe: gbọ́dọ̀ bá àpẹẹrẹ mu ${o.pattern}` : `Aṣìṣe: ${r[o.format] ?? n.format}`;
      }
      case "not_multiple_of":
        return `Nọ́mbà aṣìṣe: gbọ́dọ̀ jẹ́ èyà pípín ti ${n.divisor}`;
      case "unrecognized_keys":
        return `Bọtìnì àìmọ̀: ${g(n.keys, ", ")}`;
      case "invalid_key":
        return `Bọtìnì aṣìṣe nínú ${n.origin}`;
      case "invalid_union":
        return "Ìbáwọlé aṣìṣe";
      case "invalid_element":
        return `Iye aṣìṣe nínú ${n.origin}`;
      default:
        return "Ìbáwọlé aṣìṣe";
    }
  };
};
function uf() {
  return {
    localeError: af()
  };
}
const Qt = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ar: _d,
  az: kd,
  be: zd,
  bg: jd,
  ca: Nd,
  cs: xd,
  da: Zd,
  de: Td,
  en: Xu,
  eo: Cd,
  es: Fd,
  fa: Gd,
  fi: Kd,
  fr: Bd,
  frCA: qd,
  he: Hd,
  hu: em,
  id: tm,
  is: om,
  it: um,
  ja: lm,
  ka: mm,
  kh: gm,
  km: qu,
  ko: vm,
  lt: bm,
  mk: ym,
  ms: Im,
  nl: Sm,
  no: jm,
  ota: Nm,
  pl: Zm,
  ps: xm,
  pt: Tm,
  ru: Am,
  sl: Rm,
  sv: Jm,
  ta: Mm,
  th: Vm,
  tr: Bm,
  ua: qm,
  uk: Yu,
  ur: Hm,
  vi: ef,
  yo: uf,
  zhCN: tf,
  zhTW: of
}, Symbol.toStringTag, { value: "Module" }));
var mo;
const er = /* @__PURE__ */ Symbol("ZodOutput"), nr = /* @__PURE__ */ Symbol("ZodInput");
class Hu {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map();
  }
  add(t, ...i) {
    const r = i[0];
    if (this._map.set(t, r), r && typeof r == "object" && "id" in r) {
      if (this._idmap.has(r.id))
        throw new Error(`ID ${r.id} already exists in the registry`);
      this._idmap.set(r.id, t);
    }
    return this;
  }
  clear() {
    return this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map(), this;
  }
  remove(t) {
    const i = this._map.get(t);
    return i && typeof i == "object" && "id" in i && this._idmap.delete(i.id), this._map.delete(t), this;
  }
  get(t) {
    const i = t._zod.parent;
    if (i) {
      const r = { ...this.get(i) ?? {} };
      delete r.id;
      const n = { ...r, ...this._map.get(t) };
      return Object.keys(n).length ? n : void 0;
    }
    return this._map.get(t);
  }
  has(t) {
    return this._map.has(t);
  }
}
function jn() {
  return new Hu();
}
(mo = globalThis).__zod_globalRegistry ?? (mo.__zod_globalRegistry = jn());
const E = globalThis.__zod_globalRegistry;
function Qu(e, t) {
  return new e({
    type: "string",
    ...m(t)
  });
}
function ec(e, t) {
  return new e({
    type: "string",
    coerce: !0,
    ...m(t)
  });
}
function tr(e, t) {
  return new e({
    type: "string",
    format: "email",
    check: "string_format",
    abort: !1,
    ...m(t)
  });
}
function gn(e, t) {
  return new e({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: !1,
    ...m(t)
  });
}
function rr(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    ...m(t)
  });
}
function ir(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v4",
    ...m(t)
  });
}
function or(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v6",
    ...m(t)
  });
}
function ar(e, t) {
  return new e({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v7",
    ...m(t)
  });
}
function On(e, t) {
  return new e({
    type: "string",
    format: "url",
    check: "string_format",
    abort: !1,
    ...m(t)
  });
}
function ur(e, t) {
  return new e({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: !1,
    ...m(t)
  });
}
function cr(e, t) {
  return new e({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: !1,
    ...m(t)
  });
}
function lr(e, t) {
  return new e({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: !1,
    ...m(t)
  });
}
function sr(e, t) {
  return new e({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: !1,
    ...m(t)
  });
}
function dr(e, t) {
  return new e({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: !1,
    ...m(t)
  });
}
function mr(e, t) {
  return new e({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: !1,
    ...m(t)
  });
}
function fr(e, t) {
  return new e({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: !1,
    ...m(t)
  });
}
function gr(e, t) {
  return new e({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: !1,
    ...m(t)
  });
}
function pr(e, t) {
  return new e({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: !1,
    ...m(t)
  });
}
function nc(e, t) {
  return new e({
    type: "string",
    format: "mac",
    check: "string_format",
    abort: !1,
    ...m(t)
  });
}
function vr(e, t) {
  return new e({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: !1,
    ...m(t)
  });
}
function hr(e, t) {
  return new e({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: !1,
    ...m(t)
  });
}
function $r(e, t) {
  return new e({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: !1,
    ...m(t)
  });
}
function br(e, t) {
  return new e({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: !1,
    ...m(t)
  });
}
function _r(e, t) {
  return new e({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: !1,
    ...m(t)
  });
}
function yr(e, t) {
  return new e({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: !1,
    ...m(t)
  });
}
const kr = {
  Any: null,
  Minute: -1,
  Second: 0,
  Millisecond: 3,
  Microsecond: 6
};
function tc(e, t) {
  return new e({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: !1,
    local: !1,
    precision: null,
    ...m(t)
  });
}
function rc(e, t) {
  return new e({
    type: "string",
    format: "date",
    check: "string_format",
    ...m(t)
  });
}
function ic(e, t) {
  return new e({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...m(t)
  });
}
function oc(e, t) {
  return new e({
    type: "string",
    format: "duration",
    check: "string_format",
    ...m(t)
  });
}
function ac(e, t) {
  return new e({
    type: "number",
    checks: [],
    ...m(t)
  });
}
function uc(e, t) {
  return new e({
    type: "number",
    coerce: !0,
    checks: [],
    ...m(t)
  });
}
function cc(e, t) {
  return new e({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "safeint",
    ...m(t)
  });
}
function lc(e, t) {
  return new e({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "float32",
    ...m(t)
  });
}
function sc(e, t) {
  return new e({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "float64",
    ...m(t)
  });
}
function dc(e, t) {
  return new e({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "int32",
    ...m(t)
  });
}
function mc(e, t) {
  return new e({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "uint32",
    ...m(t)
  });
}
function fc(e, t) {
  return new e({
    type: "boolean",
    ...m(t)
  });
}
function gc(e, t) {
  return new e({
    type: "boolean",
    coerce: !0,
    ...m(t)
  });
}
function pc(e, t) {
  return new e({
    type: "bigint",
    ...m(t)
  });
}
function vc(e, t) {
  return new e({
    type: "bigint",
    coerce: !0,
    ...m(t)
  });
}
function hc(e, t) {
  return new e({
    type: "bigint",
    check: "bigint_format",
    abort: !1,
    format: "int64",
    ...m(t)
  });
}
function $c(e, t) {
  return new e({
    type: "bigint",
    check: "bigint_format",
    abort: !1,
    format: "uint64",
    ...m(t)
  });
}
function bc(e, t) {
  return new e({
    type: "symbol",
    ...m(t)
  });
}
function _c(e, t) {
  return new e({
    type: "undefined",
    ...m(t)
  });
}
function yc(e, t) {
  return new e({
    type: "null",
    ...m(t)
  });
}
function kc(e) {
  return new e({
    type: "any"
  });
}
function Ic(e) {
  return new e({
    type: "unknown"
  });
}
function zc(e, t) {
  return new e({
    type: "never",
    ...m(t)
  });
}
function Sc(e, t) {
  return new e({
    type: "void",
    ...m(t)
  });
}
function wc(e, t) {
  return new e({
    type: "date",
    ...m(t)
  });
}
function jc(e, t) {
  return new e({
    type: "date",
    coerce: !0,
    ...m(t)
  });
}
function Oc(e, t) {
  return new e({
    type: "nan",
    ...m(t)
  });
}
function Q(e, t) {
  return new Vt({
    check: "less_than",
    ...m(t),
    value: e,
    inclusive: !1
  });
}
function A(e, t) {
  return new Vt({
    check: "less_than",
    ...m(t),
    value: e,
    inclusive: !0
  });
}
function ee(e, t) {
  return new Kt({
    check: "greater_than",
    ...m(t),
    value: e,
    inclusive: !1
  });
}
function N(e, t) {
  return new Kt({
    check: "greater_than",
    ...m(t),
    value: e,
    inclusive: !0
  });
}
function Ir(e) {
  return ee(0, e);
}
function zr(e) {
  return Q(0, e);
}
function Sr(e) {
  return A(0, e);
}
function wr(e) {
  return N(0, e);
}
function pe(e, t) {
  return new va({
    check: "multiple_of",
    ...m(t),
    value: e
  });
}
function Me(e, t) {
  return new ba({
    check: "max_size",
    ...m(t),
    maximum: e
  });
}
function ve(e, t) {
  return new _a({
    check: "min_size",
    ...m(t),
    minimum: e
  });
}
function Nn(e, t) {
  return new ya({
    check: "size_equals",
    ...m(t),
    size: e
  });
}
function ue(e, t) {
  return new ka({
    check: "max_length",
    ...m(t),
    maximum: e
  });
}
function B(e, t) {
  return new Ia({
    check: "min_length",
    ...m(t),
    minimum: e
  });
}
function Ge(e, t) {
  return new za({
    check: "length_equals",
    ...m(t),
    length: e
  });
}
function Un(e, t) {
  return new Sa({
    check: "string_format",
    format: "regex",
    ...m(t),
    pattern: e
  });
}
function xn(e) {
  return new wa({
    check: "string_format",
    format: "lowercase",
    ...m(e)
  });
}
function Pn(e) {
  return new ja({
    check: "string_format",
    format: "uppercase",
    ...m(e)
  });
}
function Zn(e, t) {
  return new Oa({
    check: "string_format",
    format: "includes",
    ...m(t),
    includes: e
  });
}
function Dn(e, t) {
  return new Na({
    check: "string_format",
    format: "starts_with",
    ...m(t),
    prefix: e
  });
}
function Tn(e, t) {
  return new Ua({
    check: "string_format",
    format: "ends_with",
    ...m(t),
    suffix: e
  });
}
function jr(e, t, i) {
  return new xa({
    check: "property",
    property: e,
    schema: t,
    ...m(i)
  });
}
function En(e, t) {
  return new Pa({
    check: "mime_type",
    mime: e,
    ...m(t)
  });
}
function Y(e) {
  return new Za({
    check: "overwrite",
    tx: e
  });
}
function An(e) {
  return Y((t) => t.normalize(e));
}
function Ln() {
  return Y((e) => e.trim());
}
function Rn() {
  return Y((e) => e.toLowerCase());
}
function Cn() {
  return Y((e) => e.toUpperCase());
}
function Jn() {
  return Y((e) => po(e));
}
function Nc(e, t, i) {
  return new e({
    type: "array",
    element: t,
    // get element() {
    //   return element;
    // },
    ...m(i)
  });
}
function cf(e, t, i) {
  return new e({
    type: "union",
    options: t,
    ...m(i)
  });
}
function lf(e, t, i) {
  return new e({
    type: "union",
    options: t,
    inclusive: !1,
    ...m(i)
  });
}
function sf(e, t, i, r) {
  return new e({
    type: "union",
    options: i,
    discriminator: t,
    ...m(r)
  });
}
function df(e, t, i) {
  return new e({
    type: "intersection",
    left: t,
    right: i
  });
}
function mf(e, t, i, r) {
  const n = i instanceof $, o = n ? r : i, a = n ? i : null;
  return new e({
    type: "tuple",
    items: t,
    rest: a,
    ...m(o)
  });
}
function ff(e, t, i, r) {
  return new e({
    type: "record",
    keyType: t,
    valueType: i,
    ...m(r)
  });
}
function gf(e, t, i, r) {
  return new e({
    type: "map",
    keyType: t,
    valueType: i,
    ...m(r)
  });
}
function pf(e, t, i) {
  return new e({
    type: "set",
    valueType: t,
    ...m(i)
  });
}
function vf(e, t, i) {
  const r = Array.isArray(t) ? Object.fromEntries(t.map((n) => [n, n])) : t;
  return new e({
    type: "enum",
    entries: r,
    ...m(i)
  });
}
function hf(e, t, i) {
  return new e({
    type: "enum",
    entries: t,
    ...m(i)
  });
}
function $f(e, t, i) {
  return new e({
    type: "literal",
    values: Array.isArray(t) ? t : [t],
    ...m(i)
  });
}
function Uc(e, t) {
  return new e({
    type: "file",
    ...m(t)
  });
}
function bf(e, t) {
  return new e({
    type: "transform",
    transform: t
  });
}
function _f(e, t) {
  return new e({
    type: "optional",
    innerType: t
  });
}
function yf(e, t) {
  return new e({
    type: "nullable",
    innerType: t
  });
}
function kf(e, t, i) {
  return new e({
    type: "default",
    innerType: t,
    get defaultValue() {
      return typeof i == "function" ? i() : _n(i);
    }
  });
}
function If(e, t, i) {
  return new e({
    type: "nonoptional",
    innerType: t,
    ...m(i)
  });
}
function zf(e, t) {
  return new e({
    type: "success",
    innerType: t
  });
}
function Sf(e, t, i) {
  return new e({
    type: "catch",
    innerType: t,
    catchValue: typeof i == "function" ? i : () => i
  });
}
function wf(e, t, i) {
  return new e({
    type: "pipe",
    in: t,
    out: i
  });
}
function jf(e, t) {
  return new e({
    type: "readonly",
    innerType: t
  });
}
function Of(e, t, i) {
  return new e({
    type: "template_literal",
    parts: t,
    ...m(i)
  });
}
function Nf(e, t) {
  return new e({
    type: "lazy",
    getter: t
  });
}
function Uf(e, t) {
  return new e({
    type: "promise",
    innerType: t
  });
}
function xc(e, t, i) {
  const r = m(i);
  return r.abort ?? (r.abort = !0), new e({
    type: "custom",
    check: "custom",
    fn: t,
    ...r
  });
}
function Pc(e, t, i) {
  return new e({
    type: "custom",
    check: "custom",
    fn: t,
    ...m(i)
  });
}
function Zc(e) {
  const t = Dc((i) => (i.addIssue = (r) => {
    if (typeof r == "string")
      i.issues.push(fe(r, i.value, t._zod.def));
    else {
      const n = r;
      n.fatal && (n.continue = !1), n.code ?? (n.code = "custom"), n.input ?? (n.input = i.value), n.inst ?? (n.inst = t), n.continue ?? (n.continue = !t._zod.def.abort), i.issues.push(fe(n));
    }
  }, e(i.value, i)));
  return t;
}
function Dc(e, t) {
  const i = new S({
    check: "custom",
    ...m(t)
  });
  return i._zod.check = e, i;
}
function Tc(e) {
  const t = new S({ check: "describe" });
  return t._zod.onattach = [
    (i) => {
      const r = E.get(i) ?? {};
      E.add(i, { ...r, description: e });
    }
  ], t._zod.check = () => {
  }, t;
}
function Ec(e) {
  const t = new S({ check: "meta" });
  return t._zod.onattach = [
    (i) => {
      const r = E.get(i) ?? {};
      E.add(i, { ...r, ...e });
    }
  ], t._zod.check = () => {
  }, t;
}
function Ac(e, t) {
  const i = m(t);
  let r = i.truthy ?? ["true", "1", "yes", "on", "y", "enabled"], n = i.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  i.case !== "sensitive" && (r = r.map((v) => typeof v == "string" ? v.toLowerCase() : v), n = n.map((v) => typeof v == "string" ? v.toLowerCase() : v));
  const o = new Set(r), a = new Set(n), u = e.Codec ?? Ht, l = e.Boolean ?? Xt, c = e.String ?? Fe, d = new c({ type: "string", error: i.error }), f = new l({ type: "boolean", error: i.error }), p = new u({
    type: "pipe",
    in: d,
    out: f,
    transform: ((v, y) => {
      let T = v;
      return i.case !== "sensitive" && (T = T.toLowerCase()), o.has(T) ? !0 : a.has(T) ? !1 : (y.issues.push({
        code: "invalid_value",
        expected: "stringbool",
        values: [...o, ...a],
        input: y.value,
        inst: p,
        continue: !1
      }), {});
    }),
    reverseTransform: ((v, y) => v === !0 ? r[0] || "true" : n[0] || "false"),
    error: i.error
  });
  return p;
}
function Ve(e, t, i, r = {}) {
  const n = m(r), o = {
    ...m(r),
    check: "string_format",
    type: "string",
    format: t,
    fn: typeof i == "function" ? i : (u) => i.test(u),
    ...n
  };
  return i instanceof RegExp && (o.pattern = i), new e(o);
}
function he(e) {
  let t = e?.target ?? "draft-2020-12";
  return t === "draft-4" && (t = "draft-04"), t === "draft-7" && (t = "draft-07"), {
    processors: e.processors ?? {},
    metadataRegistry: e?.metadata ?? E,
    target: t,
    unrepresentable: e?.unrepresentable ?? "throw",
    override: e?.override ?? (() => {
    }),
    io: e?.io ?? "output",
    counter: 0,
    seen: /* @__PURE__ */ new Map(),
    cycles: e?.cycles ?? "ref",
    reused: e?.reused ?? "inline",
    external: e?.external ?? void 0
  };
}
function k(e, t, i = { path: [], schemaPath: [] }) {
  var r;
  const n = e._zod.def, o = t.seen.get(e);
  if (o)
    return o.count++, i.schemaPath.includes(e) && (o.cycle = i.path), o.schema;
  const a = { schema: {}, count: 1, cycle: void 0, path: i.path };
  t.seen.set(e, a);
  const u = e._zod.toJSONSchema?.();
  if (u)
    a.schema = u;
  else {
    const d = {
      ...i,
      schemaPath: [...i.schemaPath, e],
      path: i.path
    }, f = e._zod.parent;
    if (f)
      a.ref = f, k(f, t, d), t.seen.get(f).isParent = !0;
    else if (e._zod.processJSONSchema)
      e._zod.processJSONSchema(t, a.schema, d);
    else {
      const p = a.schema, v = t.processors[n.type];
      if (!v)
        throw new Error(`[toJSONSchema]: Non-representable type encountered: ${n.type}`);
      v(e, t, p, d);
    }
  }
  const l = t.metadataRegistry.get(e);
  return l && Object.assign(a.schema, l), t.io === "input" && O(e) && (delete a.schema.examples, delete a.schema.default), t.io === "input" && a.schema._prefault && ((r = a.schema).default ?? (r.default = a.schema._prefault)), delete a.schema._prefault, t.seen.get(e).schema;
}
function $e(e, t) {
  const i = e.seen.get(t);
  if (!i)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const r = (o) => {
    const a = e.target === "draft-2020-12" ? "$defs" : "definitions";
    if (e.external) {
      const d = e.external.registry.get(o[0])?.id, f = e.external.uri ?? ((v) => v);
      if (d)
        return { ref: f(d) };
      const p = o[1].defId ?? o[1].schema.id ?? `schema${e.counter++}`;
      return o[1].defId = p, { defId: p, ref: `${f("__shared")}#/${a}/${p}` };
    }
    if (o[1] === i)
      return { ref: "#" };
    const l = `#/${a}/`, c = o[1].schema.id ?? `__schema${e.counter++}`;
    return { defId: c, ref: l + c };
  }, n = (o) => {
    if (o[1].schema.$ref)
      return;
    const a = o[1], { ref: u, defId: l } = r(o);
    a.def = { ...a.schema }, l && (a.defId = l);
    const c = a.schema;
    for (const d in c)
      delete c[d];
    c.$ref = u;
  };
  if (e.cycles === "throw")
    for (const o of e.seen.entries()) {
      const a = o[1];
      if (a.cycle)
        throw new Error(`Cycle detected: #/${a.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
    }
  for (const o of e.seen.entries()) {
    const a = o[1];
    if (t === o[0]) {
      n(o);
      continue;
    }
    if (e.external) {
      const l = e.external.registry.get(o[0])?.id;
      if (t !== o[0] && l) {
        n(o);
        continue;
      }
    }
    if (e.metadataRegistry.get(o[0])?.id) {
      n(o);
      continue;
    }
    if (a.cycle) {
      n(o);
      continue;
    }
    if (a.count > 1 && e.reused === "ref") {
      n(o);
      continue;
    }
  }
}
function be(e, t) {
  const i = e.seen.get(t);
  if (!i)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const r = (a) => {
    const u = e.seen.get(a), l = u.def ?? u.schema, c = { ...l };
    if (u.ref === null)
      return;
    const d = u.ref;
    if (u.ref = null, d) {
      r(d);
      const f = e.seen.get(d).schema;
      f.$ref && (e.target === "draft-07" || e.target === "draft-04" || e.target === "openapi-3.0") ? (l.allOf = l.allOf ?? [], l.allOf.push(f)) : (Object.assign(l, f), Object.assign(l, c));
    }
    u.isParent || e.override({
      zodSchema: a,
      jsonSchema: l,
      path: u.path ?? []
    });
  };
  for (const a of [...e.seen.entries()].reverse())
    r(a[0]);
  const n = {};
  if (e.target === "draft-2020-12" ? n.$schema = "https://json-schema.org/draft/2020-12/schema" : e.target === "draft-07" ? n.$schema = "http://json-schema.org/draft-07/schema#" : e.target === "draft-04" ? n.$schema = "http://json-schema.org/draft-04/schema#" : e.target, e.external?.uri) {
    const a = e.external.registry.get(t)?.id;
    if (!a)
      throw new Error("Schema is missing an `id` property");
    n.$id = e.external.uri(a);
  }
  Object.assign(n, i.def ?? i.schema);
  const o = e.external?.defs ?? {};
  for (const a of e.seen.entries()) {
    const u = a[1];
    u.def && u.defId && (o[u.defId] = u.def);
  }
  e.external || Object.keys(o).length > 0 && (e.target === "draft-2020-12" ? n.$defs = o : n.definitions = o);
  try {
    const a = JSON.parse(JSON.stringify(n));
    return Object.defineProperty(a, "~standard", {
      value: {
        ...t["~standard"],
        jsonSchema: {
          input: Oe(t, "input"),
          output: Oe(t, "output")
        }
      },
      enumerable: !1,
      writable: !1
    }), a;
  } catch {
    throw new Error("Error converting schema to JSON.");
  }
}
function O(e, t) {
  const i = t ?? { seen: /* @__PURE__ */ new Set() };
  if (i.seen.has(e))
    return !1;
  i.seen.add(e);
  const r = e._zod.def;
  if (r.type === "transform")
    return !0;
  if (r.type === "array")
    return O(r.element, i);
  if (r.type === "set")
    return O(r.valueType, i);
  if (r.type === "lazy")
    return O(r.getter(), i);
  if (r.type === "promise" || r.type === "optional" || r.type === "nonoptional" || r.type === "nullable" || r.type === "readonly" || r.type === "default" || r.type === "prefault")
    return O(r.innerType, i);
  if (r.type === "intersection")
    return O(r.left, i) || O(r.right, i);
  if (r.type === "record" || r.type === "map")
    return O(r.keyType, i) || O(r.valueType, i);
  if (r.type === "pipe")
    return O(r.in, i) || O(r.out, i);
  if (r.type === "object") {
    for (const n in r.shape)
      if (O(r.shape[n], i))
        return !0;
    return !1;
  }
  if (r.type === "union") {
    for (const n of r.options)
      if (O(n, i))
        return !0;
    return !1;
  }
  if (r.type === "tuple") {
    for (const n of r.items)
      if (O(n, i))
        return !0;
    return !!(r.rest && O(r.rest, i));
  }
  return !1;
}
const Lc = (e, t = {}) => (i) => {
  const r = he({ ...i, processors: t });
  return k(e, r), $e(r, e), be(r, e);
}, Oe = (e, t) => (i) => {
  const { libraryOptions: r, target: n } = i ?? {}, o = he({ ...r ?? {}, target: n, io: t, processors: {} });
  return k(e, o), $e(o, e), be(o, e);
}, xf = {
  guid: "uuid",
  url: "uri",
  datetime: "date-time",
  json_string: "json-string",
  regex: ""
  // do not set
}, Rc = (e, t, i, r) => {
  const n = i;
  n.type = "string";
  const { minimum: o, maximum: a, format: u, patterns: l, contentEncoding: c } = e._zod.bag;
  if (typeof o == "number" && (n.minLength = o), typeof a == "number" && (n.maxLength = a), u && (n.format = xf[u] ?? u, n.format === "" && delete n.format), c && (n.contentEncoding = c), l && l.size > 0) {
    const d = [...l];
    d.length === 1 ? n.pattern = d[0].source : d.length > 1 && (n.allOf = [
      ...d.map((f) => ({
        ...t.target === "draft-07" || t.target === "draft-04" || t.target === "openapi-3.0" ? { type: "string" } : {},
        pattern: f.source
      }))
    ]);
  }
}, Cc = (e, t, i, r) => {
  const n = i, { minimum: o, maximum: a, format: u, multipleOf: l, exclusiveMaximum: c, exclusiveMinimum: d } = e._zod.bag;
  typeof u == "string" && u.includes("int") ? n.type = "integer" : n.type = "number", typeof d == "number" && (t.target === "draft-04" || t.target === "openapi-3.0" ? (n.minimum = d, n.exclusiveMinimum = !0) : n.exclusiveMinimum = d), typeof o == "number" && (n.minimum = o, typeof d == "number" && t.target !== "draft-04" && (d >= o ? delete n.minimum : delete n.exclusiveMinimum)), typeof c == "number" && (t.target === "draft-04" || t.target === "openapi-3.0" ? (n.maximum = c, n.exclusiveMaximum = !0) : n.exclusiveMaximum = c), typeof a == "number" && (n.maximum = a, typeof c == "number" && t.target !== "draft-04" && (c <= a ? delete n.maximum : delete n.exclusiveMaximum)), typeof l == "number" && (n.multipleOf = l);
}, Jc = (e, t, i, r) => {
  i.type = "boolean";
}, Fc = (e, t, i, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("BigInt cannot be represented in JSON Schema");
}, Mc = (e, t, i, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Symbols cannot be represented in JSON Schema");
}, Gc = (e, t, i, r) => {
  t.target === "openapi-3.0" ? (i.type = "string", i.nullable = !0, i.enum = [null]) : i.type = "null";
}, Vc = (e, t, i, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Undefined cannot be represented in JSON Schema");
}, Kc = (e, t, i, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Void cannot be represented in JSON Schema");
}, Wc = (e, t, i, r) => {
  i.not = {};
}, Bc = (e, t, i, r) => {
}, Xc = (e, t, i, r) => {
}, qc = (e, t, i, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Date cannot be represented in JSON Schema");
}, Yc = (e, t, i, r) => {
  const n = e._zod.def, o = Ut(n.entries);
  o.every((a) => typeof a == "number") && (i.type = "number"), o.every((a) => typeof a == "string") && (i.type = "string"), i.enum = o;
}, Hc = (e, t, i, r) => {
  const n = e._zod.def, o = [];
  for (const a of n.values)
    if (a === void 0) {
      if (t.unrepresentable === "throw")
        throw new Error("Literal `undefined` cannot be represented in JSON Schema");
    } else if (typeof a == "bigint") {
      if (t.unrepresentable === "throw")
        throw new Error("BigInt literals cannot be represented in JSON Schema");
      o.push(Number(a));
    } else
      o.push(a);
  if (o.length !== 0) if (o.length === 1) {
    const a = o[0];
    i.type = a === null ? "null" : typeof a, t.target === "draft-04" || t.target === "openapi-3.0" ? i.enum = [a] : i.const = a;
  } else
    o.every((a) => typeof a == "number") && (i.type = "number"), o.every((a) => typeof a == "string") && (i.type = "string"), o.every((a) => typeof a == "boolean") && (i.type = "boolean"), o.every((a) => a === null) && (i.type = "null"), i.enum = o;
}, Qc = (e, t, i, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("NaN cannot be represented in JSON Schema");
}, el = (e, t, i, r) => {
  const n = i, o = e._zod.pattern;
  if (!o)
    throw new Error("Pattern not found in template literal");
  n.type = "string", n.pattern = o.source;
}, nl = (e, t, i, r) => {
  const n = i, o = {
    type: "string",
    format: "binary",
    contentEncoding: "binary"
  }, { minimum: a, maximum: u, mime: l } = e._zod.bag;
  a !== void 0 && (o.minLength = a), u !== void 0 && (o.maxLength = u), l ? l.length === 1 ? (o.contentMediaType = l[0], Object.assign(n, o)) : n.anyOf = l.map((c) => ({ ...o, contentMediaType: c })) : Object.assign(n, o);
}, tl = (e, t, i, r) => {
  i.type = "boolean";
}, rl = (e, t, i, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Custom types cannot be represented in JSON Schema");
}, il = (e, t, i, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Function types cannot be represented in JSON Schema");
}, ol = (e, t, i, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Transforms cannot be represented in JSON Schema");
}, al = (e, t, i, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Map cannot be represented in JSON Schema");
}, ul = (e, t, i, r) => {
  if (t.unrepresentable === "throw")
    throw new Error("Set cannot be represented in JSON Schema");
}, cl = (e, t, i, r) => {
  const n = i, o = e._zod.def, { minimum: a, maximum: u } = e._zod.bag;
  typeof a == "number" && (n.minItems = a), typeof u == "number" && (n.maxItems = u), n.type = "array", n.items = k(o.element, t, { ...r, path: [...r.path, "items"] });
}, ll = (e, t, i, r) => {
  const n = i, o = e._zod.def;
  n.type = "object", n.properties = {};
  const a = o.shape;
  for (const c in a)
    n.properties[c] = k(a[c], t, {
      ...r,
      path: [...r.path, "properties", c]
    });
  const u = new Set(Object.keys(a)), l = new Set([...u].filter((c) => {
    const d = o.shape[c]._zod;
    return t.io === "input" ? d.optin === void 0 : d.optout === void 0;
  }));
  l.size > 0 && (n.required = Array.from(l)), o.catchall?._zod.def.type === "never" ? n.additionalProperties = !1 : o.catchall ? o.catchall && (n.additionalProperties = k(o.catchall, t, {
    ...r,
    path: [...r.path, "additionalProperties"]
  })) : t.io === "output" && (n.additionalProperties = !1);
}, Or = (e, t, i, r) => {
  const n = e._zod.def, o = n.inclusive === !1, a = n.options.map((u, l) => k(u, t, {
    ...r,
    path: [...r.path, o ? "oneOf" : "anyOf", l]
  }));
  o ? i.oneOf = a : i.anyOf = a;
}, sl = (e, t, i, r) => {
  const n = e._zod.def, o = k(n.left, t, {
    ...r,
    path: [...r.path, "allOf", 0]
  }), a = k(n.right, t, {
    ...r,
    path: [...r.path, "allOf", 1]
  }), u = (c) => "allOf" in c && Object.keys(c).length === 1, l = [
    ...u(o) ? o.allOf : [o],
    ...u(a) ? a.allOf : [a]
  ];
  i.allOf = l;
}, dl = (e, t, i, r) => {
  const n = i, o = e._zod.def;
  n.type = "array";
  const a = t.target === "draft-2020-12" ? "prefixItems" : "items", u = t.target === "draft-2020-12" || t.target === "openapi-3.0" ? "items" : "additionalItems", l = o.items.map((p, v) => k(p, t, {
    ...r,
    path: [...r.path, a, v]
  })), c = o.rest ? k(o.rest, t, {
    ...r,
    path: [...r.path, u, ...t.target === "openapi-3.0" ? [o.items.length] : []]
  }) : null;
  t.target === "draft-2020-12" ? (n.prefixItems = l, c && (n.items = c)) : t.target === "openapi-3.0" ? (n.items = {
    anyOf: l
  }, c && n.items.anyOf.push(c), n.minItems = l.length, c || (n.maxItems = l.length)) : (n.items = l, c && (n.additionalItems = c));
  const { minimum: d, maximum: f } = e._zod.bag;
  typeof d == "number" && (n.minItems = d), typeof f == "number" && (n.maxItems = f);
}, ml = (e, t, i, r) => {
  const n = i, o = e._zod.def;
  n.type = "object", (t.target === "draft-07" || t.target === "draft-2020-12") && (n.propertyNames = k(o.keyType, t, {
    ...r,
    path: [...r.path, "propertyNames"]
  })), n.additionalProperties = k(o.valueType, t, {
    ...r,
    path: [...r.path, "additionalProperties"]
  });
}, fl = (e, t, i, r) => {
  const n = e._zod.def, o = k(n.innerType, t, r), a = t.seen.get(e);
  t.target === "openapi-3.0" ? (a.ref = n.innerType, i.nullable = !0) : i.anyOf = [o, { type: "null" }];
}, gl = (e, t, i, r) => {
  const n = e._zod.def;
  k(n.innerType, t, r);
  const o = t.seen.get(e);
  o.ref = n.innerType;
}, pl = (e, t, i, r) => {
  const n = e._zod.def;
  k(n.innerType, t, r);
  const o = t.seen.get(e);
  o.ref = n.innerType, i.default = JSON.parse(JSON.stringify(n.defaultValue));
}, vl = (e, t, i, r) => {
  const n = e._zod.def;
  k(n.innerType, t, r);
  const o = t.seen.get(e);
  o.ref = n.innerType, t.io === "input" && (i._prefault = JSON.parse(JSON.stringify(n.defaultValue)));
}, hl = (e, t, i, r) => {
  const n = e._zod.def;
  k(n.innerType, t, r);
  const o = t.seen.get(e);
  o.ref = n.innerType;
  let a;
  try {
    a = n.catchValue(void 0);
  } catch {
    throw new Error("Dynamic catch values are not supported in JSON Schema");
  }
  i.default = a;
}, $l = (e, t, i, r) => {
  const n = e._zod.def, o = t.io === "input" ? n.in._zod.def.type === "transform" ? n.out : n.in : n.out;
  k(o, t, r);
  const a = t.seen.get(e);
  a.ref = o;
}, bl = (e, t, i, r) => {
  const n = e._zod.def;
  k(n.innerType, t, r);
  const o = t.seen.get(e);
  o.ref = n.innerType, i.readOnly = !0;
}, _l = (e, t, i, r) => {
  const n = e._zod.def;
  k(n.innerType, t, r);
  const o = t.seen.get(e);
  o.ref = n.innerType;
}, yl = (e, t, i, r) => {
  const n = e._zod.def;
  k(n.innerType, t, r);
  const o = t.seen.get(e);
  o.ref = n.innerType;
}, kl = (e, t, i, r) => {
  const n = e._zod.innerType;
  k(n, t, r);
  const o = t.seen.get(e);
  o.ref = n;
}, St = {
  string: Rc,
  number: Cc,
  boolean: Jc,
  bigint: Fc,
  symbol: Mc,
  null: Gc,
  undefined: Vc,
  void: Kc,
  never: Wc,
  any: Bc,
  unknown: Xc,
  date: qc,
  enum: Yc,
  literal: Hc,
  nan: Qc,
  template_literal: el,
  file: nl,
  success: tl,
  custom: rl,
  function: il,
  transform: ol,
  map: al,
  set: ul,
  array: cl,
  object: ll,
  union: Or,
  intersection: sl,
  tuple: dl,
  record: ml,
  nullable: fl,
  nonoptional: gl,
  default: pl,
  prefault: vl,
  catch: hl,
  pipe: $l,
  readonly: bl,
  promise: _l,
  optional: yl,
  lazy: kl
};
function Nr(e, t) {
  if ("_idmap" in e) {
    const r = e, n = he({ ...t, processors: St }), o = {};
    for (const l of r._idmap.entries()) {
      const [c, d] = l;
      k(d, n);
    }
    const a = {}, u = {
      registry: r,
      uri: t?.uri,
      defs: o
    };
    n.external = u;
    for (const l of r._idmap.entries()) {
      const [c, d] = l;
      $e(n, d), a[c] = be(n, d);
    }
    if (Object.keys(o).length > 0) {
      const l = n.target === "draft-2020-12" ? "$defs" : "definitions";
      a.__shared = {
        [l]: o
      };
    }
    return { schemas: a };
  }
  const i = he({ ...t, processors: St });
  return k(e, i), $e(i, e), be(i, e);
}
class Pf {
  /** @deprecated Access via ctx instead */
  get metadataRegistry() {
    return this.ctx.metadataRegistry;
  }
  /** @deprecated Access via ctx instead */
  get target() {
    return this.ctx.target;
  }
  /** @deprecated Access via ctx instead */
  get unrepresentable() {
    return this.ctx.unrepresentable;
  }
  /** @deprecated Access via ctx instead */
  get override() {
    return this.ctx.override;
  }
  /** @deprecated Access via ctx instead */
  get io() {
    return this.ctx.io;
  }
  /** @deprecated Access via ctx instead */
  get counter() {
    return this.ctx.counter;
  }
  set counter(t) {
    this.ctx.counter = t;
  }
  /** @deprecated Access via ctx instead */
  get seen() {
    return this.ctx.seen;
  }
  constructor(t) {
    let i = t?.target ?? "draft-2020-12";
    i === "draft-4" && (i = "draft-04"), i === "draft-7" && (i = "draft-07"), this.ctx = he({
      processors: St,
      target: i,
      ...t?.metadata && { metadata: t.metadata },
      ...t?.unrepresentable && { unrepresentable: t.unrepresentable },
      ...t?.override && { override: t.override },
      ...t?.io && { io: t.io }
    });
  }
  /**
   * Process a schema to prepare it for JSON Schema generation.
   * This must be called before emit().
   */
  process(t, i = { path: [], schemaPath: [] }) {
    return k(t, this.ctx, i);
  }
  /**
   * Emit the final JSON Schema after processing.
   * Must call process() first.
   */
  emit(t, i) {
    i && (i.cycles && (this.ctx.cycles = i.cycles), i.reused && (this.ctx.reused = i.reused), i.external && (this.ctx.external = i.external)), $e(this.ctx, t);
    const r = be(this.ctx, t), { "~standard": n, ...o } = r;
    return o;
  }
}
const Zf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), Il = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  $ZodAny: gu,
  $ZodArray: bu,
  $ZodAsyncError: ie,
  $ZodBase64: tu,
  $ZodBase64URL: iu,
  $ZodBigInt: qt,
  $ZodBigIntFormat: su,
  $ZodBoolean: Xt,
  $ZodCIDRv4: eu,
  $ZodCIDRv6: nu,
  $ZodCUID: Fa,
  $ZodCUID2: Ma,
  $ZodCatch: Cu,
  $ZodCheck: S,
  $ZodCheckBigIntFormat: $a,
  $ZodCheckEndsWith: Ua,
  $ZodCheckGreaterThan: Kt,
  $ZodCheckIncludes: Oa,
  $ZodCheckLengthEquals: za,
  $ZodCheckLessThan: Vt,
  $ZodCheckLowerCase: wa,
  $ZodCheckMaxLength: ka,
  $ZodCheckMaxSize: ba,
  $ZodCheckMimeType: Pa,
  $ZodCheckMinLength: Ia,
  $ZodCheckMinSize: _a,
  $ZodCheckMultipleOf: va,
  $ZodCheckNumberFormat: ha,
  $ZodCheckOverwrite: Za,
  $ZodCheckProperty: xa,
  $ZodCheckRegex: Sa,
  $ZodCheckSizeEquals: ya,
  $ZodCheckStartsWith: Na,
  $ZodCheckStringFormat: Je,
  $ZodCheckUpperCase: ja,
  $ZodCodec: Ht,
  $ZodCustom: Bu,
  $ZodCustomStringFormat: cu,
  $ZodDate: $u,
  $ZodDefault: Eu,
  $ZodDiscriminatedUnion: Su,
  $ZodE164: ou,
  $ZodEmail: La,
  $ZodEmoji: Ca,
  $ZodEncodeError: $n,
  $ZodEnum: Uu,
  $ZodError: Zt,
  $ZodFile: Pu,
  $ZodFunction: Vu,
  $ZodGUID: Ea,
  $ZodIPv4: Ya,
  $ZodIPv6: Ha,
  $ZodISODate: Ba,
  $ZodISODateTime: Wa,
  $ZodISODuration: qa,
  $ZodISOTime: Xa,
  $ZodIntersection: wu,
  $ZodJWT: uu,
  $ZodKSUID: Ka,
  $ZodLazy: Wu,
  $ZodLiteral: xu,
  $ZodMAC: Qa,
  $ZodMap: Ou,
  $ZodNaN: Ju,
  $ZodNanoID: Ja,
  $ZodNever: vu,
  $ZodNonOptional: Lu,
  $ZodNull: fu,
  $ZodNullable: Tu,
  $ZodNumber: Bt,
  $ZodNumberFormat: lu,
  $ZodObject: ku,
  $ZodObjectJIT: Iu,
  $ZodOptional: Du,
  $ZodPipe: Fu,
  $ZodPrefault: Au,
  $ZodPromise: Ku,
  $ZodReadonly: Mu,
  $ZodRealError: D,
  $ZodRecord: ju,
  $ZodRegistry: Hu,
  $ZodSet: Nu,
  $ZodString: Fe,
  $ZodStringFormat: I,
  $ZodSuccess: Ru,
  $ZodSymbol: du,
  $ZodTemplateLiteral: Gu,
  $ZodTransform: Zu,
  $ZodTuple: Yt,
  $ZodType: $,
  $ZodULID: Ga,
  $ZodURL: Ra,
  $ZodUUID: Aa,
  $ZodUndefined: mu,
  $ZodUnion: wn,
  $ZodUnknown: pu,
  $ZodVoid: hu,
  $ZodXID: Va,
  $ZodXor: zu,
  $brand: Nt,
  $constructor: s,
  $input: nr,
  $output: er,
  Doc: Da,
  JSONSchema: Zf,
  JSONSchemaGenerator: Pf,
  NEVER: Ot,
  TimePrecision: kr,
  _any: kc,
  _array: Nc,
  _base64: $r,
  _base64url: br,
  _bigint: pc,
  _boolean: fc,
  _catch: Sf,
  _check: Dc,
  _cidrv4: vr,
  _cidrv6: hr,
  _coercedBigint: vc,
  _coercedBoolean: gc,
  _coercedDate: jc,
  _coercedNumber: uc,
  _coercedString: ec,
  _cuid: lr,
  _cuid2: sr,
  _custom: xc,
  _date: wc,
  _decode: At,
  _decodeAsync: Rt,
  _default: kf,
  _discriminatedUnion: sf,
  _e164: _r,
  _email: tr,
  _emoji: ur,
  _encode: Et,
  _encodeAsync: Lt,
  _endsWith: Tn,
  _enum: vf,
  _file: Uc,
  _float32: lc,
  _float64: sc,
  _gt: ee,
  _gte: N,
  _guid: gn,
  _includes: Zn,
  _int: cc,
  _int32: dc,
  _int64: hc,
  _intersection: df,
  _ipv4: gr,
  _ipv6: pr,
  _isoDate: rc,
  _isoDateTime: tc,
  _isoDuration: oc,
  _isoTime: ic,
  _jwt: yr,
  _ksuid: fr,
  _lazy: Nf,
  _length: Ge,
  _literal: $f,
  _lowercase: xn,
  _lt: Q,
  _lte: A,
  _mac: nc,
  _map: gf,
  _max: A,
  _maxLength: ue,
  _maxSize: Me,
  _mime: En,
  _min: N,
  _minLength: B,
  _minSize: ve,
  _multipleOf: pe,
  _nan: Oc,
  _nanoid: cr,
  _nativeEnum: hf,
  _negative: zr,
  _never: zc,
  _nonnegative: wr,
  _nonoptional: If,
  _nonpositive: Sr,
  _normalize: An,
  _null: yc,
  _nullable: yf,
  _number: ac,
  _optional: _f,
  _overwrite: Y,
  _parse: Te,
  _parseAsync: Ee,
  _pipe: wf,
  _positive: Ir,
  _promise: Uf,
  _property: jr,
  _readonly: jf,
  _record: ff,
  _refine: Pc,
  _regex: Un,
  _safeDecode: Jt,
  _safeDecodeAsync: Mt,
  _safeEncode: Ct,
  _safeEncodeAsync: Ft,
  _safeParse: Ae,
  _safeParseAsync: Le,
  _set: pf,
  _size: Nn,
  _slugify: Jn,
  _startsWith: Dn,
  _string: Qu,
  _stringFormat: Ve,
  _stringbool: Ac,
  _success: zf,
  _superRefine: Zc,
  _symbol: bc,
  _templateLiteral: Of,
  _toLowerCase: Rn,
  _toUpperCase: Cn,
  _transform: bf,
  _trim: Ln,
  _tuple: mf,
  _uint32: mc,
  _uint64: $c,
  _ulid: dr,
  _undefined: _c,
  _union: cf,
  _unknown: Ic,
  _uppercase: Pn,
  _url: On,
  _uuid: rr,
  _uuidv4: ir,
  _uuidv6: or,
  _uuidv7: ar,
  _void: Sc,
  _xid: mr,
  _xor: lf,
  clone: Z,
  config: w,
  createStandardJSONSchemaMethod: Oe,
  createToJSONSchemaMethod: Lc,
  decode: Fs,
  decodeAsync: Gs,
  describe: Tc,
  encode: Js,
  encodeAsync: Ms,
  extractDefs: $e,
  finalize: be,
  flattenError: In,
  formatError: zn,
  globalConfig: sn,
  globalRegistry: E,
  initializeContext: he,
  isValidBase64: Wt,
  isValidBase64URL: ru,
  isValidJWT: au,
  locales: Qt,
  meta: Ec,
  parse: kt,
  parseAsync: It,
  prettifyError: Tt,
  process: k,
  regexes: Sn,
  registry: jn,
  safeDecode: Ks,
  safeDecodeAsync: Bs,
  safeEncode: Vs,
  safeEncodeAsync: Ws,
  safeParse: Po,
  safeParseAsync: Zo,
  toDotPath: xo,
  toJSONSchema: Nr,
  treeifyError: Dt,
  util: Pt,
  version: Ta
}, Symbol.toStringTag, { value: "Module" })), Fn = /* @__PURE__ */ s("ZodISODateTime", (e, t) => {
  Wa.init(e, t), z.init(e, t);
});
function Ur(e) {
  return tc(Fn, e);
}
const Mn = /* @__PURE__ */ s("ZodISODate", (e, t) => {
  Ba.init(e, t), z.init(e, t);
});
function xr(e) {
  return rc(Mn, e);
}
const Gn = /* @__PURE__ */ s("ZodISOTime", (e, t) => {
  Xa.init(e, t), z.init(e, t);
});
function Pr(e) {
  return ic(Gn, e);
}
const Vn = /* @__PURE__ */ s("ZodISODuration", (e, t) => {
  qa.init(e, t), z.init(e, t);
});
function Zr(e) {
  return oc(Vn, e);
}
const zl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ZodISODate: Mn,
  ZodISODateTime: Fn,
  ZodISODuration: Vn,
  ZodISOTime: Gn,
  date: xr,
  datetime: Ur,
  duration: Zr,
  time: Pr
}, Symbol.toStringTag, { value: "Module" })), Sl = (e, t) => {
  Zt.init(e, t), e.name = "ZodError", Object.defineProperties(e, {
    format: {
      value: (i) => zn(e, i)
      // enumerable: false,
    },
    flatten: {
      value: (i) => In(e, i)
      // enumerable: false,
    },
    addIssue: {
      value: (i) => {
        e.issues.push(i), e.message = JSON.stringify(e.issues, dn, 2);
      }
      // enumerable: false,
    },
    addIssues: {
      value: (i) => {
        e.issues.push(...i), e.message = JSON.stringify(e.issues, dn, 2);
      }
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return e.issues.length === 0;
      }
      // enumerable: false,
    }
  });
}, wl = s("ZodError", Sl), U = s("ZodError", Sl, {
  Parent: Error
}), Dr = /* @__PURE__ */ Te(U), Tr = /* @__PURE__ */ Ee(U), Er = /* @__PURE__ */ Ae(U), Ar = /* @__PURE__ */ Le(U), Lr = /* @__PURE__ */ Et(U), Rr = /* @__PURE__ */ At(U), Cr = /* @__PURE__ */ Lt(U), Jr = /* @__PURE__ */ Rt(U), Fr = /* @__PURE__ */ Ct(U), Mr = /* @__PURE__ */ Jt(U), Gr = /* @__PURE__ */ Ft(U), Vr = /* @__PURE__ */ Mt(U), b = /* @__PURE__ */ s("ZodType", (e, t) => ($.init(e, t), Object.assign(e["~standard"], {
  jsonSchema: {
    input: Oe(e, "input"),
    output: Oe(e, "output")
  }
}), e.toJSONSchema = Lc(e, {}), e.def = t, e.type = t.type, Object.defineProperty(e, "_def", { value: t }), e.check = (...i) => e.clone(q(t, {
  checks: [
    ...t.checks ?? [],
    ...i.map((r) => typeof r == "function" ? { _zod: { check: r, def: { check: "custom" }, onattach: [] } } : r)
  ]
})), e.clone = (i, r) => Z(e, i, r), e.brand = () => e, e.register = ((i, r) => (i.add(e, r), e)), e.parse = (i, r) => Dr(e, i, r, { callee: e.parse }), e.safeParse = (i, r) => Er(e, i, r), e.parseAsync = async (i, r) => Tr(e, i, r, { callee: e.parseAsync }), e.safeParseAsync = async (i, r) => Ar(e, i, r), e.spa = e.safeParseAsync, e.encode = (i, r) => Lr(e, i, r), e.decode = (i, r) => Rr(e, i, r), e.encodeAsync = async (i, r) => Cr(e, i, r), e.decodeAsync = async (i, r) => Jr(e, i, r), e.safeEncode = (i, r) => Fr(e, i, r), e.safeDecode = (i, r) => Mr(e, i, r), e.safeEncodeAsync = async (i, r) => Gr(e, i, r), e.safeDecodeAsync = async (i, r) => Vr(e, i, r), e.refine = (i, r) => e.check(Ki(i, r)), e.superRefine = (i) => e.check(Wi(i)), e.overwrite = (i) => e.check(Y(i)), e.optional = () => Pe(e), e.nullable = () => ye(e), e.nullish = () => Pe(ye(e)), e.nonoptional = (i) => Ei(e, i), e.array = () => X(e), e.or = (i) => ce([e, i]), e.and = (i) => K(e, i), e.transform = (i) => Ze(e, mt(i)), e.default = (i) => Zi(e, i), e.prefault = (i) => Ti(e, i), e.catch = (i) => Ri(e, i), e.pipe = (i) => Ze(e, i), e.readonly = () => ht(e), e.describe = (i) => {
  const r = e.clone();
  return E.add(r, { description: i }), r;
}, Object.defineProperty(e, "description", {
  get() {
    return E.get(e)?.description;
  },
  configurable: !0
}), e.meta = (...i) => {
  if (i.length === 0)
    return E.get(e);
  const r = e.clone();
  return E.add(r, i[0]), r;
}, e.isOptional = () => e.safeParse(void 0).success, e.isNullable = () => e.safeParse(null).success, e)), Kn = /* @__PURE__ */ s("_ZodString", (e, t) => {
  Fe.init(e, t), b.init(e, t), e._zod.processJSONSchema = (r, n, o) => Rc(e, r, n);
  const i = e._zod.bag;
  e.format = i.format ?? null, e.minLength = i.minimum ?? null, e.maxLength = i.maximum ?? null, e.regex = (...r) => e.check(Un(...r)), e.includes = (...r) => e.check(Zn(...r)), e.startsWith = (...r) => e.check(Dn(...r)), e.endsWith = (...r) => e.check(Tn(...r)), e.min = (...r) => e.check(B(...r)), e.max = (...r) => e.check(ue(...r)), e.length = (...r) => e.check(Ge(...r)), e.nonempty = (...r) => e.check(B(1, ...r)), e.lowercase = (r) => e.check(xn(r)), e.uppercase = (r) => e.check(Pn(r)), e.trim = () => e.check(Ln()), e.normalize = (...r) => e.check(An(...r)), e.toLowerCase = () => e.check(Rn()), e.toUpperCase = () => e.check(Cn()), e.slugify = () => e.check(Jn());
}), Ke = /* @__PURE__ */ s("ZodString", (e, t) => {
  Fe.init(e, t), Kn.init(e, t), e.email = (i) => e.check(tr(Wn, i)), e.url = (i) => e.check(On(We, i)), e.jwt = (i) => e.check(yr(ct, i)), e.emoji = (i) => e.check(ur(Bn, i)), e.guid = (i) => e.check(gn(Ne, i)), e.uuid = (i) => e.check(rr(F, i)), e.uuidv4 = (i) => e.check(ir(F, i)), e.uuidv6 = (i) => e.check(or(F, i)), e.uuidv7 = (i) => e.check(ar(F, i)), e.nanoid = (i) => e.check(cr(Xn, i)), e.guid = (i) => e.check(gn(Ne, i)), e.cuid = (i) => e.check(lr(qn, i)), e.cuid2 = (i) => e.check(sr(Yn, i)), e.ulid = (i) => e.check(dr(Hn, i)), e.base64 = (i) => e.check($r(ot, i)), e.base64url = (i) => e.check(br(at, i)), e.xid = (i) => e.check(mr(Qn, i)), e.ksuid = (i) => e.check(fr(et, i)), e.ipv4 = (i) => e.check(gr(nt, i)), e.ipv6 = (i) => e.check(pr(tt, i)), e.cidrv4 = (i) => e.check(vr(rt, i)), e.cidrv6 = (i) => e.check(hr(it, i)), e.e164 = (i) => e.check(_r(ut, i)), e.datetime = (i) => e.check(Ur(i)), e.date = (i) => e.check(xr(i)), e.time = (i) => e.check(Pr(i)), e.duration = (i) => e.check(Zr(i));
});
function x(e) {
  return Qu(Ke, e);
}
const z = /* @__PURE__ */ s("ZodStringFormat", (e, t) => {
  I.init(e, t), Kn.init(e, t);
}), Wn = /* @__PURE__ */ s("ZodEmail", (e, t) => {
  La.init(e, t), z.init(e, t);
});
function Kr(e) {
  return tr(Wn, e);
}
const Ne = /* @__PURE__ */ s("ZodGUID", (e, t) => {
  Ea.init(e, t), z.init(e, t);
});
function jl(e) {
  return gn(Ne, e);
}
const F = /* @__PURE__ */ s("ZodUUID", (e, t) => {
  Aa.init(e, t), z.init(e, t);
});
function Wr(e) {
  return rr(F, e);
}
function Ol(e) {
  return ir(F, e);
}
function Nl(e) {
  return or(F, e);
}
function Ul(e) {
  return ar(F, e);
}
const We = /* @__PURE__ */ s("ZodURL", (e, t) => {
  Ra.init(e, t), z.init(e, t);
});
function Br(e) {
  return On(We, e);
}
function xl(e) {
  return On(We, {
    protocol: /^https?$/,
    hostname: Ho,
    ...m(e)
  });
}
const Bn = /* @__PURE__ */ s("ZodEmoji", (e, t) => {
  Ca.init(e, t), z.init(e, t);
});
function Xr(e) {
  return ur(Bn, e);
}
const Xn = /* @__PURE__ */ s("ZodNanoID", (e, t) => {
  Ja.init(e, t), z.init(e, t);
});
function qr(e) {
  return cr(Xn, e);
}
const qn = /* @__PURE__ */ s("ZodCUID", (e, t) => {
  Fa.init(e, t), z.init(e, t);
});
function Yr(e) {
  return lr(qn, e);
}
const Yn = /* @__PURE__ */ s("ZodCUID2", (e, t) => {
  Ma.init(e, t), z.init(e, t);
});
function Hr(e) {
  return sr(Yn, e);
}
const Hn = /* @__PURE__ */ s("ZodULID", (e, t) => {
  Ga.init(e, t), z.init(e, t);
});
function Qr(e) {
  return dr(Hn, e);
}
const Qn = /* @__PURE__ */ s("ZodXID", (e, t) => {
  Va.init(e, t), z.init(e, t);
});
function ei(e) {
  return mr(Qn, e);
}
const et = /* @__PURE__ */ s("ZodKSUID", (e, t) => {
  Ka.init(e, t), z.init(e, t);
});
function ni(e) {
  return fr(et, e);
}
const nt = /* @__PURE__ */ s("ZodIPv4", (e, t) => {
  Ya.init(e, t), z.init(e, t);
});
function ti(e) {
  return gr(nt, e);
}
const ri = /* @__PURE__ */ s("ZodMAC", (e, t) => {
  Qa.init(e, t), z.init(e, t);
});
function ii(e) {
  return nc(ri, e);
}
const tt = /* @__PURE__ */ s("ZodIPv6", (e, t) => {
  Ha.init(e, t), z.init(e, t);
});
function oi(e) {
  return pr(tt, e);
}
const rt = /* @__PURE__ */ s("ZodCIDRv4", (e, t) => {
  eu.init(e, t), z.init(e, t);
});
function ai(e) {
  return vr(rt, e);
}
const it = /* @__PURE__ */ s("ZodCIDRv6", (e, t) => {
  nu.init(e, t), z.init(e, t);
});
function ui(e) {
  return hr(it, e);
}
const ot = /* @__PURE__ */ s("ZodBase64", (e, t) => {
  tu.init(e, t), z.init(e, t);
});
function ci(e) {
  return $r(ot, e);
}
const at = /* @__PURE__ */ s("ZodBase64URL", (e, t) => {
  iu.init(e, t), z.init(e, t);
});
function li(e) {
  return br(at, e);
}
const ut = /* @__PURE__ */ s("ZodE164", (e, t) => {
  ou.init(e, t), z.init(e, t);
});
function si(e) {
  return _r(ut, e);
}
const ct = /* @__PURE__ */ s("ZodJWT", (e, t) => {
  uu.init(e, t), z.init(e, t);
});
function di(e) {
  return yr(ct, e);
}
const Ie = /* @__PURE__ */ s("ZodCustomStringFormat", (e, t) => {
  cu.init(e, t), z.init(e, t);
});
function Pl(e, t, i = {}) {
  return Ve(Ie, e, t, i);
}
function Zl(e) {
  return Ve(Ie, "hostname", Yo, e);
}
function Dl(e) {
  return Ve(Ie, "hex", ga, e);
}
function Tl(e, t) {
  const i = t?.enc ?? "hex", r = `${e}_${i}`, n = Sn[r];
  if (!n)
    throw new Error(`Unrecognized hash format: ${r}`);
  return Ve(Ie, r, n, t);
}
const Be = /* @__PURE__ */ s("ZodNumber", (e, t) => {
  Bt.init(e, t), b.init(e, t), e._zod.processJSONSchema = (r, n, o) => Cc(e, r, n), e.gt = (r, n) => e.check(ee(r, n)), e.gte = (r, n) => e.check(N(r, n)), e.min = (r, n) => e.check(N(r, n)), e.lt = (r, n) => e.check(Q(r, n)), e.lte = (r, n) => e.check(A(r, n)), e.max = (r, n) => e.check(A(r, n)), e.int = (r) => e.check(pn(r)), e.safe = (r) => e.check(pn(r)), e.positive = (r) => e.check(ee(0, r)), e.nonnegative = (r) => e.check(N(0, r)), e.negative = (r) => e.check(Q(0, r)), e.nonpositive = (r) => e.check(A(0, r)), e.multipleOf = (r, n) => e.check(pe(r, n)), e.step = (r, n) => e.check(pe(r, n)), e.finite = () => e;
  const i = e._zod.bag;
  e.minValue = Math.max(i.minimum ?? Number.NEGATIVE_INFINITY, i.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null, e.maxValue = Math.min(i.maximum ?? Number.POSITIVE_INFINITY, i.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null, e.isInt = (i.format ?? "").includes("int") || Number.isSafeInteger(i.multipleOf ?? 0.5), e.isFinite = !0, e.format = i.format ?? null;
});
function Ue(e) {
  return ac(Be, e);
}
const se = /* @__PURE__ */ s("ZodNumberFormat", (e, t) => {
  lu.init(e, t), Be.init(e, t);
});
function pn(e) {
  return cc(se, e);
}
function El(e) {
  return lc(se, e);
}
function Al(e) {
  return sc(se, e);
}
function Ll(e) {
  return dc(se, e);
}
function Rl(e) {
  return mc(se, e);
}
const Xe = /* @__PURE__ */ s("ZodBoolean", (e, t) => {
  Xt.init(e, t), b.init(e, t), e._zod.processJSONSchema = (i, r, n) => Jc(e, i, r);
});
function qe(e) {
  return fc(Xe, e);
}
const Ye = /* @__PURE__ */ s("ZodBigInt", (e, t) => {
  qt.init(e, t), b.init(e, t), e._zod.processJSONSchema = (r, n, o) => Fc(e, r), e.gte = (r, n) => e.check(N(r, n)), e.min = (r, n) => e.check(N(r, n)), e.gt = (r, n) => e.check(ee(r, n)), e.gte = (r, n) => e.check(N(r, n)), e.min = (r, n) => e.check(N(r, n)), e.lt = (r, n) => e.check(Q(r, n)), e.lte = (r, n) => e.check(A(r, n)), e.max = (r, n) => e.check(A(r, n)), e.positive = (r) => e.check(ee(BigInt(0), r)), e.negative = (r) => e.check(Q(BigInt(0), r)), e.nonpositive = (r) => e.check(A(BigInt(0), r)), e.nonnegative = (r) => e.check(N(BigInt(0), r)), e.multipleOf = (r, n) => e.check(pe(r, n));
  const i = e._zod.bag;
  e.minValue = i.minimum ?? null, e.maxValue = i.maximum ?? null, e.format = i.format ?? null;
});
function Cl(e) {
  return pc(Ye, e);
}
const lt = /* @__PURE__ */ s("ZodBigIntFormat", (e, t) => {
  su.init(e, t), Ye.init(e, t);
});
function Jl(e) {
  return hc(lt, e);
}
function Fl(e) {
  return $c(lt, e);
}
const mi = /* @__PURE__ */ s("ZodSymbol", (e, t) => {
  du.init(e, t), b.init(e, t), e._zod.processJSONSchema = (i, r, n) => Mc(e, i);
});
function Ml(e) {
  return bc(mi, e);
}
const fi = /* @__PURE__ */ s("ZodUndefined", (e, t) => {
  mu.init(e, t), b.init(e, t), e._zod.processJSONSchema = (i, r, n) => Vc(e, i);
});
function Gl(e) {
  return _c(fi, e);
}
const gi = /* @__PURE__ */ s("ZodNull", (e, t) => {
  fu.init(e, t), b.init(e, t), e._zod.processJSONSchema = (i, r, n) => Gc(e, i, r);
});
function xe(e) {
  return yc(gi, e);
}
const pi = /* @__PURE__ */ s("ZodAny", (e, t) => {
  gu.init(e, t), b.init(e, t), e._zod.processJSONSchema = (i, r, n) => Bc();
});
function H() {
  return kc(pi);
}
const vi = /* @__PURE__ */ s("ZodUnknown", (e, t) => {
  pu.init(e, t), b.init(e, t), e._zod.processJSONSchema = (i, r, n) => Xc();
});
function ne() {
  return Ic(vi);
}
const hi = /* @__PURE__ */ s("ZodNever", (e, t) => {
  vu.init(e, t), b.init(e, t), e._zod.processJSONSchema = (i, r, n) => Wc(e, i, r);
});
function V(e) {
  return zc(hi, e);
}
const $i = /* @__PURE__ */ s("ZodVoid", (e, t) => {
  hu.init(e, t), b.init(e, t), e._zod.processJSONSchema = (i, r, n) => Kc(e, i);
});
function bi(e) {
  return Sc($i, e);
}
const st = /* @__PURE__ */ s("ZodDate", (e, t) => {
  $u.init(e, t), b.init(e, t), e._zod.processJSONSchema = (r, n, o) => qc(e, r), e.min = (r, n) => e.check(N(r, n)), e.max = (r, n) => e.check(A(r, n));
  const i = e._zod.bag;
  e.minDate = i.minimum ? new Date(i.minimum) : null, e.maxDate = i.maximum ? new Date(i.maximum) : null;
});
function Vl(e) {
  return wc(st, e);
}
const _i = /* @__PURE__ */ s("ZodArray", (e, t) => {
  bu.init(e, t), b.init(e, t), e._zod.processJSONSchema = (i, r, n) => cl(e, i, r, n), e.element = t.element, e.min = (i, r) => e.check(B(i, r)), e.nonempty = (i) => e.check(B(1, i)), e.max = (i, r) => e.check(ue(i, r)), e.length = (i, r) => e.check(Ge(i, r)), e.unwrap = () => e.element;
});
function X(e, t) {
  return Nc(_i, e, t);
}
function Kl(e) {
  const t = e._zod.def.shape;
  return nn(Object.keys(t));
}
const He = /* @__PURE__ */ s("ZodObject", (e, t) => {
  Iu.init(e, t), b.init(e, t), e._zod.processJSONSchema = (i, r, n) => ll(e, i, r, n), _(e, "shape", () => t.shape), e.keyof = () => nn(Object.keys(e._zod.def.shape)), e.catchall = (i) => e.clone({ ...e._zod.def, catchall: i }), e.passthrough = () => e.clone({ ...e._zod.def, catchall: ne() }), e.loose = () => e.clone({ ...e._zod.def, catchall: ne() }), e.strict = () => e.clone({ ...e._zod.def, catchall: V() }), e.strip = () => e.clone({ ...e._zod.def, catchall: void 0 }), e.extend = (i) => Io(e, i), e.safeExtend = (i) => zo(e, i), e.merge = (i) => So(e, i), e.pick = (i) => yo(e, i), e.omit = (i) => ko(e, i), e.partial = (...i) => wo(ft, e, i[0]), e.required = (...i) => jo(gt, e, i[0]);
});
function P(e, t) {
  const i = {
    type: "object",
    shape: e ?? {},
    ...m(t)
  };
  return new He(i);
}
function Wl(e, t) {
  return new He({
    type: "object",
    shape: e,
    catchall: V(),
    ...m(t)
  });
}
function Bl(e, t) {
  return new He({
    type: "object",
    shape: e,
    catchall: ne(),
    ...m(t)
  });
}
const Qe = /* @__PURE__ */ s("ZodUnion", (e, t) => {
  wn.init(e, t), b.init(e, t), e._zod.processJSONSchema = (i, r, n) => Or(e, i, r, n), e.options = t.options;
});
function ce(e, t) {
  return new Qe({
    type: "union",
    options: e,
    ...m(t)
  });
}
const yi = /* @__PURE__ */ s("ZodXor", (e, t) => {
  Qe.init(e, t), zu.init(e, t), e._zod.processJSONSchema = (i, r, n) => Or(e, i, r, n), e.options = t.options;
});
function ki(e, t) {
  return new yi({
    type: "union",
    options: e,
    inclusive: !1,
    ...m(t)
  });
}
const Ii = /* @__PURE__ */ s("ZodDiscriminatedUnion", (e, t) => {
  Qe.init(e, t), Su.init(e, t);
});
function Xl(e, t, i) {
  return new Ii({
    type: "union",
    options: t,
    discriminator: e,
    ...m(i)
  });
}
const zi = /* @__PURE__ */ s("ZodIntersection", (e, t) => {
  wu.init(e, t), b.init(e, t), e._zod.processJSONSchema = (i, r, n) => sl(e, i, r, n);
});
function K(e, t) {
  return new zi({
    type: "intersection",
    left: e,
    right: t
  });
}
const Si = /* @__PURE__ */ s("ZodTuple", (e, t) => {
  Yt.init(e, t), b.init(e, t), e._zod.processJSONSchema = (i, r, n) => dl(e, i, r, n), e.rest = (i) => e.clone({
    ...e._zod.def,
    rest: i
  });
});
function G(e, t, i) {
  const r = t instanceof $, n = r ? i : t, o = r ? t : null;
  return new Si({
    type: "tuple",
    items: e,
    rest: o,
    ...m(n)
  });
}
const en = /* @__PURE__ */ s("ZodRecord", (e, t) => {
  ju.init(e, t), b.init(e, t), e._zod.processJSONSchema = (i, r, n) => ml(e, i, r, n), e.keyType = t.keyType, e.valueType = t.valueType;
});
function dt(e, t, i) {
  return new en({
    type: "record",
    keyType: e,
    valueType: t,
    ...m(i)
  });
}
function ql(e, t, i) {
  const r = Z(e);
  return r._zod.values = void 0, new en({
    type: "record",
    keyType: r,
    valueType: t,
    ...m(i)
  });
}
function vn(e, t, i) {
  return new en({
    type: "record",
    keyType: e,
    valueType: t,
    mode: "loose",
    ...m(i)
  });
}
const wi = /* @__PURE__ */ s("ZodMap", (e, t) => {
  Ou.init(e, t), b.init(e, t), e._zod.processJSONSchema = (i, r, n) => al(e, i), e.keyType = t.keyType, e.valueType = t.valueType;
});
function Yl(e, t, i) {
  return new wi({
    type: "map",
    keyType: e,
    valueType: t,
    ...m(i)
  });
}
const ji = /* @__PURE__ */ s("ZodSet", (e, t) => {
  Nu.init(e, t), b.init(e, t), e._zod.processJSONSchema = (i, r, n) => ul(e, i), e.min = (...i) => e.check(ve(...i)), e.nonempty = (i) => e.check(ve(1, i)), e.max = (...i) => e.check(Me(...i)), e.size = (...i) => e.check(Nn(...i));
});
function Hl(e, t) {
  return new ji({
    type: "set",
    valueType: e,
    ...m(t)
  });
}
const _e = /* @__PURE__ */ s("ZodEnum", (e, t) => {
  Uu.init(e, t), b.init(e, t), e._zod.processJSONSchema = (r, n, o) => Yc(e, r, n), e.enum = t.entries, e.options = Object.values(t.entries);
  const i = new Set(Object.keys(t.entries));
  e.extract = (r, n) => {
    const o = {};
    for (const a of r)
      if (i.has(a))
        o[a] = t.entries[a];
      else
        throw new Error(`Key ${a} not found in enum`);
    return new _e({
      ...t,
      checks: [],
      ...m(n),
      entries: o
    });
  }, e.exclude = (r, n) => {
    const o = { ...t.entries };
    for (const a of r)
      if (i.has(a))
        delete o[a];
      else
        throw new Error(`Key ${a} not found in enum`);
    return new _e({
      ...t,
      checks: [],
      ...m(n),
      entries: o
    });
  };
});
function nn(e, t) {
  const i = Array.isArray(e) ? Object.fromEntries(e.map((r) => [r, r])) : e;
  return new _e({
    type: "enum",
    entries: i,
    ...m(t)
  });
}
function Ql(e, t) {
  return new _e({
    type: "enum",
    entries: e,
    ...m(t)
  });
}
const Oi = /* @__PURE__ */ s("ZodLiteral", (e, t) => {
  xu.init(e, t), b.init(e, t), e._zod.processJSONSchema = (i, r, n) => Hc(e, i, r), e.values = new Set(t.values), Object.defineProperty(e, "value", {
    get() {
      if (t.values.length > 1)
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      return t.values[0];
    }
  });
});
function oe(e, t) {
  return new Oi({
    type: "literal",
    values: Array.isArray(e) ? e : [e],
    ...m(t)
  });
}
const Ni = /* @__PURE__ */ s("ZodFile", (e, t) => {
  Pu.init(e, t), b.init(e, t), e._zod.processJSONSchema = (i, r, n) => nl(e, i, r), e.min = (i, r) => e.check(ve(i, r)), e.max = (i, r) => e.check(Me(i, r)), e.mime = (i, r) => e.check(En(Array.isArray(i) ? i : [i], r));
});
function es(e) {
  return Uc(Ni, e);
}
const Ui = /* @__PURE__ */ s("ZodTransform", (e, t) => {
  Zu.init(e, t), b.init(e, t), e._zod.processJSONSchema = (i, r, n) => ol(e, i), e._zod.parse = (i, r) => {
    if (r.direction === "backward")
      throw new $n(e.constructor.name);
    i.addIssue = (o) => {
      if (typeof o == "string")
        i.issues.push(fe(o, i.value, t));
      else {
        const a = o;
        a.fatal && (a.continue = !1), a.code ?? (a.code = "custom"), a.input ?? (a.input = i.value), a.inst ?? (a.inst = e), i.issues.push(fe(a));
      }
    };
    const n = t.transform(i.value, i);
    return n instanceof Promise ? n.then((o) => (i.value = o, i)) : (i.value = n, i);
  };
});
function mt(e) {
  return new Ui({
    type: "transform",
    transform: e
  });
}
const ft = /* @__PURE__ */ s("ZodOptional", (e, t) => {
  Du.init(e, t), b.init(e, t), e._zod.processJSONSchema = (i, r, n) => yl(e, i, r, n), e.unwrap = () => e._zod.def.innerType;
});
function Pe(e) {
  return new ft({
    type: "optional",
    innerType: e
  });
}
const xi = /* @__PURE__ */ s("ZodNullable", (e, t) => {
  Tu.init(e, t), b.init(e, t), e._zod.processJSONSchema = (i, r, n) => fl(e, i, r, n), e.unwrap = () => e._zod.def.innerType;
});
function ye(e) {
  return new xi({
    type: "nullable",
    innerType: e
  });
}
function ns(e) {
  return Pe(ye(e));
}
const Pi = /* @__PURE__ */ s("ZodDefault", (e, t) => {
  Eu.init(e, t), b.init(e, t), e._zod.processJSONSchema = (i, r, n) => pl(e, i, r, n), e.unwrap = () => e._zod.def.innerType, e.removeDefault = e.unwrap;
});
function Zi(e, t) {
  return new Pi({
    type: "default",
    innerType: e,
    get defaultValue() {
      return typeof t == "function" ? t() : _n(t);
    }
  });
}
const Di = /* @__PURE__ */ s("ZodPrefault", (e, t) => {
  Au.init(e, t), b.init(e, t), e._zod.processJSONSchema = (i, r, n) => vl(e, i, r, n), e.unwrap = () => e._zod.def.innerType;
});
function Ti(e, t) {
  return new Di({
    type: "prefault",
    innerType: e,
    get defaultValue() {
      return typeof t == "function" ? t() : _n(t);
    }
  });
}
const gt = /* @__PURE__ */ s("ZodNonOptional", (e, t) => {
  Lu.init(e, t), b.init(e, t), e._zod.processJSONSchema = (i, r, n) => gl(e, i, r, n), e.unwrap = () => e._zod.def.innerType;
});
function Ei(e, t) {
  return new gt({
    type: "nonoptional",
    innerType: e,
    ...m(t)
  });
}
const Ai = /* @__PURE__ */ s("ZodSuccess", (e, t) => {
  Ru.init(e, t), b.init(e, t), e._zod.processJSONSchema = (i, r, n) => tl(e, i, r), e.unwrap = () => e._zod.def.innerType;
});
function ts(e) {
  return new Ai({
    type: "success",
    innerType: e
  });
}
const Li = /* @__PURE__ */ s("ZodCatch", (e, t) => {
  Cu.init(e, t), b.init(e, t), e._zod.processJSONSchema = (i, r, n) => hl(e, i, r, n), e.unwrap = () => e._zod.def.innerType, e.removeCatch = e.unwrap;
});
function Ri(e, t) {
  return new Li({
    type: "catch",
    innerType: e,
    catchValue: typeof t == "function" ? t : () => t
  });
}
const Ci = /* @__PURE__ */ s("ZodNaN", (e, t) => {
  Ju.init(e, t), b.init(e, t), e._zod.processJSONSchema = (i, r, n) => Qc(e, i);
});
function rs(e) {
  return Oc(Ci, e);
}
const pt = /* @__PURE__ */ s("ZodPipe", (e, t) => {
  Fu.init(e, t), b.init(e, t), e._zod.processJSONSchema = (i, r, n) => $l(e, i, r, n), e.in = t.in, e.out = t.out;
});
function Ze(e, t) {
  return new pt({
    type: "pipe",
    in: e,
    out: t
    // ...util.normalizeParams(params),
  });
}
const vt = /* @__PURE__ */ s("ZodCodec", (e, t) => {
  pt.init(e, t), Ht.init(e, t);
});
function is(e, t, i) {
  return new vt({
    type: "pipe",
    in: e,
    out: t,
    transform: i.decode,
    reverseTransform: i.encode
  });
}
const Ji = /* @__PURE__ */ s("ZodReadonly", (e, t) => {
  Mu.init(e, t), b.init(e, t), e._zod.processJSONSchema = (i, r, n) => bl(e, i, r, n), e.unwrap = () => e._zod.def.innerType;
});
function ht(e) {
  return new Ji({
    type: "readonly",
    innerType: e
  });
}
const Fi = /* @__PURE__ */ s("ZodTemplateLiteral", (e, t) => {
  Gu.init(e, t), b.init(e, t), e._zod.processJSONSchema = (i, r, n) => el(e, i, r);
});
function os(e, t) {
  return new Fi({
    type: "template_literal",
    parts: e,
    ...m(t)
  });
}
const Mi = /* @__PURE__ */ s("ZodLazy", (e, t) => {
  Wu.init(e, t), b.init(e, t), e._zod.processJSONSchema = (i, r, n) => kl(e, i, r, n), e.unwrap = () => e._zod.def.getter();
});
function $t(e) {
  return new Mi({
    type: "lazy",
    getter: e
  });
}
const Gi = /* @__PURE__ */ s("ZodPromise", (e, t) => {
  Ku.init(e, t), b.init(e, t), e._zod.processJSONSchema = (i, r, n) => _l(e, i, r, n), e.unwrap = () => e._zod.def.innerType;
});
function as(e) {
  return new Gi({
    type: "promise",
    innerType: e
  });
}
const Vi = /* @__PURE__ */ s("ZodFunction", (e, t) => {
  Vu.init(e, t), b.init(e, t), e._zod.processJSONSchema = (i, r, n) => il(e, i);
});
function ke(e) {
  return new Vi({
    type: "function",
    input: Array.isArray(e?.input) ? G(e?.input) : e?.input ?? X(ne()),
    output: e?.output ?? ne()
  });
}
const tn = /* @__PURE__ */ s("ZodCustom", (e, t) => {
  Bu.init(e, t), b.init(e, t), e._zod.processJSONSchema = (i, r, n) => rl(e, i);
});
function us(e) {
  const t = new S({
    check: "custom"
    // ...util.normalizeParams(params),
  });
  return t._zod.check = e, t;
}
function bt(e, t) {
  return xc(tn, e ?? (() => !0), t);
}
function Ki(e, t = {}) {
  return Pc(tn, e, t);
}
function Wi(e) {
  return Zc(e);
}
const cs = Tc, ls = Ec;
function ss(e, t = {
  error: `Input not instance of ${e.name}`
}) {
  const i = new tn({
    type: "custom",
    check: "custom",
    fn: (r) => r instanceof e,
    abort: !0,
    ...m(t)
  });
  return i._zod.bag.Class = e, i;
}
const ds = (...e) => Ac({
  Codec: vt,
  Boolean: Xe,
  String: Ke
}, ...e);
function ms(e) {
  const t = $t(() => ce([x(e), Ue(), qe(), xe(), X(t), dt(x(), t)]));
  return t;
}
function fs(e, t) {
  return Ze(mt(e), t);
}
const gs = {
  invalid_type: "invalid_type",
  too_big: "too_big",
  too_small: "too_small",
  invalid_format: "invalid_format",
  not_multiple_of: "not_multiple_of",
  unrecognized_keys: "unrecognized_keys",
  invalid_union: "invalid_union",
  invalid_key: "invalid_key",
  invalid_element: "invalid_element",
  invalid_value: "invalid_value",
  custom: "custom"
};
function ps(e) {
  w({
    customError: e
  });
}
function vs() {
  return w().customError;
}
var hn;
hn || (hn = {});
function Df(e, t) {
  const i = e.$schema;
  return i === "https://json-schema.org/draft/2020-12/schema" ? "draft-2020-12" : i === "http://json-schema.org/draft-07/schema#" ? "draft-7" : i === "http://json-schema.org/draft-04/schema#" ? "draft-4" : t ?? "draft-2020-12";
}
function Tf(e, t) {
  if (!e.startsWith("#"))
    throw new Error("External $ref is not supported, only local refs (#/...) are allowed");
  const i = e.slice(1).split("/").filter(Boolean);
  if (i.length === 0)
    return t.rootSchema;
  const r = t.version === "draft-2020-12" ? "$defs" : "definitions";
  if (i[0] === r) {
    const n = i[1];
    if (!n || !t.defs[n])
      throw new Error(`Reference not found: ${e}`);
    return t.defs[n];
  }
  throw new Error(`Reference not found: ${e}`);
}
function hs(e, t) {
  if (e.not !== void 0) {
    if (typeof e.not == "object" && Object.keys(e.not).length === 0)
      return V();
    throw new Error("not is not supported in Zod (except { not: {} } for never)");
  }
  if (e.unevaluatedItems !== void 0)
    throw new Error("unevaluatedItems is not supported");
  if (e.unevaluatedProperties !== void 0)
    throw new Error("unevaluatedProperties is not supported");
  if (e.if !== void 0 || e.then !== void 0 || e.else !== void 0)
    throw new Error("Conditional schemas (if/then/else) are not supported");
  if (e.dependentSchemas !== void 0 || e.dependentRequired !== void 0)
    throw new Error("dependentSchemas and dependentRequired are not supported");
  if (e.$ref) {
    const n = e.$ref;
    if (t.refs.has(n))
      return t.refs.get(n);
    if (t.processing.has(n))
      return $t(() => {
        if (!t.refs.has(n))
          throw new Error(`Circular reference not resolved: ${n}`);
        return t.refs.get(n);
      });
    t.processing.add(n);
    const o = Tf(n, t), a = j(o, t);
    return t.refs.set(n, a), t.processing.delete(n), a;
  }
  if (e.enum !== void 0) {
    const n = e.enum;
    if (t.version === "openapi-3.0" && e.nullable === !0 && n.length === 1 && n[0] === null)
      return xe();
    if (n.length === 0)
      return V();
    if (n.length === 1)
      return oe(n[0]);
    if (n.every((a) => typeof a == "string"))
      return nn(n);
    const o = n.map((a) => oe(a));
    return o.length < 2 ? o[0] : ce([o[0], o[1], ...o.slice(2)]);
  }
  if (e.const !== void 0)
    return oe(e.const);
  const i = e.type;
  if (Array.isArray(i)) {
    const n = i.map((o) => {
      const a = { ...e, type: o };
      return hs(a, t);
    });
    return n.length === 0 ? V() : n.length === 1 ? n[0] : ce(n);
  }
  if (!i)
    return H();
  let r;
  switch (i) {
    case "string": {
      let n = x();
      if (e.format) {
        const o = e.format;
        o === "email" ? n = n.check(Kr()) : o === "uri" || o === "uri-reference" ? n = n.check(Br()) : o === "uuid" || o === "guid" ? n = n.check(Wr()) : o === "date-time" ? n = n.check(Ur()) : o === "date" ? n = n.check(xr()) : o === "time" ? n = n.check(Pr()) : o === "duration" ? n = n.check(Zr()) : o === "ipv4" ? n = n.check(ti()) : o === "ipv6" ? n = n.check(oi()) : o === "mac" ? n = n.check(ii()) : o === "cidr" ? n = n.check(ai()) : o === "cidr-v6" ? n = n.check(ui()) : o === "base64" ? n = n.check(ci()) : o === "base64url" ? n = n.check(li()) : o === "e164" ? n = n.check(si()) : o === "jwt" ? n = n.check(di()) : o === "emoji" ? n = n.check(Xr()) : o === "nanoid" ? n = n.check(qr()) : o === "cuid" ? n = n.check(Yr()) : o === "cuid2" ? n = n.check(Hr()) : o === "ulid" ? n = n.check(Qr()) : o === "xid" ? n = n.check(ei()) : o === "ksuid" && (n = n.check(ni()));
      }
      typeof e.minLength == "number" && (n = n.min(e.minLength)), typeof e.maxLength == "number" && (n = n.max(e.maxLength)), e.pattern && (n = n.regex(new RegExp(e.pattern))), r = n;
      break;
    }
    case "number":
    case "integer": {
      let n = i === "integer" ? Ue().int() : Ue();
      typeof e.minimum == "number" && (n = n.min(e.minimum)), typeof e.maximum == "number" && (n = n.max(e.maximum)), typeof e.exclusiveMinimum == "number" ? n = n.gt(e.exclusiveMinimum) : e.exclusiveMinimum === !0 && typeof e.minimum == "number" && (n = n.gt(e.minimum)), typeof e.exclusiveMaximum == "number" ? n = n.lt(e.exclusiveMaximum) : e.exclusiveMaximum === !0 && typeof e.maximum == "number" && (n = n.lt(e.maximum)), typeof e.multipleOf == "number" && (n = n.multipleOf(e.multipleOf)), r = n;
      break;
    }
    case "boolean": {
      r = qe();
      break;
    }
    case "null": {
      r = xe();
      break;
    }
    case "object": {
      const n = {}, o = e.properties || {}, a = new Set(e.required || []);
      for (const [l, c] of Object.entries(o)) {
        const d = j(c, t);
        n[l] = a.has(l) ? d : d.optional();
      }
      if (e.propertyNames) {
        const l = j(e.propertyNames, t), c = e.additionalProperties && typeof e.additionalProperties == "object" ? j(e.additionalProperties, t) : H();
        if (Object.keys(n).length === 0) {
          r = dt(l, c);
          break;
        }
        const d = P(n).passthrough(), f = vn(l, c);
        r = K(d, f);
        break;
      }
      if (e.patternProperties) {
        const l = e.patternProperties, c = Object.keys(l), d = [];
        for (const p of c) {
          const v = j(l[p], t), y = x().regex(new RegExp(p));
          d.push(vn(y, v));
        }
        const f = [];
        if (Object.keys(n).length > 0 && f.push(P(n).passthrough()), f.push(...d), f.length === 0)
          r = P({}).passthrough();
        else if (f.length === 1)
          r = f[0];
        else {
          let p = K(f[0], f[1]);
          for (let v = 2; v < f.length; v++)
            p = K(p, f[v]);
          r = p;
        }
        break;
      }
      const u = P(n);
      e.additionalProperties === !1 ? r = u.strict() : typeof e.additionalProperties == "object" ? r = u.catchall(j(e.additionalProperties, t)) : r = u.passthrough();
      break;
    }
    case "array": {
      const n = e.prefixItems, o = e.items;
      if (n && Array.isArray(n)) {
        const a = n.map((l) => j(l, t)), u = o && typeof o == "object" && !Array.isArray(o) ? j(o, t) : void 0;
        u ? r = G(a).rest(u) : r = G(a), typeof e.minItems == "number" && (r = r.check(B(e.minItems))), typeof e.maxItems == "number" && (r = r.check(ue(e.maxItems)));
      } else if (Array.isArray(o)) {
        const a = o.map((l) => j(l, t)), u = e.additionalItems && typeof e.additionalItems == "object" ? j(e.additionalItems, t) : void 0;
        u ? r = G(a).rest(u) : r = G(a), typeof e.minItems == "number" && (r = r.check(B(e.minItems))), typeof e.maxItems == "number" && (r = r.check(ue(e.maxItems)));
      } else if (o !== void 0) {
        const a = j(o, t);
        let u = X(a);
        typeof e.minItems == "number" && (u = u.min(e.minItems)), typeof e.maxItems == "number" && (u = u.max(e.maxItems)), r = u;
      } else
        r = X(H());
      break;
    }
    default:
      throw new Error(`Unsupported type: ${i}`);
  }
  return e.description && (r = r.describe(e.description)), e.default !== void 0 && (r = r.default(e.default)), r;
}
function j(e, t) {
  if (typeof e == "boolean")
    return e ? H() : V();
  let i = hs(e, t);
  const r = e.type || e.enum !== void 0 || e.const !== void 0;
  if (e.anyOf && Array.isArray(e.anyOf)) {
    const n = e.anyOf.map((a) => j(a, t)), o = ce(n);
    i = r ? K(i, o) : o;
  }
  if (e.oneOf && Array.isArray(e.oneOf)) {
    const n = e.oneOf.map((a) => j(a, t)), o = ki(n);
    i = r ? K(i, o) : o;
  }
  if (e.allOf && Array.isArray(e.allOf))
    if (e.allOf.length === 0)
      i = r ? i : H();
    else {
      let n = r ? i : j(e.allOf[0], t);
      const o = r ? 0 : 1;
      for (let a = o; a < e.allOf.length; a++)
        n = K(n, j(e.allOf[a], t));
      i = n;
    }
  return e.nullable === !0 && t.version === "openapi-3.0" && (i = ye(i)), e.readOnly === !0 && (i = ht(i)), i;
}
function $s(e, t) {
  if (typeof e == "boolean")
    return e ? H() : V();
  const i = Df(e, t?.defaultTarget), r = e.$defs || e.definitions || {};
  return j(e, {
    version: i,
    defs: r,
    refs: /* @__PURE__ */ new Map(),
    processing: /* @__PURE__ */ new Set(),
    rootSchema: e
  });
}
function Ef(e) {
  return ec(Ke, e);
}
function Af(e) {
  return uc(Be, e);
}
function Lf(e) {
  return gc(Xe, e);
}
function Rf(e) {
  return vc(Ye, e);
}
function Cf(e) {
  return jc(st, e);
}
const bs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bigint: Rf,
  boolean: Lf,
  date: Cf,
  number: Af,
  string: Ef
}, Symbol.toStringTag, { value: "Module" }));
w(Xu());
const Jf = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  $brand: Nt,
  $input: nr,
  $output: er,
  NEVER: Ot,
  TimePrecision: kr,
  ZodAny: pi,
  ZodArray: _i,
  ZodBase64: ot,
  ZodBase64URL: at,
  ZodBigInt: Ye,
  ZodBigIntFormat: lt,
  ZodBoolean: Xe,
  ZodCIDRv4: rt,
  ZodCIDRv6: it,
  ZodCUID: qn,
  ZodCUID2: Yn,
  ZodCatch: Li,
  ZodCodec: vt,
  ZodCustom: tn,
  ZodCustomStringFormat: Ie,
  ZodDate: st,
  ZodDefault: Pi,
  ZodDiscriminatedUnion: Ii,
  ZodE164: ut,
  ZodEmail: Wn,
  ZodEmoji: Bn,
  ZodEnum: _e,
  ZodError: wl,
  ZodFile: Ni,
  get ZodFirstPartyTypeKind() {
    return hn;
  },
  ZodFunction: Vi,
  ZodGUID: Ne,
  ZodIPv4: nt,
  ZodIPv6: tt,
  ZodISODate: Mn,
  ZodISODateTime: Fn,
  ZodISODuration: Vn,
  ZodISOTime: Gn,
  ZodIntersection: zi,
  ZodIssueCode: gs,
  ZodJWT: ct,
  ZodKSUID: et,
  ZodLazy: Mi,
  ZodLiteral: Oi,
  ZodMAC: ri,
  ZodMap: wi,
  ZodNaN: Ci,
  ZodNanoID: Xn,
  ZodNever: hi,
  ZodNonOptional: gt,
  ZodNull: gi,
  ZodNullable: xi,
  ZodNumber: Be,
  ZodNumberFormat: se,
  ZodObject: He,
  ZodOptional: ft,
  ZodPipe: pt,
  ZodPrefault: Di,
  ZodPromise: Gi,
  ZodReadonly: Ji,
  ZodRealError: U,
  ZodRecord: en,
  ZodSet: ji,
  ZodString: Ke,
  ZodStringFormat: z,
  ZodSuccess: Ai,
  ZodSymbol: mi,
  ZodTemplateLiteral: Fi,
  ZodTransform: Ui,
  ZodTuple: Si,
  ZodType: b,
  ZodULID: Hn,
  ZodURL: We,
  ZodUUID: F,
  ZodUndefined: fi,
  ZodUnion: Qe,
  ZodUnknown: vi,
  ZodVoid: $i,
  ZodXID: Qn,
  ZodXor: yi,
  _ZodString: Kn,
  _default: Zi,
  _function: ke,
  any: H,
  array: X,
  base64: ci,
  base64url: li,
  bigint: Cl,
  boolean: qe,
  catch: Ri,
  check: us,
  cidrv4: ai,
  cidrv6: ui,
  clone: Z,
  codec: is,
  coerce: bs,
  config: w,
  core: Il,
  cuid: Yr,
  cuid2: Hr,
  custom: bt,
  date: Vl,
  decode: Rr,
  decodeAsync: Jr,
  default: Bi,
  describe: cs,
  discriminatedUnion: Xl,
  e164: si,
  email: Kr,
  emoji: Xr,
  encode: Lr,
  encodeAsync: Cr,
  endsWith: Tn,
  enum: nn,
  file: es,
  flattenError: In,
  float32: El,
  float64: Al,
  formatError: zn,
  fromJSONSchema: $s,
  function: ke,
  getErrorMap: vs,
  globalRegistry: E,
  gt: ee,
  gte: N,
  guid: jl,
  hash: Tl,
  hex: Dl,
  hostname: Zl,
  httpUrl: xl,
  includes: Zn,
  instanceof: ss,
  int: pn,
  int32: Ll,
  int64: Jl,
  intersection: K,
  ipv4: ti,
  ipv6: oi,
  iso: zl,
  json: ms,
  jwt: di,
  keyof: Kl,
  ksuid: ni,
  lazy: $t,
  length: Ge,
  literal: oe,
  locales: Qt,
  looseObject: Bl,
  looseRecord: vn,
  lowercase: xn,
  lt: Q,
  lte: A,
  mac: ii,
  map: Yl,
  maxLength: ue,
  maxSize: Me,
  meta: ls,
  mime: En,
  minLength: B,
  minSize: ve,
  multipleOf: pe,
  nan: rs,
  nanoid: qr,
  nativeEnum: Ql,
  negative: zr,
  never: V,
  nonnegative: wr,
  nonoptional: Ei,
  nonpositive: Sr,
  normalize: An,
  null: xe,
  nullable: ye,
  nullish: ns,
  number: Ue,
  object: P,
  optional: Pe,
  overwrite: Y,
  parse: Dr,
  parseAsync: Tr,
  partialRecord: ql,
  pipe: Ze,
  positive: Ir,
  prefault: Ti,
  preprocess: fs,
  prettifyError: Tt,
  promise: as,
  property: jr,
  readonly: ht,
  record: dt,
  refine: Ki,
  regex: Un,
  regexes: Sn,
  registry: jn,
  safeDecode: Mr,
  safeDecodeAsync: Vr,
  safeEncode: Fr,
  safeEncodeAsync: Gr,
  safeParse: Er,
  safeParseAsync: Ar,
  set: Hl,
  setErrorMap: ps,
  size: Nn,
  slugify: Jn,
  startsWith: Dn,
  strictObject: Wl,
  string: x,
  stringFormat: Pl,
  stringbool: ds,
  success: ts,
  superRefine: Wi,
  symbol: Ml,
  templateLiteral: os,
  toJSONSchema: Nr,
  toLowerCase: Rn,
  toUpperCase: Cn,
  transform: mt,
  treeifyError: Dt,
  trim: Ln,
  tuple: G,
  uint32: Rl,
  uint64: Fl,
  ulid: Qr,
  undefined: Gl,
  union: ce,
  unknown: ne,
  uppercase: Pn,
  url: Br,
  util: Pt,
  uuid: Wr,
  uuidv4: Ol,
  uuidv6: Nl,
  uuidv7: Ul,
  void: bi,
  xid: ei,
  xor: ki,
  z: Bi
}, Symbol.toStringTag, { value: "Module" })), _t = ke({
  input: G([
    P({
      editor: bt((e) => e !== void 0),
      linkBrowserUrl: x()
    })
  ]),
  output: qe()
}), fo = ke({
  input: G([
    P({
      editor: bt((e) => e !== void 0),
      linkBrowserUrl: x()
    })
  ]),
  output: bi()
}), Ff = P({
  id: x(),
  label: x(),
  iconIdentifier: x(),
  position: P({
    toolbarGroupId: x().or(oe(!1)),
    bubbleMenuGroupId: x().or(oe(!1))
  }),
  status: P({
    isActive: _t.optional(),
    isDisabled: _t.optional(),
    isVisible: _t.optional()
  }).optional(),
  hooks: P({
    onEditorMounted: fo.optional()
  }).optional(),
  onExecute: fo
}), Mf = P({
  commands: X(Ff).optional(),
  extensions: X(ne()).optional()
}), ln = (e) => {
  if (typeof e == "object" && e !== null) {
    if (typeof Object.getPrototypeOf == "function") {
      const t = Object.getPrototypeOf(e);
      return t === Object.prototype || t === null;
    }
    return Object.prototype.toString.call(e) === "[object Object]";
  }
  return !1;
}, R = (...e) => e.reduce((t, i) => {
  if (i === void 0)
    return t;
  if (Array.isArray(i))
    throw new TypeError("Arguments provided to ts-deepmerge must be objects, not arrays.");
  return Object.keys(i).forEach((r) => {
    ["__proto__", "constructor", "prototype"].includes(r) || (Array.isArray(t[r]) && Array.isArray(i[r]) ? t[r] = R.options.mergeArrays ? R.options.uniqueArrayItems ? Array.from(new Set(t[r].concat(i[r]))) : [...t[r], ...i[r]] : i[r] : ln(t[r]) && ln(i[r]) ? t[r] = R(t[r], i[r]) : !ln(t[r]) && ln(i[r]) ? t[r] = R(i[r], void 0) : t[r] = i[r] === void 0 ? R.options.allowUndefinedOverrides ? i[r] : t[r] : i[r]);
  }), t;
}, {}), wt = {
  allowUndefinedOverrides: !0,
  mergeArrays: !0,
  uniqueArrayItems: !0
};
R.options = wt;
R.withOptions = (e, ...t) => {
  R.options = Object.assign(Object.assign({}, wt), e);
  const i = R(...t);
  return R.options = wt, i;
};
function Gf(e, t) {
  return R.withOptions(
    { mergeArrays: !0, uniqueArrayItems: !0 },
    { items: e },
    { items: t }
  ).items;
}
function Kf(e, t = 300) {
  let i, r = 0, n = !1;
  return (...o) => {
    const a = Date.now();
    return (!n || a - r >= t) && (i = e(...o), r = a, n = !0), i;
  };
}
const jt = [
  {
    id: "history",
    commands: []
  },
  {
    id: "styles",
    commands: [],
    dropdown: {
      label: "Styles",
      iconIdentifier: "styles"
    }
  },
  {
    id: "heading",
    commands: [],
    dropdown: {
      label: "Headings",
      iconIdentifier: "heading"
    }
  },
  {
    id: "general",
    commands: []
  },
  {
    id: "formatting",
    commands: []
  },
  {
    id: "textAlignment",
    commands: [],
    dropdown: {
      label: "Text alignment",
      iconIdentifier: "justify-left"
    }
  },
  {
    id: "developer",
    commands: []
  }
], Vf = [
  {
    id: "formatting",
    commands: []
  },
  {
    id: "heading",
    commands: [],
    dropdown: {
      label: "Headings",
      iconIdentifier: "heading"
    }
  },
  {
    id: "styles",
    commands: [],
    dropdown: {
      label: "Styles",
      iconIdentifier: "styles"
    }
  }
], de = {
  toolbar: jt,
  bubbleMenu: Vf,
  extensions: []
};
function Wf(e) {
  const t = Mf.safeParse(e);
  if (!t.success)
    throw new Error(`Invalid TipTap plugin options: ${t.error.message}`);
  const { data: i } = t;
  i.extensions && Array.isArray(de.extensions) && (de.extensions = Gf(de.extensions, i.extensions)), i.commands && i.commands.forEach((r) => {
    if (r.position.toolbarGroupId !== !1 && Array.isArray(jt)) {
      const n = de.toolbar.find((o) => o.id === r.position.toolbarGroupId);
      if (!n)
        throw new Error(`Top bar group ${r.position.toolbarGroupId} not found for command id ${r.id}.`);
      Array.isArray(n.commands) && n.commands.push(r);
    }
    if (r.position.bubbleMenuGroupId !== !1 && Array.isArray(jt)) {
      const n = de.bubbleMenu.find((o) => o.id === r.position.bubbleMenuGroupId);
      if (!n)
        throw new Error(`Bubble menu group ${r.position.bubbleMenuGroupId} not found for command id ${r.id}.`);
      Array.isArray(n.commands) && n.commands.push(r);
    }
  });
}
function Bf(e) {
  const i = e.getValidationSchema(Jf).safeParse(e.config);
  if (!i.success) {
    const r = `Invalid TipTap configuration for plugin id: ${e.pluginId}!
Received plugin configuration:
${JSON.stringify(e.config, null, 2)}

Zod Validation Error:
${i.error.message}`;
    throw new Error(r);
  }
  return i.data;
}
const Xf = () => de;
export {
  X as a,
  qe as b,
  Kf as c,
  Wf as d,
  Xf as g,
  P as o,
  Bf as p,
  dt as r,
  x as s,
  ne as u
};
