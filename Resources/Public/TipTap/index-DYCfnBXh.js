import { M as Ne, m as Ie, g as le, P as qt, a as Jt, G as Pe, ac as ve, a1 as He, aj as we, aa as xe } from "./index-DCsf0cLd.js";
const De = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3nd0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0axi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mögensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2", Me = "ελ1υ2бг1ел3дети4ею2католик6ом3мкд2он1сква6онлайн5рг3рус2ф2сайт3рб3укр3қаз3հայ3ישראל5קום3ابوظبي5رامكو5لاردن4بحرين5جزائر5سعودية6عليان5مغرب5مارات5یران5بارت2زار4يتك3ھارت5تونس4سودان3رية5شبكة4عراق2ب2مان4فلسطين6قطر3كاثوليك6وم3مصر2ليسيا5وريتانيا7قع4همراه5پاکستان7ڀارت4कॉम3नेट3भारत0म्3ोत5संगठन5বাংলা5ভারত2ৰত4ਭਾਰਤ4ભારત4ଭାରତ4இந்தியா6லங்கை6சிங்கப்பூர்11భారత్5ಭಾರತ4ഭാരതം5ලංකා4คอม3ไทย3ລາວ3გე2みんな3アマゾン4クラウド4グーグル4コム2ストア3セール3ファッション6ポイント4世界2中信1国1國1文网3亚马逊3企业2佛山2信息2健康2八卦2公司1益2台湾1灣2商城1店1标2嘉里0大酒店5在线2大拿2天主教3娱乐2家電2广东2微博2慈善2我爱你3手机2招聘2政务1府2新加坡2闻2时尚2書籍2机构2淡马锡3游戏2澳門2点看2移动2组织机构4网址1店1站1络2联通2谷歌2购物2通販2集团2電訊盈科4飞利浦3食品2餐厅2香格里拉3港2닷넷1컴2삼성2한국2", zt = "numeric", Wt = "ascii", Ft = "alpha", K = "asciinumeric", F = "alphanumeric", Kt = "domain", me = "emoji", Ue = "scheme", je = "slashscheme", xt = "whitespace";
function Be(t, n) {
  return t in n || (n[t] = []), n[t];
}
function M(t, n, e) {
  n[zt] && (n[K] = !0, n[F] = !0), n[Wt] && (n[K] = !0, n[Ft] = !0), n[K] && (n[F] = !0), n[Ft] && (n[F] = !0), n[F] && (n[Kt] = !0), n[me] && (n[Kt] = !0);
  for (const o in n) {
    const s = Be(o, e);
    s.indexOf(t) < 0 && s.push(t);
  }
}
function ze(t, n) {
  const e = {};
  for (const o in n)
    n[o].indexOf(t) >= 0 && (e[o] = !0);
  return e;
}
function R(t = null) {
  this.j = {}, this.jr = [], this.jd = null, this.t = t;
}
R.groups = {};
R.prototype = {
  accepts() {
    return !!this.t;
  },
  /**
   * Follow an existing transition from the given input to the next state.
   * Does not mutate.
   * @param {string} input character or token type to transition on
   * @returns {?State<T>} the next state, if any
   */
  go(t) {
    const n = this, e = n.j[t];
    if (e)
      return e;
    for (let o = 0; o < n.jr.length; o++) {
      const s = n.jr[o][0], r = n.jr[o][1];
      if (r && s.test(t))
        return r;
    }
    return n.jd;
  },
  /**
   * Whether the state has a transition for the given input. Set the second
   * argument to true to only look for an exact match (and not a default or
   * regular-expression-based transition)
   * @param {string} input
   * @param {boolean} exactOnly
   */
  has(t, n = !1) {
    return n ? t in this.j : !!this.go(t);
  },
  /**
   * Short for "transition all"; create a transition from the array of items
   * in the given list to the same final resulting state.
   * @param {string | string[]} inputs Group of inputs to transition on
   * @param {Transition<T> | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   */
  ta(t, n, e, o) {
    for (let s = 0; s < t.length; s++)
      this.tt(t[s], n, e, o);
  },
  /**
   * Short for "take regexp transition"; defines a transition for this state
   * when it encounters a token which matches the given regular expression
   * @param {RegExp} regexp Regular expression transition (populate first)
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  tr(t, n, e, o) {
    o = o || R.groups;
    let s;
    return n && n.j ? s = n : (s = new R(n), e && o && M(n, e, o)), this.jr.push([t, s]), s;
  },
  /**
   * Short for "take transitions", will take as many sequential transitions as
   * the length of the given input and returns the
   * resulting final state.
   * @param {string | string[]} input
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  ts(t, n, e, o) {
    let s = this;
    const r = t.length;
    if (!r)
      return s;
    for (let a = 0; a < r - 1; a++)
      s = s.tt(t[a]);
    return s.tt(t[r - 1], n, e, o);
  },
  /**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * Specify a token group flags to define groups that this token belongs to.
   * The token will be added to corresponding entires in the given groups
   * object.
   *
   * @param {string} input character, token type to transition on
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of groups
   * @returns {State<T>} taken after the given input
   */
  tt(t, n, e, o) {
    o = o || R.groups;
    const s = this;
    if (n && n.j)
      return s.j[t] = n, n;
    const r = n;
    let a, l = s.go(t);
    if (l ? (a = new R(), Object.assign(a.j, l.j), a.jr.push.apply(a.jr, l.jr), a.jd = l.jd, a.t = l.t) : a = new R(), r) {
      if (o)
        if (a.t && typeof a.t == "string") {
          const f = Object.assign(ze(a.t, o), e);
          M(r, f, o);
        } else e && M(r, e, o);
      a.t = r;
    }
    return s.j[t] = a, a;
  }
};
const c = (t, n, e, o, s) => t.ta(n, e, o, s), A = (t, n, e, o, s) => t.tr(n, e, o, s), ce = (t, n, e, o, s) => t.ts(n, e, o, s), i = (t, n, e, o, s) => t.tt(n, e, o, s), v = "WORD", _t = "UWORD", Ee = "ASCIINUMERICAL", Ae = "ALPHANUMERICAL", J = "LOCALHOST", Gt = "TLD", $t = "UTLD", et = "SCHEME", j = "SLASH_SCHEME", Vt = "NUM", Qt = "WS", Yt = "NL", _ = "OPENBRACE", G = "CLOSEBRACE", nt = "OPENBRACKET", ot = "CLOSEBRACKET", st = "OPENPAREN", it = "CLOSEPAREN", rt = "OPENANGLEBRACKET", at = "CLOSEANGLEBRACKET", lt = "FULLWIDTHLEFTPAREN", ct = "FULLWIDTHRIGHTPAREN", ut = "LEFTCORNERBRACKET", dt = "RIGHTCORNERBRACKET", ht = "LEFTWHITECORNERBRACKET", ft = "RIGHTWHITECORNERBRACKET", pt = "FULLWIDTHLESSTHAN", gt = "FULLWIDTHGREATERTHAN", mt = "AMPERSAND", Et = "APOSTROPHE", At = "ASTERISK", w = "AT", kt = "BACKSLASH", Lt = "BACKTICK", Tt = "CARET", x = "COLON", Xt = "COMMA", Ct = "DOLLAR", S = "DOT", Rt = "EQUALS", Zt = "EXCLAMATION", b = "HYPHEN", $ = "PERCENT", yt = "PIPE", Ot = "PLUS", bt = "POUND", Q = "QUERY", te = "QUOTE", ke = "FULLWIDTHMIDDLEDOT", ee = "SEMI", N = "SLASH", q = "TILDE", St = "UNDERSCORE", Le = "EMOJI", Nt = "SYM";
var Te = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ALPHANUMERICAL: Ae,
  AMPERSAND: mt,
  APOSTROPHE: Et,
  ASCIINUMERICAL: Ee,
  ASTERISK: At,
  AT: w,
  BACKSLASH: kt,
  BACKTICK: Lt,
  CARET: Tt,
  CLOSEANGLEBRACKET: at,
  CLOSEBRACE: G,
  CLOSEBRACKET: ot,
  CLOSEPAREN: it,
  COLON: x,
  COMMA: Xt,
  DOLLAR: Ct,
  DOT: S,
  EMOJI: Le,
  EQUALS: Rt,
  EXCLAMATION: Zt,
  FULLWIDTHGREATERTHAN: gt,
  FULLWIDTHLEFTPAREN: lt,
  FULLWIDTHLESSTHAN: pt,
  FULLWIDTHMIDDLEDOT: ke,
  FULLWIDTHRIGHTPAREN: ct,
  HYPHEN: b,
  LEFTCORNERBRACKET: ut,
  LEFTWHITECORNERBRACKET: ht,
  LOCALHOST: J,
  NL: Yt,
  NUM: Vt,
  OPENANGLEBRACKET: rt,
  OPENBRACE: _,
  OPENBRACKET: nt,
  OPENPAREN: st,
  PERCENT: $,
  PIPE: yt,
  PLUS: Ot,
  POUND: bt,
  QUERY: Q,
  QUOTE: te,
  RIGHTCORNERBRACKET: dt,
  RIGHTWHITECORNERBRACKET: ft,
  SCHEME: et,
  SEMI: ee,
  SLASH: N,
  SLASH_SCHEME: j,
  SYM: Nt,
  TILDE: q,
  TLD: Gt,
  UNDERSCORE: St,
  UTLD: $t,
  UWORD: _t,
  WORD: v,
  WS: Qt
});
const I = /[a-z]/, W = /\p{L}/u, Dt = /\p{Emoji}/u, P = /\d/, Mt = /\s/, ue = "\r", Ut = `
`, We = "️", Fe = "‍", jt = "￼";
let X = null, Z = null;
function Ke(t = []) {
  const n = {};
  R.groups = n;
  const e = new R();
  X == null && (X = de(De)), Z == null && (Z = de(Me)), i(e, "'", Et), i(e, "{", _), i(e, "}", G), i(e, "[", nt), i(e, "]", ot), i(e, "(", st), i(e, ")", it), i(e, "<", rt), i(e, ">", at), i(e, "（", lt), i(e, "）", ct), i(e, "「", ut), i(e, "」", dt), i(e, "『", ht), i(e, "』", ft), i(e, "＜", pt), i(e, "＞", gt), i(e, "&", mt), i(e, "*", At), i(e, "@", w), i(e, "`", Lt), i(e, "^", Tt), i(e, ":", x), i(e, ",", Xt), i(e, "$", Ct), i(e, ".", S), i(e, "=", Rt), i(e, "!", Zt), i(e, "-", b), i(e, "%", $), i(e, "|", yt), i(e, "+", Ot), i(e, "#", bt), i(e, "?", Q), i(e, '"', te), i(e, "/", N), i(e, ";", ee), i(e, "~", q), i(e, "_", St), i(e, "\\", kt), i(e, "・", ke);
  const o = A(e, P, Vt, {
    [zt]: !0
  });
  A(o, P, o);
  const s = A(o, I, Ee, {
    [K]: !0
  }), r = A(o, W, Ae, {
    [F]: !0
  }), a = A(e, I, v, {
    [Wt]: !0
  });
  A(a, P, s), A(a, I, a), A(s, P, s), A(s, I, s);
  const l = A(e, W, _t, {
    [Ft]: !0
  });
  A(l, I), A(l, P, r), A(l, W, l), A(r, P, r), A(r, I), A(r, W, r);
  const f = i(e, Ut, Yt, {
    [xt]: !0
  }), h = i(e, ue, Qt, {
    [xt]: !0
  }), d = A(e, Mt, Qt, {
    [xt]: !0
  });
  i(e, jt, d), i(h, Ut, f), i(h, jt, d), A(h, Mt, d), i(d, ue), i(d, Ut), A(d, Mt, d), i(d, jt, d);
  const u = A(e, Dt, Le, {
    [me]: !0
  });
  i(u, "#"), A(u, Dt, u), i(u, We, u);
  const g = i(u, Fe);
  i(g, "#"), A(g, Dt, u);
  const m = [[I, a], [P, s]], y = [[I, null], [W, l], [P, r]];
  for (let k = 0; k < X.length; k++)
    H(e, X[k], Gt, v, m);
  for (let k = 0; k < Z.length; k++)
    H(e, Z[k], $t, _t, y);
  M(Gt, {
    tld: !0,
    ascii: !0
  }, n), M($t, {
    utld: !0,
    alpha: !0
  }, n), H(e, "file", et, v, m), H(e, "mailto", et, v, m), H(e, "http", j, v, m), H(e, "https", j, v, m), H(e, "ftp", j, v, m), H(e, "ftps", j, v, m), M(et, {
    scheme: !0,
    ascii: !0
  }, n), M(j, {
    slashscheme: !0,
    ascii: !0
  }, n), t = t.sort((k, T) => k[0] > T[0] ? 1 : -1);
  for (let k = 0; k < t.length; k++) {
    const T = t[k][0], L = t[k][1] ? {
      [Ue]: !0
    } : {
      [je]: !0
    };
    T.indexOf("-") >= 0 ? L[Kt] = !0 : I.test(T) ? P.test(T) ? L[K] = !0 : L[Wt] = !0 : L[zt] = !0, ce(e, T, T, L);
  }
  return ce(e, "localhost", J, {
    ascii: !0
  }), e.jd = new R(Nt), {
    start: e,
    tokens: Object.assign({
      groups: n
    }, Te)
  };
}
function Ce(t, n) {
  const e = _e(n.replace(/[A-Z]/g, (l) => l.toLowerCase())), o = e.length, s = [];
  let r = 0, a = 0;
  for (; a < o; ) {
    let l = t, f = null, h = 0, d = null, u = -1, g = -1;
    for (; a < o && (f = l.go(e[a])); )
      l = f, l.accepts() ? (u = 0, g = 0, d = l) : u >= 0 && (u += e[a].length, g++), h += e[a].length, r += e[a].length, a++;
    r -= u, a -= g, h -= u, s.push({
      t: d.t,
      // token type/name
      v: n.slice(r - h, r),
      // string value
      s: r - h,
      // start index
      e: r
      // end index (excluding)
    });
  }
  return s;
}
function _e(t) {
  const n = [], e = t.length;
  let o = 0;
  for (; o < e; ) {
    let s = t.charCodeAt(o), r, a = s < 55296 || s > 56319 || o + 1 === e || (r = t.charCodeAt(o + 1)) < 56320 || r > 57343 ? t[o] : t.slice(o, o + 2);
    n.push(a), o += a.length;
  }
  return n;
}
function H(t, n, e, o, s) {
  let r;
  const a = n.length;
  for (let l = 0; l < a - 1; l++) {
    const f = n[l];
    t.j[f] ? r = t.j[f] : (r = new R(o), r.jr = s.slice(), t.j[f] = r), t = r;
  }
  return r = new R(e), r.jr = s.slice(), t.j[n[a - 1]] = r, r;
}
function de(t) {
  const n = [], e = [];
  let o = 0, s = "0123456789";
  for (; o < t.length; ) {
    let r = 0;
    for (; s.indexOf(t[o + r]) >= 0; )
      r++;
    if (r > 0) {
      n.push(e.join(""));
      for (let a = parseInt(t.substring(o, o + r), 10); a > 0; a--)
        e.pop();
      o += r;
    } else
      e.push(t[o]), o++;
  }
  return n;
}
const V = {
  defaultProtocol: "http",
  events: null,
  format: he,
  formatHref: he,
  nl2br: !1,
  tagName: "a",
  target: null,
  rel: null,
  validate: !0,
  truncate: 1 / 0,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null
};
function ne(t, n = null) {
  let e = Object.assign({}, V);
  t && (e = Object.assign(e, t instanceof ne ? t.o : t));
  const o = e.ignoreTags, s = [];
  for (let r = 0; r < o.length; r++)
    s.push(o[r].toUpperCase());
  this.o = e, n && (this.defaultRender = n), this.ignoreTags = s;
}
ne.prototype = {
  o: V,
  /**
   * @type string[]
   */
  ignoreTags: [],
  /**
   * @param {IntermediateRepresentation} ir
   * @returns {any}
   */
  defaultRender(t) {
    return t;
  },
  /**
   * Returns true or false based on whether a token should be displayed as a
   * link based on the user options.
   * @param {MultiToken} token
   * @returns {boolean}
   */
  check(t) {
    return this.get("validate", t.toString(), t);
  },
  // Private methods
  /**
   * Resolve an option's value based on the value of the option and the given
   * params. If operator and token are specified and the target option is
   * callable, automatically calls the function with the given argument.
   * @template {keyof Opts} K
   * @param {K} key Name of option to use
   * @param {string} [operator] will be passed to the target option if it's a
   * function. If not specified, RAW function value gets returned
   * @param {MultiToken} [token] The token from linkify.tokenize
   * @returns {Opts[K] | any}
   */
  get(t, n, e) {
    const o = n != null;
    let s = this.o[t];
    return s && (typeof s == "object" ? (s = e.t in s ? s[e.t] : V[t], typeof s == "function" && o && (s = s(n, e))) : typeof s == "function" && o && (s = s(n, e.t, e)), s);
  },
  /**
   * @template {keyof Opts} L
   * @param {L} key Name of options object to use
   * @param {string} [operator]
   * @param {MultiToken} [token]
   * @returns {Opts[L] | any}
   */
  getObj(t, n, e) {
    let o = this.o[t];
    return typeof o == "function" && n != null && (o = o(n, e.t, e)), o;
  },
  /**
   * Convert the given token to a rendered element that may be added to the
   * calling-interface's DOM
   * @param {MultiToken} token Token to render to an HTML element
   * @returns {any} Render result; e.g., HTML string, DOM element, React
   *   Component, etc.
   */
  render(t) {
    const n = t.render(this);
    return (this.get("render", null, t) || this.defaultRender)(n, t.t, t);
  }
};
function he(t) {
  return t;
}
function Re(t, n) {
  this.t = "token", this.v = t, this.tk = n;
}
Re.prototype = {
  isLink: !1,
  /**
   * Return the string this token represents.
   * @return {string}
   */
  toString() {
    return this.v;
  },
  /**
   * What should the value for this token be in the `href` HTML attribute?
   * Returns the `.toString` value by default.
   * @param {string} [scheme]
   * @return {string}
   */
  toHref(t) {
    return this.toString();
  },
  /**
   * @param {Options} options Formatting options
   * @returns {string}
   */
  toFormattedString(t) {
    const n = this.toString(), e = t.get("truncate", n, this), o = t.get("format", n, this);
    return e && o.length > e ? o.substring(0, e) + "…" : o;
  },
  /**
   *
   * @param {Options} options
   * @returns {string}
   */
  toFormattedHref(t) {
    return t.get("formatHref", this.toHref(t.get("defaultProtocol")), this);
  },
  /**
   * The start index of this token in the original input string
   * @returns {number}
   */
  startIndex() {
    return this.tk[0].s;
  },
  /**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
  endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  /**
  	Returns an object  of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
  toObject(t = V.defaultProtocol) {
    return {
      type: this.t,
      value: this.toString(),
      isLink: this.isLink,
      href: this.toHref(t),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   *
   * @param {Options} options Formatting option
   */
  toFormattedObject(t) {
    return {
      type: this.t,
      value: this.toFormattedString(t),
      isLink: this.isLink,
      href: this.toFormattedHref(t),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   * Whether this token should be rendered as a link according to the given options
   * @param {Options} options
   * @returns {boolean}
   */
  validate(t) {
    return t.get("validate", this.toString(), this);
  },
  /**
   * Return an object that represents how this link should be rendered.
   * @param {Options} options Formattinng options
   */
  render(t) {
    const n = this, e = this.toHref(t.get("defaultProtocol")), o = t.get("formatHref", e, this), s = t.get("tagName", e, n), r = this.toFormattedString(t), a = {}, l = t.get("className", e, n), f = t.get("target", e, n), h = t.get("rel", e, n), d = t.getObj("attributes", e, n), u = t.getObj("events", e, n);
    return a.href = o, l && (a.class = l), f && (a.target = f), h && (a.rel = h), d && Object.assign(a, d), {
      tagName: s,
      attributes: a,
      content: r,
      eventListeners: u
    };
  }
};
function It(t, n) {
  class e extends Re {
    constructor(s, r) {
      super(s, r), this.t = t;
    }
  }
  for (const o in n)
    e.prototype[o] = n[o];
  return e.t = t, e;
}
const fe = It("email", {
  isLink: !0,
  toHref() {
    return "mailto:" + this.toString();
  }
}), pe = It("text"), Ge = It("nl"), tt = It("url", {
  isLink: !0,
  /**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@param {string} [scheme] default scheme (e.g., 'https')
  	@return {string} the full href
  */
  toHref(t = V.defaultProtocol) {
    return this.hasProtocol() ? this.v : `${t}://${this.v}`;
  },
  /**
   * Check whether this URL token has a protocol
   * @return {boolean}
   */
  hasProtocol() {
    const t = this.tk;
    return t.length >= 2 && t[0].t !== J && t[1].t === x;
  }
}), O = (t) => new R(t);
function $e({
  groups: t
}) {
  const n = t.domain.concat([mt, At, w, kt, Lt, Tt, Ct, Rt, b, Vt, $, yt, Ot, bt, N, Nt, q, St]), e = [Et, x, Xt, S, Zt, $, Q, te, ee, rt, at, _, G, ot, nt, st, it, lt, ct, ut, dt, ht, ft, pt, gt], o = [mt, Et, At, kt, Lt, Tt, Ct, Rt, b, _, G, $, yt, Ot, bt, Q, N, Nt, q, St], s = O(), r = i(s, q);
  c(r, o, r), c(r, t.domain, r);
  const a = O(), l = O(), f = O();
  c(s, t.domain, a), c(s, t.scheme, l), c(s, t.slashscheme, f), c(a, o, r), c(a, t.domain, a);
  const h = i(a, w);
  i(r, w, h), i(l, w, h), i(f, w, h);
  const d = i(r, S);
  c(d, o, r), c(d, t.domain, r);
  const u = O();
  c(h, t.domain, u), c(u, t.domain, u);
  const g = i(u, S);
  c(g, t.domain, u);
  const m = O(fe);
  c(g, t.tld, m), c(g, t.utld, m), i(h, J, m);
  const y = i(u, b);
  i(y, b, y), c(y, t.domain, u), c(m, t.domain, u), i(m, S, g), i(m, b, y);
  const k = i(m, x);
  c(k, t.numeric, fe);
  const T = i(a, b), p = i(a, S);
  i(T, b, T), c(T, t.domain, a), c(p, o, r), c(p, t.domain, a);
  const L = O(tt);
  c(p, t.tld, L), c(p, t.utld, L), c(L, t.domain, a), c(L, o, r), i(L, S, p), i(L, b, T), i(L, w, h);
  const Oe = i(L, x), ie = O(tt);
  c(Oe, t.numeric, ie);
  const C = O(tt), B = O();
  c(C, n, C), c(C, e, B), c(B, n, C), c(B, e, B), i(L, N, C), i(ie, N, C);
  const Pt = i(l, x), be = i(f, x), Se = i(be, N), vt = i(Se, N);
  c(l, t.domain, a), i(l, S, p), i(l, b, T), c(f, t.domain, a), i(f, S, p), i(f, b, T), c(Pt, t.domain, C), i(Pt, N, C), i(Pt, Q, C), c(vt, t.domain, C), c(vt, n, C), i(vt, N, C);
  const re = [
    [_, G],
    // {}
    [nt, ot],
    // []
    [st, it],
    // ()
    [rt, at],
    // <>
    [lt, ct],
    // （）
    [ut, dt],
    // 「」
    [ht, ft],
    // 『』
    [pt, gt]
    // ＜＞
  ];
  for (let Ht = 0; Ht < re.length; Ht++) {
    const [ae, wt] = re[Ht], Y = i(C, ae);
    i(B, ae, Y), i(Y, wt, C);
    const U = O(tt);
    c(Y, n, U);
    const z = O();
    c(Y, e), c(U, n, U), c(U, e, z), c(z, n, U), c(z, e, z), i(U, wt, C), i(z, wt, C);
  }
  return i(s, J, L), i(s, Yt, Ge), {
    start: s,
    tokens: Te
  };
}
function Qe(t, n, e) {
  let o = e.length, s = 0, r = [], a = [];
  for (; s < o; ) {
    let l = t, f = null, h = null, d = 0, u = null, g = -1;
    for (; s < o && !(f = l.go(e[s].t)); )
      a.push(e[s++]);
    for (; s < o && (h = f || l.go(e[s].t)); )
      f = null, l = h, l.accepts() ? (g = 0, u = l) : g >= 0 && g++, s++, d++;
    if (g < 0)
      s -= d, s < o && (a.push(e[s]), s++);
    else {
      a.length > 0 && (r.push(Bt(pe, n, a)), a = []), s -= g, d -= g;
      const m = u.t, y = e.slice(s - d, s);
      r.push(Bt(m, n, y));
    }
  }
  return a.length > 0 && r.push(Bt(pe, n, a)), r;
}
function Bt(t, n, e) {
  const o = e[0].s, s = e[e.length - 1].e, r = n.slice(o, s);
  return new t(r, e);
}
const qe = typeof console < "u" && console && console.warn || (() => {
}), Je = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.", E = {
  scanner: null,
  parser: null,
  tokenQueue: [],
  pluginQueue: [],
  customSchemes: [],
  initialized: !1
};
function Ve() {
  return R.groups = {}, E.scanner = null, E.parser = null, E.tokenQueue = [], E.pluginQueue = [], E.customSchemes = [], E.initialized = !1, E;
}
function ge(t, n = !1) {
  if (E.initialized && qe(`linkifyjs: already initialized - will not register custom scheme "${t}" ${Je}`), !/^[0-9a-z]+(-[0-9a-z]+)*$/.test(t))
    throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
  E.customSchemes.push([t, n]);
}
function Ye() {
  E.scanner = Ke(E.customSchemes);
  for (let t = 0; t < E.tokenQueue.length; t++)
    E.tokenQueue[t][1]({
      scanner: E.scanner
    });
  E.parser = $e(E.scanner.tokens);
  for (let t = 0; t < E.pluginQueue.length; t++)
    E.pluginQueue[t][1]({
      scanner: E.scanner,
      parser: E.parser
    });
  return E.initialized = !0, E;
}
function oe(t) {
  return E.initialized || Ye(), Qe(E.parser.start, t, Ce(E.scanner.start, t));
}
oe.scan = Ce;
function ye(t, n = null, e = null) {
  if (n && typeof n == "object") {
    if (e)
      throw Error(`linkifyjs: Invalid link type ${n}; must be a string`);
    e = n, n = null;
  }
  const o = new ne(e), s = oe(t), r = [];
  for (let a = 0; a < s.length; a++) {
    const l = s[a];
    l.isLink && (!n || l.t === n) && o.check(l) && r.push(l.toFormattedObject(o));
  }
  return r;
}
var se = "[\0-   ᠎ -\u2029 　]", Xe = new RegExp(se), Ze = new RegExp(`${se}$`), tn = new RegExp(se, "g");
function en(t) {
  return t.length === 1 ? t[0].isLink : t.length === 3 && t[1].isLink ? ["()", "[]"].includes(t[0].value + t[2].value) : !1;
}
function nn(t) {
  return new qt({
    key: new Jt("autolink"),
    appendTransaction: (n, e, o) => {
      const s = n.some((h) => h.docChanged) && !e.doc.eq(o.doc), r = n.some((h) => h.getMeta("preventAutolink"));
      if (!s || r)
        return;
      const { tr: a } = o, l = Pe(e.doc, [...n]);
      if (ve(l).forEach(({ newRange: h }) => {
        const d = He(o.doc, h, (m) => m.isTextblock);
        let u, g;
        if (d.length > 1)
          u = d[0], g = o.doc.textBetween(
            u.pos,
            u.pos + u.node.nodeSize,
            void 0,
            " "
          );
        else if (d.length) {
          const m = o.doc.textBetween(h.from, h.to, " ", " ");
          if (!Ze.test(m))
            return;
          u = d[0], g = o.doc.textBetween(u.pos, h.to, void 0, " ");
        }
        if (u && g) {
          const m = g.split(Xe).filter(Boolean);
          if (m.length <= 0)
            return !1;
          const y = m[m.length - 1], k = u.pos + g.lastIndexOf(y);
          if (!y)
            return !1;
          const T = oe(y).map((p) => p.toObject(t.defaultProtocol));
          if (!en(T))
            return !1;
          T.filter((p) => p.isLink).map((p) => ({
            ...p,
            from: k + p.start + 1,
            to: k + p.end + 1
          })).filter((p) => o.schema.marks.code ? !o.doc.rangeHasMark(p.from, p.to, o.schema.marks.code) : !0).filter((p) => t.validate(p.value)).filter((p) => t.shouldAutoLink(p.value)).forEach((p) => {
            we(p.from, p.to, o.doc).some((L) => L.mark.type === t.type) || a.addMark(
              p.from,
              p.to,
              t.type.create({
                href: p.href
              })
            );
          });
        }
      }), !!a.steps.length)
        return a;
    }
  });
}
function on(t) {
  return new qt({
    key: new Jt("handleClickLink"),
    props: {
      handleClick: (n, e, o) => {
        var s, r;
        if (o.button !== 0 || !n.editable)
          return !1;
        let a = null;
        if (o.target instanceof HTMLAnchorElement)
          a = o.target;
        else {
          let d = o.target;
          const u = [];
          for (; d.nodeName !== "DIV"; )
            u.push(d), d = d.parentNode;
          a = u.find((g) => g.nodeName === "A");
        }
        if (!a)
          return !1;
        const l = xe(n.state, t.type.name), f = (s = a?.href) != null ? s : l.href, h = (r = a?.target) != null ? r : l.target;
        return t.enableClickSelection && t.editor.commands.extendMarkRange(t.type.name), a && f ? (window.open(f, h), !0) : !1;
      }
    }
  });
}
function sn(t) {
  return new qt({
    key: new Jt("handlePasteLink"),
    props: {
      handlePaste: (n, e, o) => {
        const { shouldAutoLink: s } = t, { state: r } = n, { selection: a } = r, { empty: l } = a;
        if (l)
          return !1;
        let f = "";
        o.content.forEach((d) => {
          f += d.textContent;
        });
        const h = ye(f, { defaultProtocol: t.defaultProtocol }).find(
          (d) => d.isLink && d.value === f
        );
        return !f || !h || s !== void 0 && !s(h.href) ? !1 : t.editor.commands.setMark(t.type, {
          href: h.href
        });
      }
    }
  });
}
function D(t, n) {
  const e = ["http", "https", "ftp", "ftps", "mailto", "tel", "callto", "sms", "cid", "xmpp"];
  return n && n.forEach((o) => {
    const s = typeof o == "string" ? o : o.scheme;
    s && e.push(s);
  }), !t || t.replace(tn, "").match(
    new RegExp(
      // eslint-disable-next-line no-useless-escape
      `^(?:(?:${e.join("|")}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`,
      "i"
    )
  );
}
var an = Ne.create({
  name: "link",
  priority: 1e3,
  keepOnSplit: !1,
  exitable: !0,
  onCreate() {
    this.options.validate && !this.options.shouldAutoLink && (this.options.shouldAutoLink = this.options.validate, console.warn("The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.")), this.options.protocols.forEach((t) => {
      if (typeof t == "string") {
        ge(t);
        return;
      }
      ge(t.scheme, t.optionalSlashes);
    });
  },
  onDestroy() {
    Ve();
  },
  inclusive() {
    return this.options.autolink;
  },
  addOptions() {
    return {
      openOnClick: !0,
      enableClickSelection: !1,
      linkOnPaste: !0,
      autolink: !0,
      protocols: [],
      defaultProtocol: "http",
      HTMLAttributes: {
        target: "_blank",
        rel: "noopener noreferrer nofollow",
        class: null
      },
      isAllowedUri: (t, n) => !!D(t, n.protocols),
      validate: (t) => !!t,
      shouldAutoLink: (t) => !!t
    };
  },
  addAttributes() {
    return {
      href: {
        default: null,
        parseHTML(t) {
          return t.getAttribute("href");
        }
      },
      target: {
        default: this.options.HTMLAttributes.target
      },
      rel: {
        default: this.options.HTMLAttributes.rel
      },
      class: {
        default: this.options.HTMLAttributes.class
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "a[href]",
        getAttrs: (t) => {
          const n = t.getAttribute("href");
          return !n || !this.options.isAllowedUri(n, {
            defaultValidate: (e) => !!D(e, this.options.protocols),
            protocols: this.options.protocols,
            defaultProtocol: this.options.defaultProtocol
          }) ? !1 : null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return this.options.isAllowedUri(t.href, {
      defaultValidate: (n) => !!D(n, this.options.protocols),
      protocols: this.options.protocols,
      defaultProtocol: this.options.defaultProtocol
    }) ? ["a", le(this.options.HTMLAttributes, t), 0] : ["a", le(this.options.HTMLAttributes, { ...t, href: "" }), 0];
  },
  markdownTokenName: "link",
  parseMarkdown: (t, n) => n.applyMark("link", n.parseInline(t.tokens || []), {
    href: t.href,
    title: t.title || null
  }),
  renderMarkdown: (t, n) => {
    var e;
    const o = ((e = t.attrs) == null ? void 0 : e.href) || "";
    return `[${n.renderChildren(t)}](${o})`;
  },
  addCommands() {
    return {
      setLink: (t) => ({ chain: n }) => {
        const { href: e } = t;
        return this.options.isAllowedUri(e, {
          defaultValidate: (o) => !!D(o, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        }) ? n().setMark(this.name, t).setMeta("preventAutolink", !0).run() : !1;
      },
      toggleLink: (t) => ({ chain: n }) => {
        const { href: e } = t || {};
        return e && !this.options.isAllowedUri(e, {
          defaultValidate: (o) => !!D(o, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        }) ? !1 : n().toggleMark(this.name, t, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run();
      },
      unsetLink: () => ({ chain: t }) => t().unsetMark(this.name, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run()
    };
  },
  addPasteRules() {
    return [
      Ie({
        find: (t) => {
          const n = [];
          if (t) {
            const { protocols: e, defaultProtocol: o } = this.options, s = ye(t).filter(
              (r) => r.isLink && this.options.isAllowedUri(r.value, {
                defaultValidate: (a) => !!D(a, e),
                protocols: e,
                defaultProtocol: o
              })
            );
            s.length && s.forEach((r) => {
              this.options.shouldAutoLink(r.value) && n.push({
                text: r.value,
                data: {
                  href: r.href
                },
                index: r.start
              });
            });
          }
          return n;
        },
        type: this.type,
        getAttributes: (t) => {
          var n;
          return {
            href: (n = t.data) == null ? void 0 : n.href
          };
        }
      })
    ];
  },
  addProseMirrorPlugins() {
    const t = [], { protocols: n, defaultProtocol: e } = this.options;
    return this.options.autolink && t.push(
      nn({
        type: this.type,
        defaultProtocol: this.options.defaultProtocol,
        validate: (o) => this.options.isAllowedUri(o, {
          defaultValidate: (s) => !!D(s, n),
          protocols: n,
          defaultProtocol: e
        }),
        shouldAutoLink: this.options.shouldAutoLink
      })
    ), this.options.openOnClick === !0 && t.push(
      on({
        type: this.type,
        editor: this.editor,
        enableClickSelection: this.options.enableClickSelection
      })
    ), this.options.linkOnPaste && t.push(
      sn({
        editor: this.editor,
        defaultProtocol: this.options.defaultProtocol,
        type: this.type,
        shouldAutoLink: this.options.shouldAutoLink
      })
    ), t;
  }
});
export {
  an as L
};
