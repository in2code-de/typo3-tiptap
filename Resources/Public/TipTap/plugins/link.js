import { o as Pe } from "../index-e_Ie-2wz.js";
import { M as Ne, d as ve, m as ce, P as Jt, e as Vt, f as He, h as we, j as xe, k as De, l as Me } from "../index-DHU43GOd.js";
import xt from "@typo3/backend/modal.js";
import { d as Ue } from "../configuration-C_XBPA12.js";
const je = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3nd0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0axi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mögensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2", Be = "ελ1υ2бг1ел3дети4ею2католик6ом3мкд2он1сква6онлайн5рг3рус2ф2сайт3рб3укр3қаз3հայ3ישראל5קום3ابوظبي5رامكو5لاردن4بحرين5جزائر5سعودية6عليان5مغرب5مارات5یران5بارت2زار4يتك3ھارت5تونس4سودان3رية5شبكة4عراق2ب2مان4فلسطين6قطر3كاثوليك6وم3مصر2ليسيا5وريتانيا7قع4همراه5پاکستان7ڀارت4कॉम3नेट3भारत0म्3ोत5संगठन5বাংলা5ভারত2ৰত4ਭਾਰਤ4ભારત4ଭାରତ4இந்தியா6லங்கை6சிங்கப்பூர்11భారత్5ಭಾರತ4ഭാരതം5ලංකා4คอม3ไทย3ລາວ3გე2みんな3アマゾン4クラウド4グーグル4コム2ストア3セール3ファッション6ポイント4世界2中信1国1國1文网3亚马逊3企业2佛山2信息2健康2八卦2公司1益2台湾1灣2商城1店1标2嘉里0大酒店5在线2大拿2天主教3娱乐2家電2广东2微博2慈善2我爱你3手机2招聘2政务1府2新加坡2闻2时尚2書籍2机构2淡马锡3游戏2澳門2点看2移动2组织机构4网址1店1站1络2联通2谷歌2购物2通販2集团2電訊盈科4飞利浦3食品2餐厅2香格里拉3港2닷넷1컴2삼성2한국2", Wt = "numeric", Kt = "ascii", Ft = "alpha", F = "asciinumeric", K = "alphanumeric", _t = "domain", Ee = "emoji", ze = "scheme", We = "slashscheme", Dt = "whitespace";
function Ke(t, n) {
  return t in n || (n[t] = []), n[t];
}
function M(t, n, e) {
  n[Wt] && (n[F] = !0, n[K] = !0), n[Kt] && (n[F] = !0, n[Ft] = !0), n[F] && (n[K] = !0), n[Ft] && (n[K] = !0), n[K] && (n[_t] = !0), n[Ee] && (n[_t] = !0);
  for (const o in n) {
    const s = Ke(o, e);
    s.indexOf(t) < 0 && s.push(t);
  }
}
function Fe(t, n) {
  const e = {};
  for (const o in n)
    n[o].indexOf(t) >= 0 && (e[o] = !0);
  return e;
}
function R(t = null) {
  this.j = {}, this.jr = [], this.jd = null, this.t = t;
}
R.groups = {};
R.prototype = {
  accepts() {
    return !!this.t;
  },
  /**
   * Follow an existing transition from the given input to the next state.
   * Does not mutate.
   * @param {string} input character or token type to transition on
   * @returns {?State<T>} the next state, if any
   */
  go(t) {
    const n = this, e = n.j[t];
    if (e)
      return e;
    for (let o = 0; o < n.jr.length; o++) {
      const s = n.jr[o][0], i = n.jr[o][1];
      if (i && s.test(t))
        return i;
    }
    return n.jd;
  },
  /**
   * Whether the state has a transition for the given input. Set the second
   * argument to true to only look for an exact match (and not a default or
   * regular-expression-based transition)
   * @param {string} input
   * @param {boolean} exactOnly
   */
  has(t, n = !1) {
    return n ? t in this.j : !!this.go(t);
  },
  /**
   * Short for "transition all"; create a transition from the array of items
   * in the given list to the same final resulting state.
   * @param {string | string[]} inputs Group of inputs to transition on
   * @param {Transition<T> | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   */
  ta(t, n, e, o) {
    for (let s = 0; s < t.length; s++)
      this.tt(t[s], n, e, o);
  },
  /**
   * Short for "take regexp transition"; defines a transition for this state
   * when it encounters a token which matches the given regular expression
   * @param {RegExp} regexp Regular expression transition (populate first)
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  tr(t, n, e, o) {
    o = o || R.groups;
    let s;
    return n && n.j ? s = n : (s = new R(n), e && o && M(n, e, o)), this.jr.push([t, s]), s;
  },
  /**
   * Short for "take transitions", will take as many sequential transitions as
   * the length of the given input and returns the
   * resulting final state.
   * @param {string | string[]} input
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  ts(t, n, e, o) {
    let s = this;
    const i = t.length;
    if (!i)
      return s;
    for (let a = 0; a < i - 1; a++)
      s = s.tt(t[a]);
    return s.tt(t[i - 1], n, e, o);
  },
  /**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * Specify a token group flags to define groups that this token belongs to.
   * The token will be added to corresponding entires in the given groups
   * object.
   *
   * @param {string} input character, token type to transition on
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of groups
   * @returns {State<T>} taken after the given input
   */
  tt(t, n, e, o) {
    o = o || R.groups;
    const s = this;
    if (n && n.j)
      return s.j[t] = n, n;
    const i = n;
    let a, l = s.go(t);
    if (l ? (a = new R(), Object.assign(a.j, l.j), a.jr.push.apply(a.jr, l.jr), a.jd = l.jd, a.t = l.t) : a = new R(), i) {
      if (o)
        if (a.t && typeof a.t == "string") {
          const f = Object.assign(Fe(a.t, o), e);
          M(i, f, o);
        } else e && M(i, e, o);
      a.t = i;
    }
    return s.j[t] = a, a;
  }
};
const c = (t, n, e, o, s) => t.ta(n, e, o, s), A = (t, n, e, o, s) => t.tr(n, e, o, s), ue = (t, n, e, o, s) => t.ts(n, e, o, s), r = (t, n, e, o, s) => t.tt(n, e, o, s), v = "WORD", Gt = "UWORD", Ae = "ASCIINUMERICAL", ke = "ALPHANUMERICAL", J = "LOCALHOST", $t = "TLD", Qt = "UTLD", et = "SCHEME", j = "SLASH_SCHEME", Yt = "NUM", qt = "WS", Xt = "NL", _ = "OPENBRACE", G = "CLOSEBRACE", nt = "OPENBRACKET", ot = "CLOSEBRACKET", st = "OPENPAREN", it = "CLOSEPAREN", rt = "OPENANGLEBRACKET", at = "CLOSEANGLEBRACKET", lt = "FULLWIDTHLEFTPAREN", ct = "FULLWIDTHRIGHTPAREN", ut = "LEFTCORNERBRACKET", dt = "RIGHTCORNERBRACKET", ht = "LEFTWHITECORNERBRACKET", ft = "RIGHTWHITECORNERBRACKET", pt = "FULLWIDTHLESSTHAN", mt = "FULLWIDTHGREATERTHAN", gt = "AMPERSAND", Et = "APOSTROPHE", At = "ASTERISK", w = "AT", kt = "BACKSLASH", Lt = "BACKTICK", Tt = "CARET", x = "COLON", Zt = "COMMA", Ct = "DOLLAR", S = "DOT", Rt = "EQUALS", te = "EXCLAMATION", O = "HYPHEN", $ = "PERCENT", yt = "PIPE", bt = "PLUS", Ot = "POUND", Q = "QUERY", ee = "QUOTE", Le = "FULLWIDTHMIDDLEDOT", ne = "SEMI", I = "SLASH", q = "TILDE", St = "UNDERSCORE", Te = "EMOJI", It = "SYM";
var Ce = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ALPHANUMERICAL: ke,
  AMPERSAND: gt,
  APOSTROPHE: Et,
  ASCIINUMERICAL: Ae,
  ASTERISK: At,
  AT: w,
  BACKSLASH: kt,
  BACKTICK: Lt,
  CARET: Tt,
  CLOSEANGLEBRACKET: at,
  CLOSEBRACE: G,
  CLOSEBRACKET: ot,
  CLOSEPAREN: it,
  COLON: x,
  COMMA: Zt,
  DOLLAR: Ct,
  DOT: S,
  EMOJI: Te,
  EQUALS: Rt,
  EXCLAMATION: te,
  FULLWIDTHGREATERTHAN: mt,
  FULLWIDTHLEFTPAREN: lt,
  FULLWIDTHLESSTHAN: pt,
  FULLWIDTHMIDDLEDOT: Le,
  FULLWIDTHRIGHTPAREN: ct,
  HYPHEN: O,
  LEFTCORNERBRACKET: ut,
  LEFTWHITECORNERBRACKET: ht,
  LOCALHOST: J,
  NL: Xt,
  NUM: Yt,
  OPENANGLEBRACKET: rt,
  OPENBRACE: _,
  OPENBRACKET: nt,
  OPENPAREN: st,
  PERCENT: $,
  PIPE: yt,
  PLUS: bt,
  POUND: Ot,
  QUERY: Q,
  QUOTE: ee,
  RIGHTCORNERBRACKET: dt,
  RIGHTWHITECORNERBRACKET: ft,
  SCHEME: et,
  SEMI: ne,
  SLASH: I,
  SLASH_SCHEME: j,
  SYM: It,
  TILDE: q,
  TLD: $t,
  UNDERSCORE: St,
  UTLD: Qt,
  UWORD: Gt,
  WORD: v,
  WS: qt
});
const P = /[a-z]/, W = /\p{L}/u, Mt = /\p{Emoji}/u, N = /\d/, Ut = /\s/, de = "\r", jt = `
`, _e = "️", Ge = "‍", Bt = "￼";
let X = null, Z = null;
function $e(t = []) {
  const n = {};
  R.groups = n;
  const e = new R();
  X == null && (X = he(je)), Z == null && (Z = he(Be)), r(e, "'", Et), r(e, "{", _), r(e, "}", G), r(e, "[", nt), r(e, "]", ot), r(e, "(", st), r(e, ")", it), r(e, "<", rt), r(e, ">", at), r(e, "（", lt), r(e, "）", ct), r(e, "「", ut), r(e, "」", dt), r(e, "『", ht), r(e, "』", ft), r(e, "＜", pt), r(e, "＞", mt), r(e, "&", gt), r(e, "*", At), r(e, "@", w), r(e, "`", Lt), r(e, "^", Tt), r(e, ":", x), r(e, ",", Zt), r(e, "$", Ct), r(e, ".", S), r(e, "=", Rt), r(e, "!", te), r(e, "-", O), r(e, "%", $), r(e, "|", yt), r(e, "+", bt), r(e, "#", Ot), r(e, "?", Q), r(e, '"', ee), r(e, "/", I), r(e, ";", ne), r(e, "~", q), r(e, "_", St), r(e, "\\", kt), r(e, "・", Le);
  const o = A(e, N, Yt, {
    [Wt]: !0
  });
  A(o, N, o);
  const s = A(o, P, Ae, {
    [F]: !0
  }), i = A(o, W, ke, {
    [K]: !0
  }), a = A(e, P, v, {
    [Kt]: !0
  });
  A(a, N, s), A(a, P, a), A(s, N, s), A(s, P, s);
  const l = A(e, W, Gt, {
    [Ft]: !0
  });
  A(l, P), A(l, N, i), A(l, W, l), A(i, N, i), A(i, P), A(i, W, i);
  const f = r(e, jt, Xt, {
    [Dt]: !0
  }), h = r(e, de, qt, {
    [Dt]: !0
  }), d = A(e, Ut, qt, {
    [Dt]: !0
  });
  r(e, Bt, d), r(h, jt, f), r(h, Bt, d), A(h, Ut, d), r(d, de), r(d, jt), A(d, Ut, d), r(d, Bt, d);
  const u = A(e, Mt, Te, {
    [Ee]: !0
  });
  r(u, "#"), A(u, Mt, u), r(u, _e, u);
  const m = r(u, Ge);
  r(m, "#"), A(m, Mt, u);
  const g = [[P, a], [N, s]], y = [[P, null], [W, l], [N, i]];
  for (let k = 0; k < X.length; k++)
    H(e, X[k], $t, v, g);
  for (let k = 0; k < Z.length; k++)
    H(e, Z[k], Qt, Gt, y);
  M($t, {
    tld: !0,
    ascii: !0
  }, n), M(Qt, {
    utld: !0,
    alpha: !0
  }, n), H(e, "file", et, v, g), H(e, "mailto", et, v, g), H(e, "http", j, v, g), H(e, "https", j, v, g), H(e, "ftp", j, v, g), H(e, "ftps", j, v, g), M(et, {
    scheme: !0,
    ascii: !0
  }, n), M(j, {
    slashscheme: !0,
    ascii: !0
  }, n), t = t.sort((k, T) => k[0] > T[0] ? 1 : -1);
  for (let k = 0; k < t.length; k++) {
    const T = t[k][0], L = t[k][1] ? {
      [ze]: !0
    } : {
      [We]: !0
    };
    T.indexOf("-") >= 0 ? L[_t] = !0 : P.test(T) ? N.test(T) ? L[F] = !0 : L[Kt] = !0 : L[Wt] = !0, ue(e, T, T, L);
  }
  return ue(e, "localhost", J, {
    ascii: !0
  }), e.jd = new R(It), {
    start: e,
    tokens: Object.assign({
      groups: n
    }, Ce)
  };
}
function Re(t, n) {
  const e = Qe(n.replace(/[A-Z]/g, (l) => l.toLowerCase())), o = e.length, s = [];
  let i = 0, a = 0;
  for (; a < o; ) {
    let l = t, f = null, h = 0, d = null, u = -1, m = -1;
    for (; a < o && (f = l.go(e[a])); )
      l = f, l.accepts() ? (u = 0, m = 0, d = l) : u >= 0 && (u += e[a].length, m++), h += e[a].length, i += e[a].length, a++;
    i -= u, a -= m, h -= u, s.push({
      t: d.t,
      // token type/name
      v: n.slice(i - h, i),
      // string value
      s: i - h,
      // start index
      e: i
      // end index (excluding)
    });
  }
  return s;
}
function Qe(t) {
  const n = [], e = t.length;
  let o = 0;
  for (; o < e; ) {
    let s = t.charCodeAt(o), i, a = s < 55296 || s > 56319 || o + 1 === e || (i = t.charCodeAt(o + 1)) < 56320 || i > 57343 ? t[o] : t.slice(o, o + 2);
    n.push(a), o += a.length;
  }
  return n;
}
function H(t, n, e, o, s) {
  let i;
  const a = n.length;
  for (let l = 0; l < a - 1; l++) {
    const f = n[l];
    t.j[f] ? i = t.j[f] : (i = new R(o), i.jr = s.slice(), t.j[f] = i), t = i;
  }
  return i = new R(e), i.jr = s.slice(), t.j[n[a - 1]] = i, i;
}
function he(t) {
  const n = [], e = [];
  let o = 0, s = "0123456789";
  for (; o < t.length; ) {
    let i = 0;
    for (; s.indexOf(t[o + i]) >= 0; )
      i++;
    if (i > 0) {
      n.push(e.join(""));
      for (let a = parseInt(t.substring(o, o + i), 10); a > 0; a--)
        e.pop();
      o += i;
    } else
      e.push(t[o]), o++;
  }
  return n;
}
const V = {
  defaultProtocol: "http",
  events: null,
  format: fe,
  formatHref: fe,
  nl2br: !1,
  tagName: "a",
  target: null,
  rel: null,
  validate: !0,
  truncate: 1 / 0,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null
};
function oe(t, n = null) {
  let e = Object.assign({}, V);
  t && (e = Object.assign(e, t instanceof oe ? t.o : t));
  const o = e.ignoreTags, s = [];
  for (let i = 0; i < o.length; i++)
    s.push(o[i].toUpperCase());
  this.o = e, n && (this.defaultRender = n), this.ignoreTags = s;
}
oe.prototype = {
  o: V,
  /**
   * @type string[]
   */
  ignoreTags: [],
  /**
   * @param {IntermediateRepresentation} ir
   * @returns {any}
   */
  defaultRender(t) {
    return t;
  },
  /**
   * Returns true or false based on whether a token should be displayed as a
   * link based on the user options.
   * @param {MultiToken} token
   * @returns {boolean}
   */
  check(t) {
    return this.get("validate", t.toString(), t);
  },
  // Private methods
  /**
   * Resolve an option's value based on the value of the option and the given
   * params. If operator and token are specified and the target option is
   * callable, automatically calls the function with the given argument.
   * @template {keyof Opts} K
   * @param {K} key Name of option to use
   * @param {string} [operator] will be passed to the target option if it's a
   * function. If not specified, RAW function value gets returned
   * @param {MultiToken} [token] The token from linkify.tokenize
   * @returns {Opts[K] | any}
   */
  get(t, n, e) {
    const o = n != null;
    let s = this.o[t];
    return s && (typeof s == "object" ? (s = e.t in s ? s[e.t] : V[t], typeof s == "function" && o && (s = s(n, e))) : typeof s == "function" && o && (s = s(n, e.t, e)), s);
  },
  /**
   * @template {keyof Opts} L
   * @param {L} key Name of options object to use
   * @param {string} [operator]
   * @param {MultiToken} [token]
   * @returns {Opts[L] | any}
   */
  getObj(t, n, e) {
    let o = this.o[t];
    return typeof o == "function" && n != null && (o = o(n, e.t, e)), o;
  },
  /**
   * Convert the given token to a rendered element that may be added to the
   * calling-interface's DOM
   * @param {MultiToken} token Token to render to an HTML element
   * @returns {any} Render result; e.g., HTML string, DOM element, React
   *   Component, etc.
   */
  render(t) {
    const n = t.render(this);
    return (this.get("render", null, t) || this.defaultRender)(n, t.t, t);
  }
};
function fe(t) {
  return t;
}
function ye(t, n) {
  this.t = "token", this.v = t, this.tk = n;
}
ye.prototype = {
  isLink: !1,
  /**
   * Return the string this token represents.
   * @return {string}
   */
  toString() {
    return this.v;
  },
  /**
   * What should the value for this token be in the `href` HTML attribute?
   * Returns the `.toString` value by default.
   * @param {string} [scheme]
   * @return {string}
   */
  toHref(t) {
    return this.toString();
  },
  /**
   * @param {Options} options Formatting options
   * @returns {string}
   */
  toFormattedString(t) {
    const n = this.toString(), e = t.get("truncate", n, this), o = t.get("format", n, this);
    return e && o.length > e ? o.substring(0, e) + "…" : o;
  },
  /**
   *
   * @param {Options} options
   * @returns {string}
   */
  toFormattedHref(t) {
    return t.get("formatHref", this.toHref(t.get("defaultProtocol")), this);
  },
  /**
   * The start index of this token in the original input string
   * @returns {number}
   */
  startIndex() {
    return this.tk[0].s;
  },
  /**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
  endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  /**
  	Returns an object  of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
  toObject(t = V.defaultProtocol) {
    return {
      type: this.t,
      value: this.toString(),
      isLink: this.isLink,
      href: this.toHref(t),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   *
   * @param {Options} options Formatting option
   */
  toFormattedObject(t) {
    return {
      type: this.t,
      value: this.toFormattedString(t),
      isLink: this.isLink,
      href: this.toFormattedHref(t),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   * Whether this token should be rendered as a link according to the given options
   * @param {Options} options
   * @returns {boolean}
   */
  validate(t) {
    return t.get("validate", this.toString(), this);
  },
  /**
   * Return an object that represents how this link should be rendered.
   * @param {Options} options Formattinng options
   */
  render(t) {
    const n = this, e = this.toHref(t.get("defaultProtocol")), o = t.get("formatHref", e, this), s = t.get("tagName", e, n), i = this.toFormattedString(t), a = {}, l = t.get("className", e, n), f = t.get("target", e, n), h = t.get("rel", e, n), d = t.getObj("attributes", e, n), u = t.getObj("events", e, n);
    return a.href = o, l && (a.class = l), f && (a.target = f), h && (a.rel = h), d && Object.assign(a, d), {
      tagName: s,
      attributes: a,
      content: i,
      eventListeners: u
    };
  }
};
function Pt(t, n) {
  class e extends ye {
    constructor(s, i) {
      super(s, i), this.t = t;
    }
  }
  for (const o in n)
    e.prototype[o] = n[o];
  return e.t = t, e;
}
const pe = Pt("email", {
  isLink: !0,
  toHref() {
    return "mailto:" + this.toString();
  }
}), me = Pt("text"), qe = Pt("nl"), tt = Pt("url", {
  isLink: !0,
  /**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@param {string} [scheme] default scheme (e.g., 'https')
  	@return {string} the full href
  */
  toHref(t = V.defaultProtocol) {
    return this.hasProtocol() ? this.v : `${t}://${this.v}`;
  },
  /**
   * Check whether this URL token has a protocol
   * @return {boolean}
   */
  hasProtocol() {
    const t = this.tk;
    return t.length >= 2 && t[0].t !== J && t[1].t === x;
  }
}), b = (t) => new R(t);
function Je({
  groups: t
}) {
  const n = t.domain.concat([gt, At, w, kt, Lt, Tt, Ct, Rt, O, Yt, $, yt, bt, Ot, I, It, q, St]), e = [Et, x, Zt, S, te, $, Q, ee, ne, rt, at, _, G, ot, nt, st, it, lt, ct, ut, dt, ht, ft, pt, mt], o = [gt, Et, At, kt, Lt, Tt, Ct, Rt, O, _, G, $, yt, bt, Ot, Q, I, It, q, St], s = b(), i = r(s, q);
  c(i, o, i), c(i, t.domain, i);
  const a = b(), l = b(), f = b();
  c(s, t.domain, a), c(s, t.scheme, l), c(s, t.slashscheme, f), c(a, o, i), c(a, t.domain, a);
  const h = r(a, w);
  r(i, w, h), r(l, w, h), r(f, w, h);
  const d = r(i, S);
  c(d, o, i), c(d, t.domain, i);
  const u = b();
  c(h, t.domain, u), c(u, t.domain, u);
  const m = r(u, S);
  c(m, t.domain, u);
  const g = b(pe);
  c(m, t.tld, g), c(m, t.utld, g), r(h, J, g);
  const y = r(u, O);
  r(y, O, y), c(y, t.domain, u), c(g, t.domain, u), r(g, S, m), r(g, O, y);
  const k = r(g, x);
  c(k, t.numeric, pe);
  const T = r(a, O), p = r(a, S);
  r(T, O, T), c(T, t.domain, a), c(p, o, i), c(p, t.domain, a);
  const L = b(tt);
  c(p, t.tld, L), c(p, t.utld, L), c(L, t.domain, a), c(L, o, i), r(L, S, p), r(L, O, T), r(L, w, h);
  const Oe = r(L, x), re = b(tt);
  c(Oe, t.numeric, re);
  const C = b(tt), B = b();
  c(C, n, C), c(C, e, B), c(B, n, C), c(B, e, B), r(L, I, C), r(re, I, C);
  const Nt = r(l, x), Se = r(f, x), Ie = r(Se, I), vt = r(Ie, I);
  c(l, t.domain, a), r(l, S, p), r(l, O, T), c(f, t.domain, a), r(f, S, p), r(f, O, T), c(Nt, t.domain, C), r(Nt, I, C), r(Nt, Q, C), c(vt, t.domain, C), c(vt, n, C), r(vt, I, C);
  const ae = [
    [_, G],
    // {}
    [nt, ot],
    // []
    [st, it],
    // ()
    [rt, at],
    // <>
    [lt, ct],
    // （）
    [ut, dt],
    // 「」
    [ht, ft],
    // 『』
    [pt, mt]
    // ＜＞
  ];
  for (let Ht = 0; Ht < ae.length; Ht++) {
    const [le, wt] = ae[Ht], Y = r(C, le);
    r(B, le, Y), r(Y, wt, C);
    const U = b(tt);
    c(Y, n, U);
    const z = b();
    c(Y, e), c(U, n, U), c(U, e, z), c(z, n, U), c(z, e, z), r(U, wt, C), r(z, wt, C);
  }
  return r(s, J, L), r(s, Xt, qe), {
    start: s,
    tokens: Ce
  };
}
function Ve(t, n, e) {
  let o = e.length, s = 0, i = [], a = [];
  for (; s < o; ) {
    let l = t, f = null, h = null, d = 0, u = null, m = -1;
    for (; s < o && !(f = l.go(e[s].t)); )
      a.push(e[s++]);
    for (; s < o && (h = f || l.go(e[s].t)); )
      f = null, l = h, l.accepts() ? (m = 0, u = l) : m >= 0 && m++, s++, d++;
    if (m < 0)
      s -= d, s < o && (a.push(e[s]), s++);
    else {
      a.length > 0 && (i.push(zt(me, n, a)), a = []), s -= m, d -= m;
      const g = u.t, y = e.slice(s - d, s);
      i.push(zt(g, n, y));
    }
  }
  return a.length > 0 && i.push(zt(me, n, a)), i;
}
function zt(t, n, e) {
  const o = e[0].s, s = e[e.length - 1].e, i = n.slice(o, s);
  return new t(i, e);
}
const Ye = typeof console < "u" && console && console.warn || (() => {
}), Xe = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.", E = {
  scanner: null,
  parser: null,
  tokenQueue: [],
  pluginQueue: [],
  customSchemes: [],
  initialized: !1
};
function Ze() {
  return R.groups = {}, E.scanner = null, E.parser = null, E.tokenQueue = [], E.pluginQueue = [], E.customSchemes = [], E.initialized = !1, E;
}
function ge(t, n = !1) {
  if (E.initialized && Ye(`linkifyjs: already initialized - will not register custom scheme "${t}" ${Xe}`), !/^[0-9a-z]+(-[0-9a-z]+)*$/.test(t))
    throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
  E.customSchemes.push([t, n]);
}
function tn() {
  E.scanner = $e(E.customSchemes);
  for (let t = 0; t < E.tokenQueue.length; t++)
    E.tokenQueue[t][1]({
      scanner: E.scanner
    });
  E.parser = Je(E.scanner.tokens);
  for (let t = 0; t < E.pluginQueue.length; t++)
    E.pluginQueue[t][1]({
      scanner: E.scanner,
      parser: E.parser
    });
  return E.initialized = !0, E;
}
function se(t) {
  return E.initialized || tn(), Ve(E.parser.start, t, Re(E.scanner.start, t));
}
se.scan = Re;
function be(t, n = null, e = null) {
  if (n && typeof n == "object") {
    if (e)
      throw Error(`linkifyjs: Invalid link type ${n}; must be a string`);
    e = n, n = null;
  }
  const o = new oe(e), s = se(t), i = [];
  for (let a = 0; a < s.length; a++) {
    const l = s[a];
    l.isLink && (!n || l.t === n) && o.check(l) && i.push(l.toFormattedObject(o));
  }
  return i;
}
var ie = "[\0-   ᠎ -\u2029 　]", en = new RegExp(ie), nn = new RegExp(`${ie}$`), on = new RegExp(ie, "g");
function sn(t) {
  return t.length === 1 ? t[0].isLink : t.length === 3 && t[1].isLink ? ["()", "[]"].includes(t[0].value + t[2].value) : !1;
}
function rn(t) {
  return new Jt({
    key: new Vt("autolink"),
    appendTransaction: (n, e, o) => {
      const s = n.some((h) => h.docChanged) && !e.doc.eq(o.doc), i = n.some((h) => h.getMeta("preventAutolink"));
      if (!s || i)
        return;
      const { tr: a } = o, l = He(e.doc, [...n]);
      if (we(l).forEach(({ newRange: h }) => {
        const d = xe(o.doc, h, (g) => g.isTextblock);
        let u, m;
        if (d.length > 1)
          u = d[0], m = o.doc.textBetween(
            u.pos,
            u.pos + u.node.nodeSize,
            void 0,
            " "
          );
        else if (d.length) {
          const g = o.doc.textBetween(h.from, h.to, " ", " ");
          if (!nn.test(g))
            return;
          u = d[0], m = o.doc.textBetween(u.pos, h.to, void 0, " ");
        }
        if (u && m) {
          const g = m.split(en).filter(Boolean);
          if (g.length <= 0)
            return !1;
          const y = g[g.length - 1], k = u.pos + m.lastIndexOf(y);
          if (!y)
            return !1;
          const T = se(y).map((p) => p.toObject(t.defaultProtocol));
          if (!sn(T))
            return !1;
          T.filter((p) => p.isLink).map((p) => ({
            ...p,
            from: k + p.start + 1,
            to: k + p.end + 1
          })).filter((p) => o.schema.marks.code ? !o.doc.rangeHasMark(p.from, p.to, o.schema.marks.code) : !0).filter((p) => t.validate(p.value)).filter((p) => t.shouldAutoLink(p.value)).forEach((p) => {
            De(p.from, p.to, o.doc).some((L) => L.mark.type === t.type) || a.addMark(
              p.from,
              p.to,
              t.type.create({
                href: p.href
              })
            );
          });
        }
      }), !!a.steps.length)
        return a;
    }
  });
}
function an(t) {
  return new Jt({
    key: new Vt("handleClickLink"),
    props: {
      handleClick: (n, e, o) => {
        var s, i;
        if (o.button !== 0 || !n.editable)
          return !1;
        let a = null;
        if (o.target instanceof HTMLAnchorElement)
          a = o.target;
        else {
          let d = o.target;
          const u = [];
          for (; d.nodeName !== "DIV"; )
            u.push(d), d = d.parentNode;
          a = u.find((m) => m.nodeName === "A");
        }
        if (!a)
          return !1;
        const l = Me(n.state, t.type.name), f = (s = a?.href) != null ? s : l.href, h = (i = a?.target) != null ? i : l.target;
        return t.enableClickSelection && t.editor.commands.extendMarkRange(t.type.name), a && f ? (window.open(f, h), !0) : !1;
      }
    }
  });
}
function ln(t) {
  return new Jt({
    key: new Vt("handlePasteLink"),
    props: {
      handlePaste: (n, e, o) => {
        const { shouldAutoLink: s } = t, { state: i } = n, { selection: a } = i, { empty: l } = a;
        if (l)
          return !1;
        let f = "";
        o.content.forEach((d) => {
          f += d.textContent;
        });
        const h = be(f, { defaultProtocol: t.defaultProtocol }).find(
          (d) => d.isLink && d.value === f
        );
        return !f || !h || s !== void 0 && !s(h.href) ? !1 : t.editor.commands.setMark(t.type, {
          href: h.href
        });
      }
    }
  });
}
function D(t, n) {
  const e = ["http", "https", "ftp", "ftps", "mailto", "tel", "callto", "sms", "cid", "xmpp"];
  return n && n.forEach((o) => {
    const s = typeof o == "string" ? o : o.scheme;
    s && e.push(s);
  }), !t || t.replace(on, "").match(
    new RegExp(
      // eslint-disable-next-line no-useless-escape
      `^(?:(?:${e.join("|")}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`,
      "i"
    )
  );
}
var cn = Ne.create({
  name: "link",
  priority: 1e3,
  keepOnSplit: !1,
  exitable: !0,
  onCreate() {
    this.options.validate && !this.options.shouldAutoLink && (this.options.shouldAutoLink = this.options.validate, console.warn("The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.")), this.options.protocols.forEach((t) => {
      if (typeof t == "string") {
        ge(t);
        return;
      }
      ge(t.scheme, t.optionalSlashes);
    });
  },
  onDestroy() {
    Ze();
  },
  inclusive() {
    return this.options.autolink;
  },
  addOptions() {
    return {
      openOnClick: !0,
      enableClickSelection: !1,
      linkOnPaste: !0,
      autolink: !0,
      protocols: [],
      defaultProtocol: "http",
      HTMLAttributes: {
        target: "_blank",
        rel: "noopener noreferrer nofollow",
        class: null
      },
      isAllowedUri: (t, n) => !!D(t, n.protocols),
      validate: (t) => !!t,
      shouldAutoLink: (t) => !!t
    };
  },
  addAttributes() {
    return {
      href: {
        default: null,
        parseHTML(t) {
          return t.getAttribute("href");
        }
      },
      target: {
        default: this.options.HTMLAttributes.target
      },
      rel: {
        default: this.options.HTMLAttributes.rel
      },
      class: {
        default: this.options.HTMLAttributes.class
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "a[href]",
        getAttrs: (t) => {
          const n = t.getAttribute("href");
          return !n || !this.options.isAllowedUri(n, {
            defaultValidate: (e) => !!D(e, this.options.protocols),
            protocols: this.options.protocols,
            defaultProtocol: this.options.defaultProtocol
          }) ? !1 : null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return this.options.isAllowedUri(t.href, {
      defaultValidate: (n) => !!D(n, this.options.protocols),
      protocols: this.options.protocols,
      defaultProtocol: this.options.defaultProtocol
    }) ? ["a", ce(this.options.HTMLAttributes, t), 0] : ["a", ce(this.options.HTMLAttributes, { ...t, href: "" }), 0];
  },
  markdownTokenName: "link",
  parseMarkdown: (t, n) => n.applyMark("link", n.parseInline(t.tokens || []), {
    href: t.href,
    title: t.title || null
  }),
  renderMarkdown: (t, n) => {
    var e;
    const o = ((e = t.attrs) == null ? void 0 : e.href) || "";
    return `[${n.renderChildren(t)}](${o})`;
  },
  addCommands() {
    return {
      setLink: (t) => ({ chain: n }) => {
        const { href: e } = t;
        return this.options.isAllowedUri(e, {
          defaultValidate: (o) => !!D(o, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        }) ? n().setMark(this.name, t).setMeta("preventAutolink", !0).run() : !1;
      },
      toggleLink: (t) => ({ chain: n }) => {
        const { href: e } = t || {};
        return e && !this.options.isAllowedUri(e, {
          defaultValidate: (o) => !!D(o, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        }) ? !1 : n().toggleMark(this.name, t, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run();
      },
      unsetLink: () => ({ chain: t }) => t().unsetMark(this.name, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run()
    };
  },
  addPasteRules() {
    return [
      ve({
        find: (t) => {
          const n = [];
          if (t) {
            const { protocols: e, defaultProtocol: o } = this.options, s = be(t).filter(
              (i) => i.isLink && this.options.isAllowedUri(i.value, {
                defaultValidate: (a) => !!D(a, e),
                protocols: e,
                defaultProtocol: o
              })
            );
            s.length && s.forEach((i) => {
              this.options.shouldAutoLink(i.value) && n.push({
                text: i.value,
                data: {
                  href: i.href
                },
                index: i.start
              });
            });
          }
          return n;
        },
        type: this.type,
        getAttributes: (t) => {
          var n;
          return {
            href: (n = t.data) == null ? void 0 : n.href
          };
        }
      })
    ];
  },
  addProseMirrorPlugins() {
    const t = [], { protocols: n, defaultProtocol: e } = this.options;
    return this.options.autolink && t.push(
      rn({
        type: this.type,
        defaultProtocol: this.options.defaultProtocol,
        validate: (o) => this.options.isAllowedUri(o, {
          defaultValidate: (s) => !!D(s, n),
          protocols: n,
          defaultProtocol: e
        }),
        shouldAutoLink: this.options.shouldAutoLink
      })
    ), this.options.openOnClick === !0 && t.push(
      an({
        type: this.type,
        editor: this.editor,
        enableClickSelection: this.options.enableClickSelection
      })
    ), this.options.linkOnPaste && t.push(
      ln({
        editor: this.editor,
        defaultProtocol: this.options.defaultProtocol,
        type: this.type,
        shouldAutoLink: this.options.shouldAutoLink
      })
    ), t;
  }
});
const un = cn.extend({
  addAttributes() {
    return {
      ...this.parent?.(),
      title: {
        default: null,
        parseHTML: (t) => t.getAttribute("title"),
        renderHTML: (t) => t.title ? {
          title: t.title
        } : {}
      }
    };
  }
});
function mn() {
  Ue({
    extensions: [
      un.configure({
        openOnClick: !1,
        defaultProtocol: "https",
        protocols: ["http", "https", "t3"]
      })
    ],
    commands: [
      {
        id: "link",
        label: "Link",
        iconIdentifier: "link",
        position: {
          toolbarGroupId: "formatting",
          bubbleMenuGroupId: !1
        },
        status: {
          isActive: ({ editor: t }) => t.isActive("link"),
          isDisabled: ({ editor: t }) => {
            const n = t.can().setLink({ href: "" }), e = t.isActive("link"), o = t.state.selection.empty;
            return !n || o && !e;
          }
        },
        onExecute: ({ editor: t, linkBrowserUrl: n }) => {
          const e = new URL(n, window.location.origin);
          if (t.isActive("link")) {
            const s = t.getAttributes("link");
            Pe(s).filter(([, i]) => !!i).forEach(([i, a]) => {
              const l = i === "href" ? "url" : encodeURIComponent(i);
              e.searchParams.set(`P[curUrl][${l}]`, a);
            });
          }
          xt.advanced({
            type: xt.types.iframe,
            title: "Set Link",
            content: e.toString(),
            size: xt.sizes.large,
            callback: (s) => {
              s.userData.editor = t;
            }
          });
        }
      }
    ]
  });
}
export {
  un as CustomLink,
  mn as default
};
