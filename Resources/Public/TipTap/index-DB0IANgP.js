import { M as Ne, m as Ie, g as le, P as qt, a as Yt, G as Pe, a7 as He, Y as ve, ae as we, a5 as xe } from "./index-CXcNTZf2.js";
const De = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4w0s2x0a2z0ure5ba0by2idu3namex4d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dad1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3nd0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0axi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp3ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mögensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2", Me = "ελ1υ2бг1ел3дети4ею2католик6ом3мкд2он1сква6онлайн5рг3рус2ф2сайт3рб3укр3қаз3հայ3ישראל5קום3ابوظبي5رامكو5لاردن4بحرين5جزائر5سعودية6عليان5مغرب5مارات5یران5بارت2زار4يتك3ھارت5تونس4سودان3رية5شبكة4عراق2ب2مان4فلسطين6قطر3كاثوليك6وم3مصر2ليسيا5وريتانيا7قع4همراه5پاکستان7ڀارت4कॉम3नेट3भारत0म्3ोत5संगठन5বাংলা5ভারত2ৰত4ਭਾਰਤ4ભારત4ଭାରତ4இந்தியா6லங்கை6சிங்கப்பூர்11భారత్5ಭಾರತ4ഭാരതം5ලංකා4คอม3ไทย3ລາວ3გე2みんな3アマゾン4クラウド4グーグル4コム2ストア3セール3ファッション6ポイント4世界2中信1国1國1文网3亚马逊3企业2佛山2信息2健康2八卦2公司1益2台湾1灣2商城1店1标2嘉里0大酒店5在线2大拿2天主教3娱乐2家電2广东2微博2慈善2我爱你3手机2招聘2政务1府2新加坡2闻2时尚2書籍2机构2淡马锡3游戏2澳門2点看2移动2组织机构4网址1店1站1络2联通2谷歌2购物2通販2集团2電訊盈科4飞利浦3食品2餐厅2香格里拉3港2닷넷1컴2삼성2한국2", zt = "numeric", Wt = "ascii", Ft = "alpha", K = "asciinumeric", F = "alphanumeric", Kt = "domain", me = "emoji", Ue = "scheme", je = "slashscheme", xt = "whitespace";
function Be(t, n) {
  return t in n || (n[t] = []), n[t];
}
function M(t, n, e) {
  n[zt] && (n[K] = !0, n[F] = !0), n[Wt] && (n[K] = !0, n[Ft] = !0), n[K] && (n[F] = !0), n[Ft] && (n[F] = !0), n[F] && (n[Kt] = !0), n[me] && (n[Kt] = !0);
  for (const s in n) {
    const o = Be(s, e);
    o.indexOf(t) < 0 && o.push(t);
  }
}
function ze(t, n) {
  const e = {};
  for (const s in n)
    n[s].indexOf(t) >= 0 && (e[s] = !0);
  return e;
}
function R(t = null) {
  this.j = {}, this.jr = [], this.jd = null, this.t = t;
}
R.groups = {};
R.prototype = {
  accepts() {
    return !!this.t;
  },
  /**
   * Follow an existing transition from the given input to the next state.
   * Does not mutate.
   * @param {string} input character or token type to transition on
   * @returns {?State<T>} the next state, if any
   */
  go(t) {
    const n = this, e = n.j[t];
    if (e)
      return e;
    for (let s = 0; s < n.jr.length; s++) {
      const o = n.jr[s][0], r = n.jr[s][1];
      if (r && o.test(t))
        return r;
    }
    return n.jd;
  },
  /**
   * Whether the state has a transition for the given input. Set the second
   * argument to true to only look for an exact match (and not a default or
   * regular-expression-based transition)
   * @param {string} input
   * @param {boolean} exactOnly
   */
  has(t, n = !1) {
    return n ? t in this.j : !!this.go(t);
  },
  /**
   * Short for "transition all"; create a transition from the array of items
   * in the given list to the same final resulting state.
   * @param {string | string[]} inputs Group of inputs to transition on
   * @param {Transition<T> | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   */
  ta(t, n, e, s) {
    for (let o = 0; o < t.length; o++)
      this.tt(t[o], n, e, s);
  },
  /**
   * Short for "take regexp transition"; defines a transition for this state
   * when it encounters a token which matches the given regular expression
   * @param {RegExp} regexp Regular expression transition (populate first)
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  tr(t, n, e, s) {
    s = s || R.groups;
    let o;
    return n && n.j ? o = n : (o = new R(n), e && s && M(n, e, s)), this.jr.push([t, o]), o;
  },
  /**
   * Short for "take transitions", will take as many sequential transitions as
   * the length of the given input and returns the
   * resulting final state.
   * @param {string | string[]} input
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of token groups
   * @returns {State<T>} taken after the given input
   */
  ts(t, n, e, s) {
    let o = this;
    const r = t.length;
    if (!r)
      return o;
    for (let a = 0; a < r - 1; a++)
      o = o.tt(t[a]);
    return o.tt(t[r - 1], n, e, s);
  },
  /**
   * Short for "take transition", this is a method for building/working with
   * state machines.
   *
   * If a state already exists for the given input, returns it.
   *
   * If a token is specified, that state will emit that token when reached by
   * the linkify engine.
   *
   * If no state exists, it will be initialized with some default transitions
   * that resemble existing default transitions.
   *
   * If a state is given for the second argument, that state will be
   * transitioned to on the given input regardless of what that input
   * previously did.
   *
   * Specify a token group flags to define groups that this token belongs to.
   * The token will be added to corresponding entires in the given groups
   * object.
   *
   * @param {string} input character, token type to transition on
   * @param {T | State<T>} [next] Transition options
   * @param {Flags} [flags] Collections flags to add token to
   * @param {Collections<T>} [groups] Master list of groups
   * @returns {State<T>} taken after the given input
   */
  tt(t, n, e, s) {
    s = s || R.groups;
    const o = this;
    if (n && n.j)
      return o.j[t] = n, n;
    const r = n;
    let a, l = o.go(t);
    if (l ? (a = new R(), Object.assign(a.j, l.j), a.jr.push.apply(a.jr, l.jr), a.jd = l.jd, a.t = l.t) : a = new R(), r) {
      if (s)
        if (a.t && typeof a.t == "string") {
          const f = Object.assign(ze(a.t, s), e);
          M(r, f, s);
        } else e && M(r, e, s);
      a.t = r;
    }
    return o.j[t] = a, a;
  }
};
const c = (t, n, e, s, o) => t.ta(n, e, s, o), A = (t, n, e, s, o) => t.tr(n, e, s, o), ce = (t, n, e, s, o) => t.ts(n, e, s, o), i = (t, n, e, s, o) => t.tt(n, e, s, o), H = "WORD", Gt = "UWORD", Ee = "ASCIINUMERICAL", Ae = "ALPHANUMERICAL", Y = "LOCALHOST", _t = "TLD", Qt = "UTLD", et = "SCHEME", j = "SLASH_SCHEME", Jt = "NUM", $t = "WS", Vt = "NL", G = "OPENBRACE", _ = "CLOSEBRACE", nt = "OPENBRACKET", st = "CLOSEBRACKET", ot = "OPENPAREN", it = "CLOSEPAREN", rt = "OPENANGLEBRACKET", at = "CLOSEANGLEBRACKET", lt = "FULLWIDTHLEFTPAREN", ct = "FULLWIDTHRIGHTPAREN", ut = "LEFTCORNERBRACKET", dt = "RIGHTCORNERBRACKET", ht = "LEFTWHITECORNERBRACKET", ft = "RIGHTWHITECORNERBRACKET", pt = "FULLWIDTHLESSTHAN", gt = "FULLWIDTHGREATERTHAN", mt = "AMPERSAND", Et = "APOSTROPHE", At = "ASTERISK", w = "AT", Lt = "BACKSLASH", kt = "BACKTICK", Tt = "CARET", x = "COLON", Xt = "COMMA", Ct = "DOLLAR", S = "DOT", Rt = "EQUALS", Zt = "EXCLAMATION", b = "HYPHEN", Q = "PERCENT", yt = "PIPE", Ot = "PLUS", bt = "POUND", $ = "QUERY", te = "QUOTE", Le = "FULLWIDTHMIDDLEDOT", ee = "SEMI", N = "SLASH", q = "TILDE", St = "UNDERSCORE", ke = "EMOJI", Nt = "SYM";
var Te = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ALPHANUMERICAL: Ae,
  AMPERSAND: mt,
  APOSTROPHE: Et,
  ASCIINUMERICAL: Ee,
  ASTERISK: At,
  AT: w,
  BACKSLASH: Lt,
  BACKTICK: kt,
  CARET: Tt,
  CLOSEANGLEBRACKET: at,
  CLOSEBRACE: _,
  CLOSEBRACKET: st,
  CLOSEPAREN: it,
  COLON: x,
  COMMA: Xt,
  DOLLAR: Ct,
  DOT: S,
  EMOJI: ke,
  EQUALS: Rt,
  EXCLAMATION: Zt,
  FULLWIDTHGREATERTHAN: gt,
  FULLWIDTHLEFTPAREN: lt,
  FULLWIDTHLESSTHAN: pt,
  FULLWIDTHMIDDLEDOT: Le,
  FULLWIDTHRIGHTPAREN: ct,
  HYPHEN: b,
  LEFTCORNERBRACKET: ut,
  LEFTWHITECORNERBRACKET: ht,
  LOCALHOST: Y,
  NL: Vt,
  NUM: Jt,
  OPENANGLEBRACKET: rt,
  OPENBRACE: G,
  OPENBRACKET: nt,
  OPENPAREN: ot,
  PERCENT: Q,
  PIPE: yt,
  PLUS: Ot,
  POUND: bt,
  QUERY: $,
  QUOTE: te,
  RIGHTCORNERBRACKET: dt,
  RIGHTWHITECORNERBRACKET: ft,
  SCHEME: et,
  SEMI: ee,
  SLASH: N,
  SLASH_SCHEME: j,
  SYM: Nt,
  TILDE: q,
  TLD: _t,
  UNDERSCORE: St,
  UTLD: Qt,
  UWORD: Gt,
  WORD: H,
  WS: $t
});
const I = /[a-z]/, W = /\p{L}/u, Dt = /\p{Emoji}/u, P = /\d/, Mt = /\s/, ue = "\r", Ut = `
`, We = "️", Fe = "‍", jt = "￼";
let X = null, Z = null;
function Ke(t = []) {
  const n = {};
  R.groups = n;
  const e = new R();
  X == null && (X = de(De)), Z == null && (Z = de(Me)), i(e, "'", Et), i(e, "{", G), i(e, "}", _), i(e, "[", nt), i(e, "]", st), i(e, "(", ot), i(e, ")", it), i(e, "<", rt), i(e, ">", at), i(e, "（", lt), i(e, "）", ct), i(e, "「", ut), i(e, "」", dt), i(e, "『", ht), i(e, "』", ft), i(e, "＜", pt), i(e, "＞", gt), i(e, "&", mt), i(e, "*", At), i(e, "@", w), i(e, "`", kt), i(e, "^", Tt), i(e, ":", x), i(e, ",", Xt), i(e, "$", Ct), i(e, ".", S), i(e, "=", Rt), i(e, "!", Zt), i(e, "-", b), i(e, "%", Q), i(e, "|", yt), i(e, "+", Ot), i(e, "#", bt), i(e, "?", $), i(e, '"', te), i(e, "/", N), i(e, ";", ee), i(e, "~", q), i(e, "_", St), i(e, "\\", Lt), i(e, "・", Le);
  const s = A(e, P, Jt, {
    [zt]: !0
  });
  A(s, P, s);
  const o = A(s, I, Ee, {
    [K]: !0
  }), r = A(s, W, Ae, {
    [F]: !0
  }), a = A(e, I, H, {
    [Wt]: !0
  });
  A(a, P, o), A(a, I, a), A(o, P, o), A(o, I, o);
  const l = A(e, W, Gt, {
    [Ft]: !0
  });
  A(l, I), A(l, P, r), A(l, W, l), A(r, P, r), A(r, I), A(r, W, r);
  const f = i(e, Ut, Vt, {
    [xt]: !0
  }), d = i(e, ue, $t, {
    [xt]: !0
  }), h = A(e, Mt, $t, {
    [xt]: !0
  });
  i(e, jt, h), i(d, Ut, f), i(d, jt, h), A(d, Mt, h), i(h, ue), i(h, Ut), A(h, Mt, h), i(h, jt, h);
  const u = A(e, Dt, ke, {
    [me]: !0
  });
  i(u, "#"), A(u, Dt, u), i(u, We, u);
  const g = i(u, Fe);
  i(g, "#"), A(g, Dt, u);
  const m = [[I, a], [P, o]], y = [[I, null], [W, l], [P, r]];
  for (let L = 0; L < X.length; L++)
    v(e, X[L], _t, H, m);
  for (let L = 0; L < Z.length; L++)
    v(e, Z[L], Qt, Gt, y);
  M(_t, {
    tld: !0,
    ascii: !0
  }, n), M(Qt, {
    utld: !0,
    alpha: !0
  }, n), v(e, "file", et, H, m), v(e, "mailto", et, H, m), v(e, "http", j, H, m), v(e, "https", j, H, m), v(e, "ftp", j, H, m), v(e, "ftps", j, H, m), M(et, {
    scheme: !0,
    ascii: !0
  }, n), M(j, {
    slashscheme: !0,
    ascii: !0
  }, n), t = t.sort((L, T) => L[0] > T[0] ? 1 : -1);
  for (let L = 0; L < t.length; L++) {
    const T = t[L][0], k = t[L][1] ? {
      [Ue]: !0
    } : {
      [je]: !0
    };
    T.indexOf("-") >= 0 ? k[Kt] = !0 : I.test(T) ? P.test(T) ? k[K] = !0 : k[Wt] = !0 : k[zt] = !0, ce(e, T, T, k);
  }
  return ce(e, "localhost", Y, {
    ascii: !0
  }), e.jd = new R(Nt), {
    start: e,
    tokens: Object.assign({
      groups: n
    }, Te)
  };
}
function Ce(t, n) {
  const e = Ge(n.replace(/[A-Z]/g, (l) => l.toLowerCase())), s = e.length, o = [];
  let r = 0, a = 0;
  for (; a < s; ) {
    let l = t, f = null, d = 0, h = null, u = -1, g = -1;
    for (; a < s && (f = l.go(e[a])); )
      l = f, l.accepts() ? (u = 0, g = 0, h = l) : u >= 0 && (u += e[a].length, g++), d += e[a].length, r += e[a].length, a++;
    r -= u, a -= g, d -= u, o.push({
      t: h.t,
      // token type/name
      v: n.slice(r - d, r),
      // string value
      s: r - d,
      // start index
      e: r
      // end index (excluding)
    });
  }
  return o;
}
function Ge(t) {
  const n = [], e = t.length;
  let s = 0;
  for (; s < e; ) {
    let o = t.charCodeAt(s), r, a = o < 55296 || o > 56319 || s + 1 === e || (r = t.charCodeAt(s + 1)) < 56320 || r > 57343 ? t[s] : t.slice(s, s + 2);
    n.push(a), s += a.length;
  }
  return n;
}
function v(t, n, e, s, o) {
  let r;
  const a = n.length;
  for (let l = 0; l < a - 1; l++) {
    const f = n[l];
    t.j[f] ? r = t.j[f] : (r = new R(s), r.jr = o.slice(), t.j[f] = r), t = r;
  }
  return r = new R(e), r.jr = o.slice(), t.j[n[a - 1]] = r, r;
}
function de(t) {
  const n = [], e = [];
  let s = 0, o = "0123456789";
  for (; s < t.length; ) {
    let r = 0;
    for (; o.indexOf(t[s + r]) >= 0; )
      r++;
    if (r > 0) {
      n.push(e.join(""));
      for (let a = parseInt(t.substring(s, s + r), 10); a > 0; a--)
        e.pop();
      s += r;
    } else
      e.push(t[s]), s++;
  }
  return n;
}
const J = {
  defaultProtocol: "http",
  events: null,
  format: he,
  formatHref: he,
  nl2br: !1,
  tagName: "a",
  target: null,
  rel: null,
  validate: !0,
  truncate: 1 / 0,
  className: null,
  attributes: null,
  ignoreTags: [],
  render: null
};
function ne(t, n = null) {
  let e = Object.assign({}, J);
  t && (e = Object.assign(e, t instanceof ne ? t.o : t));
  const s = e.ignoreTags, o = [];
  for (let r = 0; r < s.length; r++)
    o.push(s[r].toUpperCase());
  this.o = e, n && (this.defaultRender = n), this.ignoreTags = o;
}
ne.prototype = {
  o: J,
  /**
   * @type string[]
   */
  ignoreTags: [],
  /**
   * @param {IntermediateRepresentation} ir
   * @returns {any}
   */
  defaultRender(t) {
    return t;
  },
  /**
   * Returns true or false based on whether a token should be displayed as a
   * link based on the user options.
   * @param {MultiToken} token
   * @returns {boolean}
   */
  check(t) {
    return this.get("validate", t.toString(), t);
  },
  // Private methods
  /**
   * Resolve an option's value based on the value of the option and the given
   * params. If operator and token are specified and the target option is
   * callable, automatically calls the function with the given argument.
   * @template {keyof Opts} K
   * @param {K} key Name of option to use
   * @param {string} [operator] will be passed to the target option if it's a
   * function. If not specified, RAW function value gets returned
   * @param {MultiToken} [token] The token from linkify.tokenize
   * @returns {Opts[K] | any}
   */
  get(t, n, e) {
    const s = n != null;
    let o = this.o[t];
    return o && (typeof o == "object" ? (o = e.t in o ? o[e.t] : J[t], typeof o == "function" && s && (o = o(n, e))) : typeof o == "function" && s && (o = o(n, e.t, e)), o);
  },
  /**
   * @template {keyof Opts} L
   * @param {L} key Name of options object to use
   * @param {string} [operator]
   * @param {MultiToken} [token]
   * @returns {Opts[L] | any}
   */
  getObj(t, n, e) {
    let s = this.o[t];
    return typeof s == "function" && n != null && (s = s(n, e.t, e)), s;
  },
  /**
   * Convert the given token to a rendered element that may be added to the
   * calling-interface's DOM
   * @param {MultiToken} token Token to render to an HTML element
   * @returns {any} Render result; e.g., HTML string, DOM element, React
   *   Component, etc.
   */
  render(t) {
    const n = t.render(this);
    return (this.get("render", null, t) || this.defaultRender)(n, t.t, t);
  }
};
function he(t) {
  return t;
}
function Re(t, n) {
  this.t = "token", this.v = t, this.tk = n;
}
Re.prototype = {
  isLink: !1,
  /**
   * Return the string this token represents.
   * @return {string}
   */
  toString() {
    return this.v;
  },
  /**
   * What should the value for this token be in the `href` HTML attribute?
   * Returns the `.toString` value by default.
   * @param {string} [scheme]
   * @return {string}
   */
  toHref(t) {
    return this.toString();
  },
  /**
   * @param {Options} options Formatting options
   * @returns {string}
   */
  toFormattedString(t) {
    const n = this.toString(), e = t.get("truncate", n, this), s = t.get("format", n, this);
    return e && s.length > e ? s.substring(0, e) + "…" : s;
  },
  /**
   *
   * @param {Options} options
   * @returns {string}
   */
  toFormattedHref(t) {
    return t.get("formatHref", this.toHref(t.get("defaultProtocol")), this);
  },
  /**
   * The start index of this token in the original input string
   * @returns {number}
   */
  startIndex() {
    return this.tk[0].s;
  },
  /**
   * The end index of this token in the original input string (up to this
   * index but not including it)
   * @returns {number}
   */
  endIndex() {
    return this.tk[this.tk.length - 1].e;
  },
  /**
  	Returns an object  of relevant values for this token, which includes keys
  	* type - Kind of token ('url', 'email', etc.)
  	* value - Original text
  	* href - The value that should be added to the anchor tag's href
  		attribute
  		@method toObject
  	@param {string} [protocol] `'http'` by default
  */
  toObject(t = J.defaultProtocol) {
    return {
      type: this.t,
      value: this.toString(),
      isLink: this.isLink,
      href: this.toHref(t),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   *
   * @param {Options} options Formatting option
   */
  toFormattedObject(t) {
    return {
      type: this.t,
      value: this.toFormattedString(t),
      isLink: this.isLink,
      href: this.toFormattedHref(t),
      start: this.startIndex(),
      end: this.endIndex()
    };
  },
  /**
   * Whether this token should be rendered as a link according to the given options
   * @param {Options} options
   * @returns {boolean}
   */
  validate(t) {
    return t.get("validate", this.toString(), this);
  },
  /**
   * Return an object that represents how this link should be rendered.
   * @param {Options} options Formattinng options
   */
  render(t) {
    const n = this, e = this.toHref(t.get("defaultProtocol")), s = t.get("formatHref", e, this), o = t.get("tagName", e, n), r = this.toFormattedString(t), a = {}, l = t.get("className", e, n), f = t.get("target", e, n), d = t.get("rel", e, n), h = t.getObj("attributes", e, n), u = t.getObj("events", e, n);
    return a.href = s, l && (a.class = l), f && (a.target = f), d && (a.rel = d), h && Object.assign(a, h), {
      tagName: o,
      attributes: a,
      content: r,
      eventListeners: u
    };
  }
};
function It(t, n) {
  class e extends Re {
    constructor(o, r) {
      super(o, r), this.t = t;
    }
  }
  for (const s in n)
    e.prototype[s] = n[s];
  return e.t = t, e;
}
const fe = It("email", {
  isLink: !0,
  toHref() {
    return "mailto:" + this.toString();
  }
}), pe = It("text"), _e = It("nl"), tt = It("url", {
  isLink: !0,
  /**
  	Lowercases relevant parts of the domain and adds the protocol if
  	required. Note that this will not escape unsafe HTML characters in the
  	URL.
  		@param {string} [scheme] default scheme (e.g., 'https')
  	@return {string} the full href
  */
  toHref(t = J.defaultProtocol) {
    return this.hasProtocol() ? this.v : `${t}://${this.v}`;
  },
  /**
   * Check whether this URL token has a protocol
   * @return {boolean}
   */
  hasProtocol() {
    const t = this.tk;
    return t.length >= 2 && t[0].t !== Y && t[1].t === x;
  }
}), O = (t) => new R(t);
function Qe({
  groups: t
}) {
  const n = t.domain.concat([mt, At, w, Lt, kt, Tt, Ct, Rt, b, Jt, Q, yt, Ot, bt, N, Nt, q, St]), e = [Et, x, Xt, S, Zt, Q, $, te, ee, rt, at, G, _, st, nt, ot, it, lt, ct, ut, dt, ht, ft, pt, gt], s = [mt, Et, At, Lt, kt, Tt, Ct, Rt, b, G, _, Q, yt, Ot, bt, $, N, Nt, q, St], o = O(), r = i(o, q);
  c(r, s, r), c(r, t.domain, r);
  const a = O(), l = O(), f = O();
  c(o, t.domain, a), c(o, t.scheme, l), c(o, t.slashscheme, f), c(a, s, r), c(a, t.domain, a);
  const d = i(a, w);
  i(r, w, d), i(l, w, d), i(f, w, d);
  const h = i(r, S);
  c(h, s, r), c(h, t.domain, r);
  const u = O();
  c(d, t.domain, u), c(u, t.domain, u);
  const g = i(u, S);
  c(g, t.domain, u);
  const m = O(fe);
  c(g, t.tld, m), c(g, t.utld, m), i(d, Y, m);
  const y = i(u, b);
  i(y, b, y), c(y, t.domain, u), c(m, t.domain, u), i(m, S, g), i(m, b, y);
  const L = i(m, x);
  c(L, t.numeric, fe);
  const T = i(a, b), p = i(a, S);
  i(T, b, T), c(T, t.domain, a), c(p, s, r), c(p, t.domain, a);
  const k = O(tt);
  c(p, t.tld, k), c(p, t.utld, k), c(k, t.domain, a), c(k, s, r), i(k, S, p), i(k, b, T), i(k, w, d);
  const Oe = i(k, x), ie = O(tt);
  c(Oe, t.numeric, ie);
  const C = O(tt), B = O();
  c(C, n, C), c(C, e, B), c(B, n, C), c(B, e, B), i(k, N, C), i(ie, N, C);
  const Pt = i(l, x), be = i(f, x), Se = i(be, N), Ht = i(Se, N);
  c(l, t.domain, a), i(l, S, p), i(l, b, T), c(f, t.domain, a), i(f, S, p), i(f, b, T), c(Pt, t.domain, C), i(Pt, N, C), i(Pt, $, C), c(Ht, t.domain, C), c(Ht, n, C), i(Ht, N, C);
  const re = [
    [G, _],
    // {}
    [nt, st],
    // []
    [ot, it],
    // ()
    [rt, at],
    // <>
    [lt, ct],
    // （）
    [ut, dt],
    // 「」
    [ht, ft],
    // 『』
    [pt, gt]
    // ＜＞
  ];
  for (let vt = 0; vt < re.length; vt++) {
    const [ae, wt] = re[vt], V = i(C, ae);
    i(B, ae, V), i(V, wt, C);
    const U = O(tt);
    c(V, n, U);
    const z = O();
    c(V, e), c(U, n, U), c(U, e, z), c(z, n, U), c(z, e, z), i(U, wt, C), i(z, wt, C);
  }
  return i(o, Y, k), i(o, Vt, _e), {
    start: o,
    tokens: Te
  };
}
function $e(t, n, e) {
  let s = e.length, o = 0, r = [], a = [];
  for (; o < s; ) {
    let l = t, f = null, d = null, h = 0, u = null, g = -1;
    for (; o < s && !(f = l.go(e[o].t)); )
      a.push(e[o++]);
    for (; o < s && (d = f || l.go(e[o].t)); )
      f = null, l = d, l.accepts() ? (g = 0, u = l) : g >= 0 && g++, o++, h++;
    if (g < 0)
      o -= h, o < s && (a.push(e[o]), o++);
    else {
      a.length > 0 && (r.push(Bt(pe, n, a)), a = []), o -= g, h -= g;
      const m = u.t, y = e.slice(o - h, o);
      r.push(Bt(m, n, y));
    }
  }
  return a.length > 0 && r.push(Bt(pe, n, a)), r;
}
function Bt(t, n, e) {
  const s = e[0].s, o = e[e.length - 1].e, r = n.slice(s, o);
  return new t(r, e);
}
const qe = typeof console < "u" && console && console.warn || (() => {
}), Ye = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.", E = {
  scanner: null,
  parser: null,
  tokenQueue: [],
  pluginQueue: [],
  customSchemes: [],
  initialized: !1
};
function Je() {
  return R.groups = {}, E.scanner = null, E.parser = null, E.tokenQueue = [], E.pluginQueue = [], E.customSchemes = [], E.initialized = !1, E;
}
function ge(t, n = !1) {
  if (E.initialized && qe(`linkifyjs: already initialized - will not register custom scheme "${t}" ${Ye}`), !/^[0-9a-z]+(-[0-9a-z]+)*$/.test(t))
    throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`);
  E.customSchemes.push([t, n]);
}
function Ve() {
  E.scanner = Ke(E.customSchemes);
  for (let t = 0; t < E.tokenQueue.length; t++)
    E.tokenQueue[t][1]({
      scanner: E.scanner
    });
  E.parser = Qe(E.scanner.tokens);
  for (let t = 0; t < E.pluginQueue.length; t++)
    E.pluginQueue[t][1]({
      scanner: E.scanner,
      parser: E.parser
    });
  return E.initialized = !0, E;
}
function se(t) {
  return E.initialized || Ve(), $e(E.parser.start, t, Ce(E.scanner.start, t));
}
se.scan = Ce;
function ye(t, n = null, e = null) {
  if (n && typeof n == "object") {
    if (e)
      throw Error(`linkifyjs: Invalid link type ${n}; must be a string`);
    e = n, n = null;
  }
  const s = new ne(e), o = se(t), r = [];
  for (let a = 0; a < o.length; a++) {
    const l = o[a];
    l.isLink && (!n || l.t === n) && s.check(l) && r.push(l.toFormattedObject(s));
  }
  return r;
}
var oe = "[\0-   ᠎ -\u2029 　]", Xe = new RegExp(oe), Ze = new RegExp(`${oe}$`), tn = new RegExp(oe, "g");
function en(t) {
  return t.length === 1 ? t[0].isLink : t.length === 3 && t[1].isLink ? ["()", "[]"].includes(t[0].value + t[2].value) : !1;
}
function nn(t) {
  return new qt({
    key: new Yt("autolink"),
    appendTransaction: (n, e, s) => {
      const o = n.some((d) => d.docChanged) && !e.doc.eq(s.doc), r = n.some((d) => d.getMeta("preventAutolink"));
      if (!o || r)
        return;
      const { tr: a } = s, l = Pe(e.doc, [...n]);
      if (He(l).forEach(({ newRange: d }) => {
        const h = ve(s.doc, d, (m) => m.isTextblock);
        let u, g;
        if (h.length > 1)
          u = h[0], g = s.doc.textBetween(
            u.pos,
            u.pos + u.node.nodeSize,
            void 0,
            " "
          );
        else if (h.length) {
          const m = s.doc.textBetween(d.from, d.to, " ", " ");
          if (!Ze.test(m))
            return;
          u = h[0], g = s.doc.textBetween(u.pos, d.to, void 0, " ");
        }
        if (u && g) {
          const m = g.split(Xe).filter(Boolean);
          if (m.length <= 0)
            return !1;
          const y = m[m.length - 1], L = u.pos + g.lastIndexOf(y);
          if (!y)
            return !1;
          const T = se(y).map((p) => p.toObject(t.defaultProtocol));
          if (!en(T))
            return !1;
          T.filter((p) => p.isLink).map((p) => ({
            ...p,
            from: L + p.start + 1,
            to: L + p.end + 1
          })).filter((p) => s.schema.marks.code ? !s.doc.rangeHasMark(p.from, p.to, s.schema.marks.code) : !0).filter((p) => t.validate(p.value)).filter((p) => t.shouldAutoLink(p.value)).forEach((p) => {
            we(p.from, p.to, s.doc).some((k) => k.mark.type === t.type) || a.addMark(
              p.from,
              p.to,
              t.type.create({
                href: p.href
              })
            );
          });
        }
      }), !!a.steps.length)
        return a;
    }
  });
}
function sn(t) {
  return new qt({
    key: new Yt("handleClickLink"),
    props: {
      handleClick: (n, e, s) => {
        var o, r;
        if (s.button !== 0 || !n.editable)
          return !1;
        let a = null;
        if (s.target instanceof HTMLAnchorElement)
          a = s.target;
        else {
          let h = s.target;
          const u = [];
          for (; h.nodeName !== "DIV"; )
            u.push(h), h = h.parentNode;
          a = u.find((g) => g.nodeName === "A");
        }
        if (!a)
          return !1;
        const l = xe(n.state, t.type.name), f = (o = a?.href) != null ? o : l.href, d = (r = a?.target) != null ? r : l.target;
        return t.enableClickSelection && t.editor.commands.extendMarkRange(t.type.name), a && f ? (window.open(f, d), !0) : !1;
      }
    }
  });
}
function on(t) {
  return new qt({
    key: new Yt("handlePasteLink"),
    props: {
      handlePaste: (n, e, s) => {
        const { state: o } = n, { selection: r } = o, { empty: a } = r;
        if (a)
          return !1;
        let l = "";
        s.content.forEach((d) => {
          l += d.textContent;
        });
        const f = ye(l, { defaultProtocol: t.defaultProtocol }).find(
          (d) => d.isLink && d.value === l
        );
        return !l || !f ? !1 : t.editor.commands.setMark(t.type, {
          href: f.href
        });
      }
    }
  });
}
function D(t, n) {
  const e = ["http", "https", "ftp", "ftps", "mailto", "tel", "callto", "sms", "cid", "xmpp"];
  return n && n.forEach((s) => {
    const o = typeof s == "string" ? s : s.scheme;
    o && e.push(o);
  }), !t || t.replace(tn, "").match(
    new RegExp(
      // eslint-disable-next-line no-useless-escape
      `^(?:(?:${e.join("|")}):|[^a-z]|[a-z0-9+.-]+(?:[^a-z+.-:]|$))`,
      "i"
    )
  );
}
var an = Ne.create({
  name: "link",
  priority: 1e3,
  keepOnSplit: !1,
  exitable: !0,
  onCreate() {
    this.options.validate && !this.options.shouldAutoLink && (this.options.shouldAutoLink = this.options.validate, console.warn("The `validate` option is deprecated. Rename to the `shouldAutoLink` option instead.")), this.options.protocols.forEach((t) => {
      if (typeof t == "string") {
        ge(t);
        return;
      }
      ge(t.scheme, t.optionalSlashes);
    });
  },
  onDestroy() {
    Je();
  },
  inclusive() {
    return this.options.autolink;
  },
  addOptions() {
    return {
      openOnClick: !0,
      enableClickSelection: !1,
      linkOnPaste: !0,
      autolink: !0,
      protocols: [],
      defaultProtocol: "http",
      HTMLAttributes: {
        target: "_blank",
        rel: "noopener noreferrer nofollow",
        class: null
      },
      isAllowedUri: (t, n) => !!D(t, n.protocols),
      validate: (t) => !!t,
      shouldAutoLink: (t) => !!t
    };
  },
  addAttributes() {
    return {
      href: {
        default: null,
        parseHTML(t) {
          return t.getAttribute("href");
        }
      },
      target: {
        default: this.options.HTMLAttributes.target
      },
      rel: {
        default: this.options.HTMLAttributes.rel
      },
      class: {
        default: this.options.HTMLAttributes.class
      }
    };
  },
  parseHTML() {
    return [
      {
        tag: "a[href]",
        getAttrs: (t) => {
          const n = t.getAttribute("href");
          return !n || !this.options.isAllowedUri(n, {
            defaultValidate: (e) => !!D(e, this.options.protocols),
            protocols: this.options.protocols,
            defaultProtocol: this.options.defaultProtocol
          }) ? !1 : null;
        }
      }
    ];
  },
  renderHTML({ HTMLAttributes: t }) {
    return this.options.isAllowedUri(t.href, {
      defaultValidate: (n) => !!D(n, this.options.protocols),
      protocols: this.options.protocols,
      defaultProtocol: this.options.defaultProtocol
    }) ? ["a", le(this.options.HTMLAttributes, t), 0] : ["a", le(this.options.HTMLAttributes, { ...t, href: "" }), 0];
  },
  addCommands() {
    return {
      setLink: (t) => ({ chain: n }) => {
        const { href: e } = t;
        return this.options.isAllowedUri(e, {
          defaultValidate: (s) => !!D(s, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        }) ? n().setMark(this.name, t).setMeta("preventAutolink", !0).run() : !1;
      },
      toggleLink: (t) => ({ chain: n }) => {
        const { href: e } = t || {};
        return e && !this.options.isAllowedUri(e, {
          defaultValidate: (s) => !!D(s, this.options.protocols),
          protocols: this.options.protocols,
          defaultProtocol: this.options.defaultProtocol
        }) ? !1 : n().toggleMark(this.name, t, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run();
      },
      unsetLink: () => ({ chain: t }) => t().unsetMark(this.name, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run()
    };
  },
  addPasteRules() {
    return [
      Ie({
        find: (t) => {
          const n = [];
          if (t) {
            const { protocols: e, defaultProtocol: s } = this.options, o = ye(t).filter(
              (r) => r.isLink && this.options.isAllowedUri(r.value, {
                defaultValidate: (a) => !!D(a, e),
                protocols: e,
                defaultProtocol: s
              })
            );
            o.length && o.forEach(
              (r) => n.push({
                text: r.value,
                data: {
                  href: r.href
                },
                index: r.start
              })
            );
          }
          return n;
        },
        type: this.type,
        getAttributes: (t) => {
          var n;
          return {
            href: (n = t.data) == null ? void 0 : n.href
          };
        }
      })
    ];
  },
  addProseMirrorPlugins() {
    const t = [], { protocols: n, defaultProtocol: e } = this.options;
    return this.options.autolink && t.push(
      nn({
        type: this.type,
        defaultProtocol: this.options.defaultProtocol,
        validate: (s) => this.options.isAllowedUri(s, {
          defaultValidate: (o) => !!D(o, n),
          protocols: n,
          defaultProtocol: e
        }),
        shouldAutoLink: this.options.shouldAutoLink
      })
    ), this.options.openOnClick === !0 && t.push(
      sn({
        type: this.type,
        editor: this.editor,
        enableClickSelection: this.options.enableClickSelection
      })
    ), this.options.linkOnPaste && t.push(
      on({
        editor: this.editor,
        defaultProtocol: this.options.defaultProtocol,
        type: this.type
      })
    ), t;
  }
});
export {
  an as L
};
